<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/16/Rust/"/>
    <url>/2023/05/16/Rust/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust-语言基础学习"><a href="#Rust-语言基础学习" class="headerlink" title="Rust 语言基础学习"></a>Rust 语言基础学习</h1><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><ol><li><code>Even Better TOML</code>，支持 .toml 文件完整特性</li><li><code>Error Lens</code>, 更好的获得错误展示</li><li><code>One Dark Pro</code>, 非常好看的 VSCode 主题</li><li><code>CodeLLDB</code>, Debugger 程序</li></ol><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p><code>cargo new hello_world</code></p><p><code>tree</code></p><p><code>cargo run</code> is equal to <code>cargo build</code> + <code>./target/debug/world_hello</code> 默认的是debug模式，编译器不会做任何的优化，编译速度快，运行慢。</p><p>高性能模式，生产发布模式：</p><p><code>cargo run --release</code></p><p><code>cargo build --release</code></p><p><code>cargo check</code> 检查编译能否通过</p><p><code>cargo.toml</code> <strong>项目数据描述文件</strong></p><p><code>cargo.lock</code> <strong>项目依赖详细清单</strong></p><p>在cargo.toml中定义依赖的三种方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">[dependencies]<br>rand = <span class="hljs-string">&quot;0.3&quot;</span><br>hammer = &#123; version = <span class="hljs-string">&quot;0.5.0&quot;</span>&#125;<br>color = &#123; git = <span class="hljs-string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;<br>geometry = &#123; path = <span class="hljs-string">&quot;crates/geometry&quot;</span> &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Uart subsystem</title>
    <link href="/2023/05/15/linux_subsystem/Uart/"/>
    <url>/2023/05/15/linux_subsystem/Uart/</url>
    
    <content type="html"><![CDATA[<h1 id="Uart子系统"><a href="#Uart子系统" class="headerlink" title="Uart子系统"></a>Uart子系统</h1><p>波特率115200，bps每秒传输的bit数。</p><p>每一位1&#x2F;115200秒，传输1byte需要10位（start, data, stop）,那么每秒能传11520byte。</p><p>115200，8n1。8:data，n:校验位不用，1：停止位。</p><h2 id="TTY体系中设备节点的差别"><a href="#TTY体系中设备节点的差别" class="headerlink" title="TTY体系中设备节点的差别"></a>TTY体系中设备节点的差别</h2><p>不关心终端是真实的还是虚拟的，都可以通过&#x2F;dev&#x2F;tty找到当前终端。</p><p><strong>&#x2F;dev&#x2F;console</strong> </p><p>内核的打印信息可以通过cmdline来选择打印到哪个设备。</p><p>console&#x3D;ttyS0 console&#x3D;tty</p><p>console&#x3D;ttyS0时，&#x2F;dev&#x2F;console就是ttyS0</p><p>console&#x3D;ttyN时，&#x2F;dev&#x2F;console就是&#x2F;dev&#x2F;ttyN</p><p>console&#x3D;tty时，&#x2F;dev&#x2F;console就是前台程序的虚拟终端</p><p>console&#x3D;tty0时，&#x2F;dev&#x2F;console就是前台程序的虚拟终端</p><p>console有多个取值时，使用最后一个取值来判断。</p><p><strong>&#x2F;dev&#x2F;tty 和&#x2F;dev&#x2F;tty0区别</strong></p><p><code>/dev/tty</code>表示当前进程的控制终端，也就是当前进程与用户交互的终端。</p><p><code>/dev/tty0</code>则是当前所使用虚拟终端的一个别名</p><h2 id="Linux串口应用编程"><a href="#Linux串口应用编程" class="headerlink" title="Linux串口应用编程"></a>Linux串口应用编程</h2><p><a href="https://digilander.libero.it/robang/rubrica/serial.htm">https://digilander.libero.it/robang/rubrica/serial.htm</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">termios</span> <span class="hljs-title">options</span>;</span><br><br>open(<span class="hljs-string">&quot;/dev/ttyS1&quot;</span>, O_RDWR | O_NOCTTY | O_NDELAY)<span class="hljs-comment">// O_NOCTTY: 不用作控制终端 O_NDELAY: 使I/O变成非阻塞模式</span><br><br><br>fcntl(fd, F_SETFL, <span class="hljs-number">0</span>): <span class="hljs-comment">//读数据时，没有数据则阻塞等待</span><br>fcntl(fd, F_SETFL, FNDELAY): <span class="hljs-comment">//读数据时不等待，没有数据就返回0</span><br><br><br><span class="hljs-comment">/* c_cflag: Control Options */</span><br>options.c_cflag |= (CLOCAL | CREAD); <span class="hljs-comment">// 必须打开 Enable the receiver and set local mode</span><br><br>options.c_cflag &amp;= ~CSIZE; <span class="hljs-comment">/* Mask the character size bits */</span><br>options.c_cflag |= CS8;    <span class="hljs-comment">/* Select 8 data bits */</span><br><br>cfsetispeed(&amp;options, B19200); <span class="hljs-comment">//设置input output波特率</span><br>cfsetospeed(&amp;options, B19200);<br><br>options.c_cflag &amp;= ~PARENB <span class="hljs-comment">// no parity</span><br>options.c_cflag &amp;= ~CSTOPB<br><br>options.c_cflag &amp;= ~CNEW_RTSCTS; <span class="hljs-comment">// RTS CTS</span><br><br><br><span class="hljs-comment">/* c_lflag: Local Options */</span><br>options.c_lflag |= (ICANON | ECHO | ECHOE); <span class="hljs-comment">// 选择规范输入 Canonical Input</span><br>options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); <span class="hljs-comment">// 选择原始输入 Raw Input</span><br><br><span class="hljs-comment">/* c_iflag: Input Options*/</span><br>opt.c_iflag &amp;= ~INPCK;<br><br><span class="hljs-comment">/* c_oflag: Input Options*/</span><br>options.c_oflag &amp;= ~OPOST; <span class="hljs-comment">// raw output. When the OPOST option is disabled, all other option bits in c_oflag are ignored.</span><br><br>tcsetattr(fd, TCSANOW, &amp;options);<br></code></pre></td></tr></table></figure><p>VMIN: 读数据时的最小字节数，没读到这些数据就不返回</p><p>VTIME: 等待第一个数据的时间，比如VTIME&#x3D;1，表示10秒内一个数据都没有的话就返回，如果10秒内至少读到一个字节，就继续等待，完全读到VMIN个数据返回。 VTIME&#x3D;0表示一直等待。</p><p><strong>Timeouts are ignored in canonical input mode or when the *NDELAY* option is set on the file via *open* or *fcntl*.</strong></p><p>raw mode可以设置VMIN和VTIME，canonical input mode不用设置。</p><h2 id="Uart-driver"><a href="#Uart-driver" class="headerlink" title="Uart driver"></a>Uart driver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 8250_dw.c</span><br>serial8250_register_8250_port();<br><br><span class="hljs-comment">//8250_core.c</span><br>serial8250_register_8250_port();<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/12/rCore_uCore/uCore_Chapter3/"/>
    <url>/2023/05/12/rCore_uCore/uCore_Chapter3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GPIO subsystem</title>
    <link href="/2023/05/12/linux_subsystem/GPIO/"/>
    <url>/2023/05/12/linux_subsystem/GPIO/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/41942876">https://zhuanlan.zhihu.com/p/41942876</a></p><p><strong>push pull推挽输出</strong></p><p>推挽输出的最大特点是可以真正能真正的输出高电平和低电平，在两种电平下都具有驱动能力。</p><p><strong>open drain开漏输出</strong></p><p><strong>open source开集输出</strong></p><p>这两种输出的原理和特性基本是类似的，区别在于一个是使用MOS管，其中的”漏”指的就是MOS管的漏极；另一个使用三极管，其中的”集”指的就是MOS三极管的集电极。这两者其实都是和推挽输出相对应的输出模式，由于使用MOS管的情况较多，很多时候就用”开漏输出”这个词代替了开漏输出和开集输出。</p><p>开漏、开集输出最主要的特性就是高电平没有驱动能力，需要借助外部上拉电阻才能真正输出高电平。</p><h1 id="Kernel-doc-General-Purpose-Input-x2F-Output-GPIO"><a href="#Kernel-doc-General-Purpose-Input-x2F-Output-GPIO" class="headerlink" title="Kernel doc: General Purpose Input&#x2F;Output (GPIO)"></a>Kernel doc: General Purpose Input&#x2F;Output (GPIO)</h1><h2 id="GPIO-Driver-Interface"><a href="#GPIO-Driver-Interface" class="headerlink" title="GPIO Driver Interface"></a>GPIO Driver Interface</h2><h3 id="Controller-Drivers-gpio-chip"><a href="#Controller-Drivers-gpio-chip" class="headerlink" title="Controller Drivers: gpio_chip"></a>Controller Drivers: gpio_chip</h3><p><code>struct gpio_chip</code> 抽象gpio controller。</p><p><code>gpiochip_add_data()</code> or <code>devm_gpiochip_add_data()</code>接口用来注册gpio controller。<code>gpiochip_remove()</code>释放gpio controller。</p><p><code>gpiochip_is_request()</code>在gpio controller driver中用于检测某个gpio是否被其他chip占用，没占用返回NULL，占用返回request时传入的string。</p><h3 id="GPIO-electrical-configuration"><a href="#GPIO-electrical-configuration" class="headerlink" title="GPIO electrical configuration"></a>GPIO electrical configuration</h3><p>gpio_chip的<code>.set_config</code>回调用于设置：</p><ul><li>Debouncing</li><li>Single-ended modes (open drain&#x2F;open source)</li><li>Pull up and pull down resistor enablement</li></ul><p>这些属性可以在dts中指定，<code>include/dt-bindings/gpio/gpio.h</code> <code>GPIO_PUSH_PULL</code> <code>GPIO_LINE_OPEN_SOURCE</code> <code>GPIO_OPEN_DRAIN </code>…</p><p>可以设置为<code>gpiochip_generic_config()</code>会调用到<code>pinctrl_gpio_set_config()</code>-&gt;<code>ops-&gt;pin_config_set</code></p><h3 id="GPIO-drivers-providing-IRQs"><a href="#GPIO-drivers-providing-IRQs" class="headerlink" title="GPIO drivers providing IRQs"></a>GPIO drivers providing IRQs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">gpiod_to_irq(); <span class="hljs-comment">// 传入gpio_desc，返回gpio的irq number(软件映射的，不是irq hw id)</span><br>  gpio_chip_hwgpio();<br>    gc-&gt;to_irq();<br>      rts_gpio_to_irq();<br>        irq_linear_revmap();<br><br></code></pre></td></tr></table></figure><h4 id="Cascaded-GPIO-irqchips"><a href="#Cascaded-GPIO-irqchips" class="headerlink" title="Cascaded GPIO irqchips"></a>Cascaded GPIO irqchips</h4><ul><li><p>CHAINED CASCADED GPIO IRQCHIPS：挺多soc上是这种做法，打开<code>CONFIG_GPIOLIB_IRQCHIP</code>设置girq-&gt;parent_handler。gpio controller注册过程中通过<strong>irq_set_chained_handler</strong>设置中断处理函数，因此在中断处理函数中需要chained_irq_enter，chained_irq_exit。</p><ul><li>&#96;&#96;&#96;c<br>static irqreturn_t foo_gpio_irq(int irq, void *data) &#x2F;&#x2F;&#x2F; 中断处理函数<br>chained_irq_enter(…);<br>generic_handle_irq(…);<br>chained_irq_exit(…);<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>- GENERIC CHAINED GPIO IRQCHIPS：rts3917是这种做法，通过**reuqest_irq**进入的rts_irq_handler中断处理函数。发现的每一个gpio都进入generic_handle_irq，最后会到各自irq_desc中通过request_irq的中断处理函数。<br><br>  - ```c<br>    static irqreturn_t rts<span class="hljs-constructor">_irq_handler(<span class="hljs-params">int</span> <span class="hljs-params">irq</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">dev_id</span>)</span><br>        <span class="hljs-keyword">for</span> each detected GPIO IRQ<br>            generic<span class="hljs-constructor">_handle_irq(<span class="hljs-operator">...</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>NESTED THREADED GPIO IRQCHIPS：gpio expander的做法，不深究。</p></li></ul><h3 id="Infrastructure-helpers-for-GPIO-irqchips"><a href="#Infrastructure-helpers-for-GPIO-irqchips" class="headerlink" title="Infrastructure helpers for GPIO irqchips"></a>Infrastructure helpers for GPIO irqchips</h3><p>GPIO子系统有针对中断的一套框架，Kconfig为<code>GPIOLIB_IRQCHIP</code>，rts没有用到就不分析了。可以看文档中具体的解释。</p><p>注意一点，方法一：如果parent_handler赋值了<code>girq-&gt;parent_handler = ftgpio_gpio_irq_handler</code>应该就是上面<code>CHAINED CASCADED GPIO IRQCHIPS</code>的做法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gpiochip_add_data();<br>    gpiochip_add_data_with_key();<br>      gpiochip_add_irqchip();<br>        irq_set_chained_handler_and_data(gc-&gt;irq.parents[i], gc-&gt;irq.parent_handler, data);<br></code></pre></td></tr></table></figure><p>方法二：<code>girq-&gt;parent_handler = NULL</code>，直接在driver中<code>devm_request_threaded_irq</code>对应<code>GENERIC CHAINED GPIO IRQCHIPS</code>的做法。</p><h2 id="GPIO-Descriptor-Consumer-Interface"><a href="#GPIO-Descriptor-Consumer-Interface" class="headerlink" title="GPIO Descriptor Consumer Interface"></a>GPIO Descriptor Consumer Interface</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/gpio.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get_index</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br><span class="hljs-comment">// return NULL 如果没有request到GPIO</span><br><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get_optional</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br></code></pre></td></tr></table></figure><h2 id="GPIO-Mappings"><a href="#GPIO-Mappings" class="headerlink" title="GPIO Mappings"></a>GPIO Mappings</h2><h3 id="device-tree"><a href="#device-tree" class="headerlink" title="device tree"></a>device tree</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">foo_device &#123;<br>        compatible = <span class="hljs-string">&quot;acme,foo&quot;</span>;<br>        ...<br>        led-gpios = &lt;&amp;gpio <span class="hljs-number">15</span> GPIO_ACTIVE_HIGH&gt;, <span class="hljs-comment">/* red */</span><br>                    &lt;&amp;gpio <span class="hljs-number">16</span> GPIO_ACTIVE_HIGH&gt;, <span class="hljs-comment">/* green */</span><br>                    &lt;&amp;gpio <span class="hljs-number">17</span> GPIO_ACTIVE_HIGH&gt;; <span class="hljs-comment">/* blue */</span><br><br>        power-gpios = &lt;&amp;gpio <span class="hljs-number">1</span> GPIO_ACTIVE_LOW&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_desc</span> *<span class="hljs-title">red</span>, *<span class="hljs-title">green</span>, *<span class="hljs-title">blue</span>, *<span class="hljs-title">power</span>;</span><br><br>red = gpiod_get_index(dev, <span class="hljs-string">&quot;led&quot;</span>, <span class="hljs-number">0</span>, GPIOD_OUT_HIGH);<br>green = gpiod_get_index(dev, <span class="hljs-string">&quot;led&quot;</span>, <span class="hljs-number">1</span>, GPIOD_OUT_HIGH);<br>blue = gpiod_get_index(dev, <span class="hljs-string">&quot;led&quot;</span>, <span class="hljs-number">2</span>, GPIOD_OUT_HIGH);<br><br>power = gpiod_get(dev, <span class="hljs-string">&quot;power&quot;</span>, GPIOD_OUT_HIGH);<br></code></pre></td></tr></table></figure><p>gpiod_set_value设置的值是“逻辑值”，不一定等于物理值。</p><h2 id="Sysfs接口"><a href="#Sysfs接口" class="headerlink" title="Sysfs接口"></a>Sysfs接口</h2><p>&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;</p><p>echo 19 &gt; export</p><p>&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpioN&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMA&amp;DMA</title>
    <link href="/2023/05/10/linux_subsystem/CMA&amp;DMA/"/>
    <url>/2023/05/10/linux_subsystem/CMA&amp;DMA/</url>
    
    <content type="html"><![CDATA[<h1 id="Reserved-memory"><a href="#Reserved-memory" class="headerlink" title="Reserved-memory"></a>Reserved-memory</h1><p>参考：<a href="http://www.wowotech.net/memory_management/cma.html">http://www.wowotech.net/memory_management/cma.html</a></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841683/Linux+Reserved+Memory?view=blog">https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841683/Linux+Reserved+Memory?view=blog</a></p><p>&#x2F;Documentation&#x2F;devicetree&#x2F;bindings&#x2F;reserved-memory&#x2F;reserved-memory.txt</p><p>定义了no-map属性的，不会自动映射到虚拟地址，需要自行在driver中映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dts</span><br>reserved: buffer@<span class="hljs-number">0x38000000</span> &#123;<br>    no-<span class="hljs-built_in">map</span>;<br>    reg = &lt;<span class="hljs-number">0x38000000</span> <span class="hljs-number">0x08000000</span>&gt;;<br>&#125;;<br><br><span class="hljs-comment">/* Get reserved memory region from Device-tree */</span><br>np = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">&quot;memory-region&quot;</span>, <span class="hljs-number">0</span>);<br><br>rc = of_address_to_resource(np, <span class="hljs-number">0</span>, &amp;r);<br><br>lp-&gt;paddr = r.start;<br>lp-&gt;vaddr = memremap(r.start, resource_size(&amp;r), MEMREMAP_WB);<br></code></pre></td></tr></table></figure><p>定义”shared-dma-pool” 就可以创建DMA memory pool，使用DMA engine API了。of_reserved_mem_device_init中会帮我们创建映射。（DMA在of_reserved_mem_device_init阶段会进行memremap同上，这个remap不是直接映射的方式）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dts</span><br>reserved: buffer@<span class="hljs-number">0</span> &#123;<br>  compatible = <span class="hljs-string">&quot;shared-dma-pool&quot;</span>;<br>  no-<span class="hljs-built_in">map</span>;<br>  reg = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0x70000000</span> <span class="hljs-number">0x0</span> <span class="hljs-number">0x10000000</span>&gt;;<br>&#125;;<br><br><span class="hljs-comment">/* Initialize reserved memory resources */</span><br>rc = of_reserved_mem_device_init(dev);<br><br><span class="hljs-comment">/* Allocate memory */</span><br>dma_set_coherent_mask(dev, <span class="hljs-number">0xFFFFFFFF</span>);<br>lp-&gt;vaddr = dma_alloc_coherent(dev, ALLOC_SIZE, &amp;lp-&gt;paddr, GFP_KERNEL);<br></code></pre></td></tr></table></figure><p>log:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[    0.000000] Reserved memory: created DMA memory pool at 0x0000000070000000, size 256 MiB<br>[    0.000000] Reserved memory: initialized node buffer@0, compatible id shared-dma-pool<br></code></pre></td></tr></table></figure><p>加上resuable属性，变成CMA pool。（CMA在dma_alloc_coherent时会通过__va宏返回直接映射的虚拟地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">reserved: buffer@<span class="hljs-number">0</span> &#123;<br>  compatible = <span class="hljs-string">&quot;shared-dma-pool&quot;</span>;<br>  reusable;<br>  reg = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0x70000000</span> <span class="hljs-number">0x0</span> <span class="hljs-number">0x10000000</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>log：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">[    <span class="hljs-number">0.000000</span>] Reserved <span class="hljs-keyword">memory</span>: created CMA <span class="hljs-keyword">memory</span> pool at <span class="hljs-number">0x0000000070000000</span>, <span class="hljs-keyword">size</span> <span class="hljs-number">256</span> MiB<br>[    <span class="hljs-number">0.000000</span>] Reserved <span class="hljs-keyword">memory</span>: initialized node buffer@0, compatible id shared-dma-pool<br></code></pre></td></tr></table></figure><p><strong>DMA pool是driver独有的，CMA pool在driver不使用的时候会被共享。</strong></p><h1 id="Dynamic-DMA-mapping-Guide"><a href="#Dynamic-DMA-mapping-Guide" class="headerlink" title="Dynamic DMA mapping Guide"></a>Dynamic DMA mapping Guide</h1><p><a href="https://docs.kernel.org/core-api/dma-api-howto.html">https://docs.kernel.org/core-api/dma-api-howto.html</a></p><h2 id="CPU-and-DMA-addresses"><a href="#CPU-and-DMA-addresses" class="headerlink" title="CPU and DMA addresses"></a>CPU and DMA addresses</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230510112218.png"></p><p>有IOMMU的设备，设备device访问的地址是bus address（等同于dma address），IOMMU负责CPU physical address和bus address的映射。</p><p>嵌入式设备一般没有IOMMU，此时bus address&#x3D;CPU pyhsical address。设备直接访问cpu的物理地址。</p><h2 id="What-memory-is-DMA’able"><a href="#What-memory-is-DMA’able" class="headerlink" title="What memory is DMA’able?"></a>What memory is DMA’able?</h2><p><code>__get_free_page*()</code>, <code>kmalloc()</code>, <code>kmem_cache_alloc()</code>这些分配连续空间地址的都可以dma mapping。</p><p><code>vmalloc()</code>, <code>kmap()</code>不行。</p><h2 id="DMA-addressing-capabilities"><a href="#DMA-addressing-capabilities" class="headerlink" title="DMA addressing capabilities"></a>DMA addressing capabilities</h2><p>设置设备通过DMA能驱动多少位地址，寻址能力。</p><p>同时设置streaming和coherent mapping：</p><p><code>int dma_set_mask_and_coherent(struct device *dev, u64 mask)</code></p><p>只设置streaming mapping：</p><p><code>int dma_set_mask(struct device *dev, u64 mask);</code></p><p>只设置coherent mapping：</p><p><code>int dma_set_coherent_mask(struct device *dev, u64 mask);</code></p><h2 id="Types-of-DMA-mappings"><a href="#Types-of-DMA-mappings" class="headerlink" title="Types of DMA mappings"></a>Types of DMA mappings</h2><ul><li>一致性DMA映射（consistent DMA mappings）。driver初始化时map，shutdown时unmap。<ul><li>不需要考虑cache的影响，也就是说不需要软件进行cache操作，CPU和DMA controller都可以看到对方对DMA buffer的更新。CPU对memory的修改device可以立即感知到，反之亦然。</li><li>一致性的DMA映射并不意味着不需要memory barrier这样的工具来保证memory order。</li><li>在有些平台上，修改了DMA Consistent buffer后，你的驱动可能需要flush write buffer，以便让device侧感知到memory的变化。</li></ul></li><li>流式DMA映射（Streaming DMA mappings）。一次性的，需要进行DMA传输的时候map，DMA传输完成，就ummap。<code>spi-dw-rts.c</code>中ssi的传输就是流式dma映射。</li></ul><h2 id="一致性DMA映射"><a href="#一致性DMA映射" class="headerlink" title="一致性DMA映射"></a>一致性DMA映射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-comment">//cpu_addr:虚拟地址，dma_handle:总线地址，没有IOMMU相当于物理地址</span><br>cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);<br></code></pre></td></tr></table></figure><p>You may however need to make sure to flush the processor’s write buffers before telling devices to read that memory.见下方sync的API。</p><p>如果driver需要许多小的buffer,可以使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">pool</span>;</span><br>pool = dma_pool_create(name, dev, size, align, boundary);<br>cpu_addr = dma_pool_alloc(pool, flags, &amp;dma_handle);<br></code></pre></td></tr></table></figure><h2 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h2><p>流式DMA映射需要设置DMA direction。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DMA_BIDIRECTIONAL<br>DMA_TO_DEVICE<br>DMA_FROM_DEVICE<br>DMA_NONE<br></code></pre></td></tr></table></figure><p>接口一<code>dma_map_single</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-type">void</span> *addr = buffer-&gt;ptr;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口二<code>dma_map_page</code></p><p>因为dma_map_single函数在进行DMA mapping的时候使用的是CPU指针（虚拟地址），导致该函数有一个弊端：不能使用HIGHMEM memory进行mapping。因为HIGHMEM memory没有进行线性映射，所以没有虚拟地址。</p><p>接口三<code>dma_map_sg</code></p><p>用于scatterlist情况，映射的对象是分散的若干段DMA buffer。具体不分析了。</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>如果你需要多次访问同一个streaming DMA buffer，并且在DMA传输之间读写DMA Buffer上的数据，这时候你需要小心进行DMA buffer的sync操作，以便CPU和设备（DMA controller）可以看到最新的、正确的数据。</p><p><code>dma_sync_single_for_cpu(dev, dma_handle, size, direction)</code></p><p>如果，CPU操作了DMA buffer的数据，然后你又想把控制权交给设备上的DMA控制器，让DMA controller访问DMA buffer，这时候，在真正让HW（指DMA控制器）去访问DMA buffer之前，需要：</p><p><code>dma_sync_single_for_device(dev, dma_handle, size, direction)</code></p><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p><a href="https://blog.csdn.net/wangyunqian6/article/details/6670110">https://blog.csdn.net/wangyunqian6/article/details/6670110</a></p><p>DMA是直接操作总线地址的，这里先当作物理地址来看待吧。如果cache缓存的内存区域不包括DMA分配到的区域，那么就没有一致性的问题。但是如果cache缓存包括了DMA目的地址的话，会出现什么什么问题呢？</p><p>问题出在，经过DMA操作，cache缓存对应的内存数据已经被修改了，而CPU本身不知道（DMA传输是不通过CPU的），它仍然认为cache中的数据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用旧的Cache数据。这样就发生Cache与内存的数据“不一致性”错误。</p><p>顺便提一下，总线地址是从设备角度上看到的内存，物理地址是CPU的角度看到的未经过转换的内存（经过转换的是虚拟地址）</p><p>由上面可以看出，DMA如果使用cache，那么一定要考虑cache的一致性。解决DMA导致的一致性的方法最简单的就是禁止DMA目标地址范围内的cache功能。但是这样就会牺牲性能。</p><p>因此在DMA是否使用cache的问题上，可以根据DMA缓冲区期望保留的的时间长短来决策。DAM的映射就分为：<strong>一致性DMA映射</strong>和<strong>流式DMA映射</strong>。</p><p>因为LCD随时都在使用，因此在Frame buffer驱动中，使用一致性DMA映射上面的代码中用到 <strong>dma_alloc_wc</strong>（<strong>non-cache, buffered</strong>）函数，另外还有一个一致性DMA映射函数<strong>dma_alloc_coherent</strong>（<strong>non-cache，non-buffer</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dma_alloc_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">    <span class="hljs-type">dma_addr_t</span> *dma_handle, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> dma_alloc_attrs(dev, size, dma_handle, gfp,<br>      (gfp &amp; __GFP_NOWARN) ? DMA_ATTR_NO_WARN : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dma_alloc_wc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">         <span class="hljs-type">dma_addr_t</span> *dma_addr, <span class="hljs-type">gfp_t</span> gfp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> attrs = DMA_ATTR_WRITE_COMBINE;<br><br>  <span class="hljs-keyword">if</span> (gfp &amp; __GFP_NOWARN)<br>    attrs |= DMA_ATTR_NO_WARN;<br><br>  <span class="hljs-keyword">return</span> dma_alloc_attrs(dev, size, dma_addr, gfp, attrs);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_alloc_attrs();<br>  dma_alloc_from_dev_coherent(); <span class="hljs-comment">// 如果dts有reserved memory会走这个函数</span><br>    dev_get_coherent_memory();<br>      <span class="hljs-keyword">return</span> dev-&gt;dma_mem <span class="hljs-comment">// 直接返回reserved-memory中分配的地址了</span><br>  <span class="hljs-keyword">return</span> cpu_addr;<br><br><span class="hljs-comment">// dev-&gt;mem的分配：</span><br>dma_init_reserved_memory();<br>  ops-&gt;device_init(dma_reserved_default_memory, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reserved_mem_ops</span> <span class="hljs-title">rmem_dma_ops</span> =</span> &#123;<br>  .device_init= rmem_dma_device_init,<br>&#125;;<br>rmem_dma_device_init();<br>  dma_init_coherent_memory();<br>  dma_assign_coherent_memory();<br>    dev-&gt;dma_mem = mem;<br><br></code></pre></td></tr></table></figure><p>看起来如果在dts中分配了reserved-memory，<code>dma_alloc_coherent</code>和<code>dma_alloc_wc</code>流程是一样的，都会走<code>dma_alloc_from_dev_coherent</code>从reserved-memory中分配空间（<strong>这块区域是cached？buffer？</strong>，rts3917启动中有打印：<code>Memory policy: Data cache writeback</code>是否与reserved memory有关系）</p><p><strong>所以rts_fb.c中有<code>dma_sync_single_for_device</code>?</strong></p><table><thead><tr><th>是否启用cache</th><th>是否启用 buffer</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>无cache，无写缓冲<br />读、写都直达外设硬件</td></tr><tr><td>0</td><td>1</td><td>无cache，有写缓冲<br />读操作直达外设硬件；写操作，CPU将数据写入到写缓冲后继续运行，由写缓冲进行写回操作。</td></tr><tr><td>1</td><td>0</td><td>有cache，写通模式write through。<br />数据要同时写入cache和内存，所以cache和内存中的数据保持一致。</td></tr><tr><td>1</td><td>1</td><td>有cache，写回模式write back<br />新数据只是写入cache ，不会立刻写入内存。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinctrl subsystem</title>
    <link href="/2023/05/10/linux_subsystem/Pinctrl/"/>
    <url>/2023/05/10/linux_subsystem/Pinctrl/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">devm_pinctrl_get(<span class="hljs-keyword">struct</span> device *dev) <span class="hljs-comment">//返回一个pinctrl句柄</span><br>  pinctrl_get(<span class="hljs-keyword">struct</span> device *dev)<br>    find_pinctrl(<span class="hljs-keyword">struct</span> device *dev) <span class="hljs-comment">// 查看是否device core已经创建了该pinctrl句柄</span><br>    create_pinctrl(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> pinctrl_dev *pctldev)<br>      pinctrl_dt_to_map(<span class="hljs-keyword">struct</span> pinctrl *p, <span class="hljs-keyword">struct</span> pinctrl_dev *pctldev) <span class="hljs-comment">//从设备树中获取信息保存到pinctrl_map结构体中</span><br>        <span class="hljs-keyword">for</span> (state = <span class="hljs-number">0</span>; ; state++) &#123;<br>          propname = kasprintf(GFP_KERNEL, <span class="hljs-string">&quot;pinctrl-%d&quot;</span>, state); <span class="hljs-comment">//查找pinctrl-0,1,2属性</span><br>                    <span class="hljs-comment">//size保存了pinctrl-0中phandle的个数，比如有的节点pinctrl-0 = &lt;&amp;x1, &amp;x2&gt;</span><br>          prop = of_find_property(np, propname, &amp;size);<br>          <span class="hljs-built_in">list</span> = prop-&gt;value; <span class="hljs-comment">//list保存了phandle列表</span><br>                    <span class="hljs-comment">//保存pinctrl-names index为state的name,比如pinctrl-names = &quot;default&quot;</span><br>          ret = of_property_read_string_index(np, <span class="hljs-string">&quot;pinctrl-names&quot;</span>, state, &amp;statename);<br>          <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                        <span class="hljs-comment">// 如果没有定义pinctrl-names属性，那么我们将pinctrl-0 pinctrl-1 pinctrl-2……中的那个ID取出来作为state name</span><br>            statename = prop-&gt;name + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;pinctrl-&quot;</span>);<br>          <span class="hljs-keyword">for</span> (config = <span class="hljs-number">0</span>; config &lt; size; config++) &#123;<br>            phandle = be32_to_cpup(<span class="hljs-built_in">list</span>++);<br>            np_config = of_find_node_by_phandle(phandle); <span class="hljs-comment">// 找到pinctrl-x=&lt;&amp;x1, &amp;x2&gt;中的config节点</span><br>            dt_to_map_one_config(p, pctldev, statename, np_config);<br>              np_pctldev = of_node_get(np_config);<br>              np_pctldev = of_get_next_parent(np_pctldev); <span class="hljs-comment">// 找到pinctrl controller节点</span><br>              pctldev = get_pinctrl_dev_from_of_node(np_pctldev); <span class="hljs-comment">//找到pinctrl_dev</span><br>                          <span class="hljs-comment">//调用底层的callback函数处理pin configuration node。</span><br>              ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="hljs-built_in">map</span>, &amp;num_maps);<br>                .dt_node_to_map = pinconf_generic_dt_node_to_map_all <span class="hljs-comment">//rts pinctrl 用的框架通用函数</span><br>                    pinconf_generic_dt_node_to_map()<br>                      ret = pinconf_generic_dt_subnode_to_map();<br>                      for_each_available_child_of_node(np_config, np)<br>                                                <span class="hljs-comment">//rts pinctrl每一个config节点下都有子节点 逐个分析子节点</span><br>                        ret = pinconf_generic_dt_subnode_to_map();<br>                      pinconf_generic_parse_dt_config(np, pctldev, &amp;configs, &amp;num_configs);<br>                          <span class="hljs-comment">//将该pin configuration node的mapping entry信息注册到系统中</span><br>              dt_remember_or_free_map(p, statename, pctldev, <span class="hljs-built_in">map</span>, num_maps);<br>          &#125;<br>        &#125;<br>      add_setting(p, pctldev, <span class="hljs-built_in">map</span>); <span class="hljs-comment">// 将pinctrl_map信息传递给pinctrl_mapping, 把这个setting的代码加入到holder中</span><br>        setting-&gt;type = <span class="hljs-built_in">map</span>-&gt;type;<br>        setting-&gt;pctldev = get_pinctrl_dev_from_devname(<span class="hljs-built_in">map</span>-&gt;ctrl_dev_name);<br>        setting-&gt;dev_name = <span class="hljs-built_in">map</span>-&gt;dev_name;<br>        pinmux_map_to_setting(<span class="hljs-built_in">map</span>, setting);<br>        pinconf_map_to_setting(<span class="hljs-built_in">map</span>, setting);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">pinctrl_lookup_state(<span class="hljs-keyword">struct</span> pinctrl *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>  find_state(p, name);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">pinctrl_select_state()<br>  pinctrl_commit_state(p, state);<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>      pinmux_enable_setting(setting);<br>        ops-&gt;set_mux(pctldev, setting-&gt;data.mux.func, setting-&gt;data.mux.group);<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>      pinconf_apply_setting(setting);<br>        <span class="hljs-keyword">switch</span> (setting-&gt;type)<br>          ops-&gt;pin_config_set()<br>          ops-&gt;pin_config_group_set()<br></code></pre></td></tr></table></figure><p>统一驱动设备模型会处理pin control：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_driver_register()<br>  driver_register();<br>    bus_add_driver();<br>      driver_attach();<br>        __driver_attach();<br>          device_driver_attach(drv, dev);<br>            driver_probe_device(drv, dev);<br>              really_probe(dev, drv);<br><br>  really_probe(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)<br>    pinctrl_bind_pins(dev);<br>      devm_pinctrl_get(dev);<br>        pinctrl_lookup_state(dev-&gt;pins-&gt;p, PINCTRL_STATE_DEFAULT);<br>        pinctrl_lookup_state(dev-&gt;pins-&gt;p, PINCTRL_STATE_INIT);<br>        pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;default_state);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB</title>
    <link href="/2023/05/08/GDB/"/>
    <url>/2023/05/08/GDB/</url>
    
    <content type="html"><![CDATA[<p>to do</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Time subsystem</title>
    <link href="/2023/05/08/linux_subsystem/Time/"/>
    <url>/2023/05/08/linux_subsystem/Time/</url>
    
    <content type="html"><![CDATA[<p>CONFIG_GENERIC_CLOCKEVENTS：新的时间子系统</p><p>以下选项三选一：</p><p>CONFIG_HZ_PERIODIC：无论何时，都启用用周期性的tick，即便是在系统idle的时候。</p><p>CONFIG_NO_HZ_IDLE：在系统idle的时候，停掉周期性tick。会同时enable NO_HZ_COMMON。</p><p>CONFIG_NO_HZ_FULL：即便在非idle的状态下，也就是说cpu上还运行在task，也可能会停掉tick。会同时enable NO_HZ_COMMON。</p><p>CONFIG_HIGH_RES_TIMERS：高精度timer。</p><p>如果配置了高精度timer，或者配置了NO_HZ_COMMON的选项，那么一定需要配置CONFIG_TICK_ONESHOT，表示系统支持支持one-shot类型的tick device。</p><h1 id="sysfs接口"><a href="#sysfs接口" class="headerlink" title="sysfs接口"></a>sysfs接口</h1><p>cd &#x2F;sys&#x2F;bus&#x2F;clocksource&#x2F;devices&#x2F;clocksource0</p><p>cat current_clocksource: 查看当前的clocksource</p><p>cat available_clocksource: 查看可用的clocksource</p><p>echo xxx &gt; current_clocksource: 设置clocksource</p><p>cd &#x2F;sys&#x2F;bus&#x2F;clockevents&#x2F;devices&#x2F;clockevent0</p><p>cat current_device: 查看当前的clockevent</p><h1 id="Clocksource"><a href="#Clocksource" class="headerlink" title="Clocksource"></a>Clocksource</h1><h1 id="Clockevent"><a href="#Clockevent" class="headerlink" title="Clockevent"></a>Clockevent</h1>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interrupt subsystem</title>
    <link href="/2023/05/08/linux_subsystem/Interrupt/"/>
    <url>/2023/05/08/linux_subsystem/Interrupt/</url>
    
    <content type="html"><![CDATA[<h1 id="IRQ-domain"><a href="#IRQ-domain" class="headerlink" title="IRQ domain"></a>IRQ domain</h1><p>1、向系统注册irq domain</p><p>interrupt controller初始化的过程中，注册irq domain</p><p><code>irq_domain_add_linear</code></p><p>2、为irq domain创建映射</p><p>在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系。</p><p><em><strong>Interrupt controller初始化的时候会mapping hw id和irq number吗？</strong></em></p><p>方法1：</p><p><code>irq_create_mapping(struct irq_domain *host, irq_hw_number_t hwirq);</code></p><p>比如<code>drivers/clocksource/timer-riscv.c</code>中<code>irq_create_mapping(domain, RV_IRQ_TIMER);</code>直接将hw id(RV_IRQ_TIMER)传入, 创建hw id和irq number的映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_create_mapping(domain, hwirq);<br>  irq_create_mapping_affinity();<br>    irq_domain_alloc_descs(); <span class="hljs-comment">// 创建hw id和irq number的映射</span><br>    irq_domain_associate();<br>      domain-&gt;ops-&gt;<span class="hljs-built_in">map</span>(); <span class="hljs-comment">//调用到interrupt controller的map函数</span><br></code></pre></td></tr></table></figure><p>方法2：</p><p><code>irq_of_parse_and_map</code></p><p>比如<code>drivers/irqchip/irq-realtek-plic.c</code>中<code>irq_of_parse_and_map</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_of_parse_and_map(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">int</span> index);<br>  of_irq_parse_one(dev, index, &amp;oirq); <span class="hljs-comment">// 解析设备树</span><br>  irq_create_of_mapping(&amp;oirq);<br>    irq_create_fwspec_mapping();<br>      irq_create_mapping(domain, hwirq); <span class="hljs-comment">// 最终还是调用到irq_create_mapping</span><br></code></pre></td></tr></table></figure><p>方法3：</p><p>外设driver中直接<code>platform_get_irq</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_get_irq();<br>  platform_get_irq_optional();<br>    of_irq_get();<br>      of_irq_parse_one();<br>      irq_create_of_mapping(); <span class="hljs-comment">// 到这里和上面一样了</span><br></code></pre></td></tr></table></figure><p>级联的第二级interrupt controller调用<code>irq_set_chained_handler</code>设置 interrupt handler</p><p>irq初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init/main.c</span><br>init_IRQ();<br><span class="hljs-comment">//arch/riscv/kernel/irq.c</span><br>init_IRQ();<br>  irqchip_init();<br><span class="hljs-comment">// drivers/irqchip/irqchip.c</span><br>irqchip_init();<br>  of_irq_init();<br>    IRQCHIP_DECLARE(riscv, <span class="hljs-string">&quot;riscv,cpu-intc&quot;</span>, riscv_intc_init); <span class="hljs-comment">// 进入riscv_intc_init</span><br><br></code></pre></td></tr></table></figure><p>risc-v 中断处理流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h1 id="IRQ-desc"><a href="#IRQ-desc" class="headerlink" title="IRQ desc"></a>IRQ desc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> <span class="hljs-title">irq_desc</span>[<span class="hljs-title">NR_IRQS</span>] // 全局<span class="hljs-title">irq_desc</span>数组，每个外设的中断对应一个<span class="hljs-title">irq_desc</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">early_irq_init</span>();</span><br>  desc_set_defaults(); <span class="hljs-comment">// 对每个irq_desc都初始化赋值</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// irq-riscv-intc.c</span><br><span class="hljs-comment">// 每个cpu int都会调用到cpu interrupt controller的map函数，会填充irq_desc。</span><br>irq_create_mapping();<br>domain-&gt;ops-&gt;<span class="hljs-built_in">map</span>;<br>.<span class="hljs-built_in">map</span> = riscv_intc_domain_map();<br>  irq_domain_set_info();<br>    irq_set_chip_and_handler_name(virq, chip, handler, handler_name);<br>      irq_set_chip();<br>        desc-&gt;irq_data.chip = chip;<br>      __irq_set_handler();<br>        desc-&gt;handle_irq = handle; <span class="hljs-comment">// handle是handle_percpu_devid_irq</span><br>    irq_set_chip_data(virq, chip_data); <span class="hljs-comment">// d-&gt;host_data irq_domain_add_linear最后一个参数</span><br>      desc-&gt;irq_data.chip_data = data; <span class="hljs-comment">// irq chip的私有数据</span><br>    irq_set_handler_data(virq, handler_data);<br>      desc-&gt;irq_common_data.handler_data = data; <span class="hljs-comment">// data=NULL</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_get_irq();<br>...<br>irq_create_of_mapping<br>  irq_create_fwspec_mapping<br>    irq_domain_alloc_irqs<br>      __irq_domain_alloc_irqs<br>        irq_domain_alloc_irqs_hierarchy<br>          domain-&gt;ops-&gt;alloc<br>            irq_domain_translate_onecell<br>            plic_irqdomain_map<br>              irq_domain_set_info<br>                ...<br>                  desc-&gt;handle_irq = handle; <span class="hljs-comment">// handle: handle_fasteoi_irq</span><br></code></pre></td></tr></table></figure><p>irq_to_desc的定义 irq_desc + irq 是什么意思？数组加上irq number？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> irq_desc *<span class="hljs-title function_">irq_to_desc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> (irq &lt; NR_IRQS) ? irq_desc + irq : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="risc-v中断处理流程"><a href="#risc-v中断处理流程" class="headerlink" title="risc-v中断处理流程"></a>risc-v中断处理流程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// head.S</span><br>setup_trap_vector:<br>  la a0, handle_exception<br>  csrw CSR_TVEC, a0     <span class="hljs-comment">// handle_exception地址传入CSR_TVEC</span><br>  csrw CSR_SCRATCH, zero   <span class="hljs-comment">// CSR_SCRATCH清零</span><br><br><span class="hljs-comment">// entry.S</span><br>ENTRY(handle_exception)<br>  handle_arch_irq();<br>    set_handle_irq();<br>      riscv_intc_irq();<br>        handle_domain_irq();<br>          __handle_domain_irq();<br>            generic_handle_irq();<br>              generic_handle_irq_desc();<br>                <span class="hljs-comment">// 不同的中断控制器在一开始初始化会设置</span><br>                desc-&gt;handle_irq(desc);<br><span class="hljs-comment">// 这里cpu int会进入handle_percpu_devid_irq, 在irq-riscv-intc.c irq_domain_set_info中设定</span><br>handle_percpu_devid_irq();<br>  action-&gt;handler(); <span class="hljs-comment">// timer-riscv.c 中request_irq会把中断处理函数赋值给action-&gt;handler();</span><br><br><span class="hljs-comment">// external int 会进入plic_handle_irq, 在irq-realtek-plic.c irq_set_chained_handler中设定</span><br>plic_handle_irq();<br>  generic_handle_irq();<br>    generic_handle_irq_desc();<br>      desc-&gt;handle_irq(desc);<br>        handle_fasteoi_irq();<br>          ...<br>                    <span class="hljs-comment">// request_irq中会把自定义的handler function赋值给action-&gt;handler</span><br>                    action-&gt;handler();<br></code></pre></td></tr></table></figure><p><em><strong>是否所有的irq_domain的irq number是按顺序排列下去，每个irq_number设置一个interrupt handler，不会重复？</strong></em></p><h1 id="irq-chip"><a href="#irq-chip" class="headerlink" title="irq_chip"></a>irq_chip</h1><p>need to do.</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uCore_Chapter1 应用程序与基本执行环境</title>
    <link href="/2023/04/25/rCore_uCore/uCore_Chapter1/"/>
    <url>/2023/04/25/rCore_uCore/uCore_Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">make build # 仅编译<br>make run # 编译+运行qemu<br>make run LOG=LOG_LEVEL_TRACE # 其他选项可以看Makefile<br>make clean # rm build/<br>make debug # 编译+运行gdb调试<br></code></pre></td></tr></table></figure><p>每次在make run之前，尽量先执行make clean以删除缓存，特别是在切换ch分支之后。</p><h1 id="ch1"><a href="#ch1" class="headerlink" title="ch1"></a>ch1</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// entry.S</span><br>_entry<br>    la sp, boot_stack_top <span class="hljs-comment">//设置堆栈</span><br>    call main<br><span class="hljs-comment">// main.c</span><br>  clean_bss();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello wrold!\n&quot;</span>);<br>    consputc();<br>      console_putchar(<span class="hljs-type">int</span> c);<br>        sbi_call(SBI_CONSOLE_PUTCHAR, c, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p class="note note-danger">怎么用gdb调试？`file kernel`然后？</p><h2 id="Makefile流程分析"><a href="#Makefile流程分析" class="headerlink" title="Makefile流程分析"></a>Makefile流程分析</h2><p>根据<code>make run </code>打印的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -fno-stack-protector -D LOG_LEVEL_ERROR  -fno-pie -no-pie -c os/console.c -o build/os/console.o<br>... # 编译所有的.c文件成.o文件<br>riscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/sbi.o build/os/printf.o  build/os/entry.o build/os/link_app.o # 链接<br>riscv64-unknown-elf-objdump -S build/kernel &gt; build/kernel.asm<br>riscv64-unknown-elf-objdump -t build/kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27; &gt; build/kernel.sym<br>Build kernel done<br></code></pre></td></tr></table></figure><p>比较熟悉的是<code>objdump -d</code> <code>objdump -D</code>将所有段都反汇编，而<code>-d</code>应该仅反汇编代码段。</p><p><code>objdump -S</code>是在-d的基础上，代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用<code>-g</code>参数，即需要调试信息。</p><p><code>objdump -t</code>打印符号表。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uCore_Chapter2 批处理系统</title>
    <link href="/2023/04/25/rCore_uCore/uCore_Chapter2/"/>
    <url>/2023/04/25/rCore_uCore/uCore_Chapter2/</url>
    
    <content type="html"><![CDATA[<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make -C user clean <span class="hljs-comment"># 在os目录，相当于cd user;make clean;cd ..</span><br>make clean <span class="hljs-comment"># 或者在user目录</span><br>git checkout ch2<br>make user BASE=1 CHAPTER=2<br>make run<br>make test BASE=1 <span class="hljs-comment"># make test 会完成　make user 和 make run 两个步骤（自动设置 CHAPTER）</span><br></code></pre></td></tr></table></figure><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">main();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello wrold!\n&quot;</span>);<br>  trap_init(); <span class="hljs-comment">// 设置中断/异常处理地址</span><br>    w_stvec((uint64)uservec &amp; ~<span class="hljs-number">0x3</span>); <span class="hljs-comment">//把uservec地址传入,uservec在trampoline.S中定义</span><br>      <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw stvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(x))</span>; <span class="hljs-comment">// 设置stvec CSR</span><br>  loader_init();<br>  run_next_app();<br>    load_app();<br>    usertrapret(trapframe, (uint64)boot_stack_top);<br>      w_sepc(trapframe-&gt;epc);<br>      r_sstatus();<br>      w_sstatus();<br>      userret();<br>        sret <span class="hljs-comment">// 返回到sepc中的值，0x80400000第一个app</span><br><br><span class="hljs-comment">// 进入应用程序</span><br><span class="hljs-built_in">exit</span>(MAGIC);<br>  syscall(SYS_exit, code);<br>    __syscall1(n, <span class="hljs-type">long</span>(<span class="hljs-number">1234</span>));<br>      __asm_syscall(<span class="hljs-string">&quot;r&quot;</span>(a7), <span class="hljs-string">&quot;0&quot;</span>(a0));<br>        ecall <span class="hljs-comment">//通过ecall 进入uservec</span><br><br>uservec<br>  <span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span>;<br>    r_scause();<br>    syscall();<br>    usertrapret(); <span class="hljs-comment">// 这里回到第九行一样，循环，执行第二个应用程序</span><br></code></pre></td></tr></table></figure><p>分析下<code>uservec</code>,注意：这里只是把stvec设置为uservec地址，并不会执行uservec下的代码，要等U mode的中断&#x2F;异常到来时才会从uservec开始执行。</p><p class="note note-warning">uservec是U mode异常/中断的入口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl uservec<br>uservec:<br>        csrrw a0, sscratch, a0 # 交换a0和sscratch<br><br>        # save the user registers in TRAPFRAME<br>        sd ra, 40(a0)<br>        sd sp, 48(a0)<br>    ...<br>        sd t6, 280(a0)<br><br>  # save the user a0 in p-&gt;trapframe-&gt;a0<br>        csrr t0, sscratch<br>        sd t0, 112(a0)<br><br>        csrr t1, sepc<br>        sd t1, 24(a0) # BASE_ADDRESS 0x80400000<br><br>        ld sp, 8(a0) # kstack + PGSIZE<br>        ld tp, 32(a0)<br>        ld t1, 0(a0)<br>        # csrw satp, t1<br>        # sfence.vma zero, zero<br>        ld t0, 16(a0)<br>        jr t0<br><br></code></pre></td></tr></table></figure><p>这里需要注意sscratch这个CSR寄存器的作用就是一个cache，它只负责存某一个值，这里它保存的就是trapframe结构体的位置。</p><h1 id="实现批处理操作系统的细节"><a href="#实现批处理操作系统的细节" class="headerlink" title="实现批处理操作系统的细节"></a>实现批处理操作系统的细节</h1><p>从Makefile中可以发现，scripts&#x2F;pack.py，scripts&#x2F;kernelld.py用来生成os&#x2F;link_app.S和os&#x2F;kernel_app.ld。link_app.S将用户程序加入kernel可执行文件中。kernel_app.ld规定了用户程序所在的段(.data.app[x])。在load_app()中将用户程序relocate到0x80400000。</p><p>需要relocate的原因：我们并不能直接跳转到 app_n_start 直接运行，因为用户程序在编译的时候，会假定程序处在虚存的特定位置，而由于我们还没有虚存机制，因此我们在运行之前还需要将用户程序加载到规定的物理内存位置。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V SBI</title>
    <link href="/2023/04/21/sbi/"/>
    <url>/2023/04/21/sbi/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>SBI implementation&#x2F;SEE(Supervisor Execution Environment), 比如opensbi，运行在Figure 1的M-mode。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230421093859.png"></p><p>Figure 2提供了另一种架构，linux kernel运行在VS-mode，opensbi运行在HS-mode和M-mode。<strong>（不确定）</strong></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230421093917.png"></p><h1 id="4-Base-Extension-EID-0x10"><a href="#4-Base-Extension-EID-0x10" class="headerlink" title="4. Base Extension(EID #0x10)"></a>4. Base Extension(EID #0x10)</h1><ul><li>ECALL指令从supervisor转移到SEE。</li><li>a7保存SBI extension ID(EID)。</li><li>a6保存SBI function ID (FID)。</li><li>除了a0和a1，其他寄存器都需要由SEE保存好。</li><li>SBI functions返回error保存在a0，value保存在a1。</li></ul><h2 id="Linux中调用sbi-function"><a href="#Linux中调用sbi-function" class="headerlink" title="Linux中调用sbi function"></a>Linux中调用sbi function</h2><p>比如Function: Get SBI specification version (FID #0, EID #0x10):</p><p>在linux <code>arch/riscv/kernel/sbi.c</code>中定义了<code>struct sbiret sbi_get_spec_version(void);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//arch/riscv/include/asm/sbi.h arch/riscv/kernel/sbi.c</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sbi_get_spec_version</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>    __<span class="hljs-title function_">sbi_base_ecall</span><span class="hljs-params">(SBI_EXT_BASE_GET_SPEC_VERSION)</span>; <span class="hljs-comment">// SBI_EXT_BASE_GET_SPEC_VERSION 0 (fid)</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbiret</span> <span class="hljs-title">ret</span>;</span><br>        ret = sbi_ecall(SBI_EXT_BASE, fid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">// SBI_EXT_BASE 0x10 (eid)</span><br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a0 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a0&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg0);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a1 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a1&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg1);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a2 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a2&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg2);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a3 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a3&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg3);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a4 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a4&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg4);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a5 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a5&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(arg5);<br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a6 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a6&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(fid); <span class="hljs-comment">// fid a6保存fid</span><br>            <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> a7 <span class="hljs-title function_">asm</span> <span class="hljs-params">(<span class="hljs-string">&quot;a7&quot;</span>)</span> = (<span class="hljs-type">uintptr_t</span>)(ext); <span class="hljs-comment">// SBI_EXT_BASE a7保存eid</span><br>            <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;ecall&quot;</span></span><br><span class="hljs-params">                      : <span class="hljs-string">&quot;+r&quot;</span> (a0), <span class="hljs-string">&quot;+r&quot;</span> (a1)</span><br><span class="hljs-params">                      : <span class="hljs-string">&quot;r&quot;</span> (a2), <span class="hljs-string">&quot;r&quot;</span> (a3), <span class="hljs-string">&quot;r&quot;</span> (a4), <span class="hljs-string">&quot;r&quot;</span> (a5), <span class="hljs-string">&quot;r&quot;</span> (a6), <span class="hljs-string">&quot;r&quot;</span> (a7)</span><br><span class="hljs-params">                      : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>执行<code>ecall</code>指令，a7保存eid, a6保存fid, a0-a5保存参数值。</p><p>Ecall是一种异常, 对应下图Interrupt 0 Exception Code 9.</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230421113527.png"></p><p>当一个hart发生中断&#x2F;异常时，硬件自动经历如下转换：</p><ul><li>异常指令的PC被保存在 mepc中，PC被设置为mtvec。（对于同步异常，mepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）</li><li>根据异常来源设置mcause，并将mtval设置为出错的地址或者其它适用于特定异常的信息字。</li><li>把控制状态寄存器mstatus中的MIE位置零以禁用中断，并把先前的MIE值保留到MPIE中。</li><li>发生异常之前的权限模式保留在 mstatus的MPP域中，再把权限模式更改为M。</li></ul><h2 id="SSE-opensbi-处理Ecall过程"><a href="#SSE-opensbi-处理Ecall过程" class="headerlink" title="SSE(opensbi)处理Ecall过程"></a>SSE(opensbi)处理Ecall过程</h2><p>还是以Function: Get SBI specification version (FID #0, EID #0x10)为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">_trap_handler<br>TRAP_CALL_C_ROUTINE<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">sbi_trap_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sbi_trap_regs *regs)</span><br>    <span class="hljs-title function_">sbi_ecall_handler</span><span class="hljs-params">(regs)</span>; <span class="hljs-comment">// sbi_ecall.c</span><br>      sbi_ecall_find_extension(extension_id);<br>      ext-&gt;handle(extension_id, func_id, regs, &amp;out_val, &amp;trap);<br>      sbi_ecall_base_handler(); <span class="hljs-comment">//根据不同的eid找到不同的handle函数</span><br>        <span class="hljs-keyword">case</span> SBI_EXT_BASE_GET_SPEC_VERSION:<br>                      *out_val = (SBI_ECALL_VERSION_MAJOR &lt;&lt; <span class="hljs-comment">//SBI_ECALL_VERSION_MAJOR 0</span><br>                             SBI_SPEC_VERSION_MAJOR_OFFSET) &amp;<br>                             (SBI_SPEC_VERSION_MAJOR_MASK &lt;&lt;<br>                              SBI_SPEC_VERSION_MAJOR_OFFSET);<br>              <span class="hljs-comment">//SBI_ECALL_VERSION_MINOR 2 可以看出sbi version为0.2</span><br>                      *out_val = *out_val | SBI_ECALL_VERSION_MINOR;<br></code></pre></td></tr></table></figure><h1 id="OpenSBI"><a href="#OpenSBI" class="headerlink" title="OpenSBI"></a>OpenSBI</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"># fw_base.S<br><span class="hljs-meta"># relocate code 使load address==link address</span><br>call  fw_platform_init <span class="hljs-meta"># platform/generic/platform.c</span><br>  <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbi_platform</span> <span class="hljs-title">platform</span>;</span> <span class="hljs-comment">// 在platform/realtek/sheipa/platform.c中定义</span><br>    <br>call  sbi_init <span class="hljs-comment">// lib/sbi/sbi_init.c</span><br>  init_coldboot();<br>    sbi_scratch_init();<br>    sbi_domain_init();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>OpenSBI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>U-Boot启动流程</title>
    <link href="/2023/04/19/U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/04/19/U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Uboot编译流程"><a href="#Uboot编译流程" class="headerlink" title="Uboot编译流程"></a>Uboot编译流程</h1><p><a href="https://blog.csdn.net/ooonebook/article/details/53000893">https://blog.csdn.net/ooonebook/article/details/53000893</a></p><p>编译生成的文件：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414152845.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414152904.png"></p><p>具体可以参考Uboot Makefile</p><h2 id="u-boot-Makefile"><a href="#u-boot-Makefile" class="headerlink" title="u-boot Makefile"></a>u-boot Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-section">u-boot.cfg: <span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(srctree)</span>/scripts/Makefile.autoconf $(@)</span><br><span class="hljs-section">cfg: u-boot.cfg</span><br><span class="hljs-section">prepare2: prepare3 outputmakefile cfg</span><br><span class="hljs-section">prepare1: prepare2<span class="hljs-variable">$(version_h)</span> <span class="hljs-variable">$(timestamp_h)</span> <span class="hljs-variable">$(dt_h)</span> <span class="hljs-variable">$(env_h)</span> include/config/auto.conf</span><br><span class="hljs-section">archprepare: prepare1 scripts_basic</span><br><span class="hljs-section">prepare0: archprepare</span><br><span class="hljs-section">prepare:prepare0</span><br><span class="hljs-section">scripts: scripts_basic scripts_dtc include/config/auto.conf</span><br><br><span class="hljs-section">$(u-boot-dirs): prepare scripts</span><br><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(u-boot-init)</span> $(u-boot-main)): $(u-boot-dirs)<br><br>u-boot-init := $(head-y)<br>u-boot-main := $(libs-y)<br>u-boot-keep-syms-lto := keep-syms-lto.o<br><span class="hljs-section">u-boot.lds: <span class="hljs-variable">$(LDSCRIPT)</span> prepare</span><br><br><span class="hljs-section">u-boot:  $(u-boot-init) $(u-boot-main) $(u-boot-keep-syms-lto) u-boot.lds</span><br><span class="hljs-section">u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb</span><br><span class="hljs-section">u-boot-nodtb.bin: u-boot</span><br><span class="hljs-section">dts/dt.dtb: u-boot</span><br><br><span class="hljs-section">u-boot.srec: u-boot</span><br><span class="hljs-section">u-boot.bin: u-boot-dtb.bin</span><br><span class="hljs-section">u-boot.sym: u-boot</span><br><span class="hljs-section">System.map:  u-boot</span><br><span class="hljs-section">binary_size_check: u-boot-nodtb.bin</span><br><span class="hljs-section">u-boot.dtb: dts/dt.dtb</span><br><br>INPUTS-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check<br>INPUTS-<span class="hljs-variable">$(CONFIG_OF_SEPARATE)</span> += <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(CONFIG_OF_OMIT_DTB)</span>,dts/dt.dtb,u-boot.dtb)</span><br><br><span class="hljs-section">.binman_stamp: $(INPUTS-y)</span><br><br><span class="hljs-section">all: .binman_stamp</span><br><br></code></pre></td></tr></table></figure><h1 id="Uboot-启动流程"><a href="#Uboot-启动流程" class="headerlink" title="Uboot 启动流程"></a>Uboot 启动流程</h1><p><a href="https://blog.csdn.net/ooonebook/article/details/53070065">https://blog.csdn.net/ooonebook/article/details/53070065</a></p><h2 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h2><p>Nor&#x2F;Nand run code from <strong>flash</strong>.</p><p>Emmc boot&#x2F;security boot run code from <strong>ROM</strong>.</p><p>初始化CPU、拷贝第二阶段代码到sram</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/realtek/rts3917/ram_init/boot.S</span><br>_start:<br>    save_boot_params<br>        bsave_boot_params_ret<br><br>save_boot_params_ret:<br>    cpu_init_cp15<br><br>    ldrr0, =(CONFIG_SYS_FLASH_BASE + CONFIG_RAMINIT_OFFSET) <span class="hljs-comment">// CONFIG_SYS_FLASH_BASE = 0   CONFIG_RAMINIT_OFFSET = 2048</span><br>    ldrr1, =(CONFIG_LOAD_BASE) <span class="hljs-comment">// 0x19000000 sram地址</span><br>    ldrr2, =(CONFIG_SYS_FLASH_BASE + CONFIG_RAMINIT_OFFSET \ <span class="hljs-comment">// CONFIG_RAMINIT_SIZE = stat -c %s init.bin 即uboot第二阶段代码的长度</span><br>        + CONFIG_RAMINIT_SIZE)<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * r0 = source address</span><br><span class="hljs-comment">     * r1 = target address</span><br><span class="hljs-comment">     * r2 = source end address</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-number">1</span>:<br>    ldrr3, [r0], #<span class="hljs-number">4</span> <span class="hljs-comment">// 拷贝第二阶段代码到sram</span><br>    strr3, [r1], #<span class="hljs-number">4</span><br>    cmpr0, r2<br>    bne<span class="hljs-number">1b</span><br><br>    ldr pc,=(CONFIG_LOAD_BASE) <span class="hljs-comment">// 0x19000000 sram地址</span><br></code></pre></td></tr></table></figure><h2 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h2><p>初始化cpu，初始化ddr，ddr controller，时钟，拷贝uboot到ddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/realtek/rts3917/ram_init/init.S</span><br>_start:<br>    bsave_boot_params<br>        bsave_boot_params_ret<br><br>save_boot_params_ret:<br>    blcpu_init_cp15<br>    ldrr0, =(CONFIG_SYS_INIT_SP_ADDR_SRAM) <span class="hljs-comment">/// 设置堆栈为C code准备 CONFIG_SYS_INIT_SP_ADDR_SRAM = 0x19010000</span><br>    bicr0, r0, #<span class="hljs-number">7</span><span class="hljs-comment">/* 8-byte alignment for ABI compliance */</span><br>    movsp, r0<br><br>    blbsp_boot_init_plat <span class="hljs-comment">/// bsp_init.c 初始化时钟、DDR、DDR controller</span><br>    blfast_copy <span class="hljs-comment">//dma_copy.c 拷贝uboot到0x82800000</span><br>    ldr pc,=(CONFIG_LOAD_BASE) <span class="hljs-comment">/// 0x82800000</span><br></code></pre></td></tr></table></figure><h2 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h2><p>初始化cpu，relocate uboot，初始化串口，flash，网卡等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/vectors.S</span><br>_start:<br>    ARM_VECTORS<br>.macro ARM_VECTORS<br>    breset<br><br><span class="hljs-comment">// arch/arm/cpu/armv7/start.S</span><br>reset:<br>    bsave_boot_params<br><br><span class="hljs-title function_">ENTRY</span><span class="hljs-params">(save_boot_params)</span><br>    bsave_boot_params_ret@ back to my caller<br><br>save_boot_params_ret:<br>    cpu_init_cp15<br>    cpu_init_crit<br>        lowlevel_init <span class="hljs-comment">// board/realtek/rts3917/low_level.S</span><br>    _main<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># arch/arm/lib/crt0.S<br>ENTRY(_main)<br>  ldrr0, =(CONFIG_SYS_INIT_SP_ADDR)<br>  blboard_init_f_alloc_reserve # board_init.c 设置global_data起始地址<br>  blboard_init_f_init_reserve # board_init.c 初始化global_data，清零<br>  # 对gd成员赋值，对relocate进行空间规划；计算relocate后的偏移；relocate旧的gd到新的gd空间上<br>  blboard_init_f<br>  brelocate_code # 重定位u-boot<br>  blrelocate_vectors #重定位异常向量表<br>  SPL_CLEAR_BSS<br>  board_init_r<br>    run_main_loop<br>      main_loop<br>      s = bootdelay_process # s = &quot;bootcmd&quot;<br>      autoboot_command(s) # 自动执行bootcmd<br>      cli_loop # 获取命令<br></code></pre></td></tr></table></figure><p>经过<code>board_init_f_init_reserve</code>后</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230417154543.png"></p><p>经过<code>board_init_f</code>规划后新的u-boot分布：</p><p>调用<code>bd_info</code>命令可以查看relocate后各gd成员的地址。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230417142657.png"></p><p>env初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// nor flash为例</span><br>env_init(); <span class="hljs-comment">// board_f.c</span><br>  drv-&gt;init();<br><br>env_sf_init(); <span class="hljs-comment">// CONFIG_ENV_IS_IN_SPI_FLAH sf.c drv-&gt;init();</span><br>    gd-&gt;env_addr = (ulong)&amp;default_environment[<span class="hljs-number">0</span>]; <span class="hljs-comment">/// 加载默认的环境变量</span><br>    gd-&gt;env_valid = <span class="hljs-number">1</span>;<br><br><br>initr_env(); <span class="hljs-comment">// board_r.c</span><br>  env_relocate();<br>    env_load();<br>      drv-&gt;load();<br><br>env_sf_load(); <span class="hljs-comment">// sf.c drv-&gt;load();</span><br>  get_rst_mode();<br>  setup_flash_device(); <span class="hljs-comment">// 初始化nor flash</span><br>    spi_flash_probe();<br>  spi_flash_read(flash, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE, buf); <span class="hljs-comment">// 从flash上读环境变量</span><br>  env_import(buf, <span class="hljs-number">1</span>);<br>    crc32(<span class="hljs-number">0</span>, ep-&gt;data, ENV_SIZE)； <span class="hljs-comment">// check crc</span><br>    himport_r(); <span class="hljs-comment">// 将环境变量存入一个hash table</span><br><br><br>env_get()<br>  <span class="hljs-keyword">if</span> (gd-&gt;flags &amp; GD_FLG_ENV_READY) &#123; <span class="hljs-comment">// board_r.c 初始化完环境变量后GD_FLG_ENV_READY</span><br>  ...<br>  &#125;；<br>  env_get_f() <span class="hljs-comment">// 在初始化环境变量前，会从default_environment[]中读取匹配变量，存入gd-&gt;env_buf</span><br>      env_match()<br></code></pre></td></tr></table></figure><p>fdt初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">fdtdec_setup();<br>  board_fdt_blob_setup()<br>reserve_fdt();<br>reloc_fdt();<br>initr_get_fdt_offset();<br>  _do_get_offset(<span class="hljs-string">&quot;kernel&quot;</span>);<br>    dma_copy_dtb_to_ddr(<span class="hljs-string">&quot;dtb_offset&quot;</span>); <span class="hljs-comment">/// 拷贝dtb</span><br></code></pre></td></tr></table></figure><h2 id="global-data"><a href="#global-data" class="headerlink" title="global_data"></a>global_data</h2><p>uboot中定义了一个宏<code>DECLARE_GLOBAL_DATA_PTR</code>，使我们可以更加简单地获取global_data。</p><p>global_data的地址存放在r9中，直接从r9寄存器中获取其地址即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//arch/arm/include/asm/global_data.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_GLOBAL_DATA_PTR    register volatile gd_t *gd asm (<span class="hljs-string">&quot;r9&quot;</span>)</span><br><br><span class="hljs-comment">// DECLARE_GLOBAL_DATA_PTR定义了gd_t *gd，并且其地址是r9中的值。</span><br><span class="hljs-comment">// 一旦使用了DECLARE_GLOBAL_DATA_PTR声明之后，后续就可以直接使用gd变量，也就是global_data了。</span><br></code></pre></td></tr></table></figure><h1 id="Uboot启动kernel"><a href="#Uboot启动kernel" class="headerlink" title="Uboot启动kernel"></a>Uboot启动kernel</h1><p>uboot用image_header来表示Legacy-uImage的头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">image_header</span> &#123;</span><br>  <span class="hljs-type">uint32_t</span>ih_magic;<span class="hljs-comment">/* Image Header Magic Number*/</span><br>  <span class="hljs-type">uint32_t</span>ih_hcrc;<span class="hljs-comment">/* Image Header CRC Checksum*/</span><br>  <span class="hljs-type">uint32_t</span>ih_time;<span class="hljs-comment">/* Image Creation Timestamp*/</span><br>  <span class="hljs-type">uint32_t</span>ih_size;<span class="hljs-comment">/* Image Data Size*/</span><br>  <span class="hljs-type">uint32_t</span>ih_load;<span class="hljs-comment">/* Data Load  Address*/</span><br>  <span class="hljs-type">uint32_t</span>ih_ep;<span class="hljs-comment">/* Entry Point Address*/</span><br>  <span class="hljs-type">uint32_t</span>ih_dcrc;<span class="hljs-comment">/* Image Data CRC Checksum*/</span><br>  <span class="hljs-type">uint8_t</span>ih_os;<span class="hljs-comment">/* Operating System*/</span><br>  <span class="hljs-type">uint8_t</span>ih_arch;<span class="hljs-comment">/* CPU architecture*/</span><br>  <span class="hljs-type">uint8_t</span>ih_type;<span class="hljs-comment">/* Image Type*/</span><br>  <span class="hljs-type">uint8_t</span>ih_comp;<span class="hljs-comment">/* Compression Type*/</span><br>  <span class="hljs-type">uint8_t</span>ih_name[IH_NMLEN];<span class="hljs-comment">/* Image Name*/</span><br>&#125; <span class="hljs-type">image_header_t</span>;<br></code></pre></td></tr></table></figure><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230419101548.png"></p><p><code>ih_magic=0x27051956</code>表示是一个<code>Legacy-uImage</code></p><p><code>ih_load=81000000</code></p><p><code>ih_ep=81000000</code></p><p><code>ih_os, ih_arch, ih_type, ih_comp=05, 02, 02, 00</code> 具体定义在uboot<code> image.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cmd/bootm.c</span><br>bootm();<br>  do_bootm();<br>    do_bootm_states(BOOTM_STATE_START |<br>    BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |<br>    BOOTM_STATE_LOADOS | BOOTM_STATE_OS_PREP |<br>         BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);<br><br><span class="hljs-comment">// common/bootm.c</span><br>bootm_start();<br>  images.verify = env_get_yesno(<span class="hljs-string">&quot;verify&quot;</span>); <span class="hljs-comment">/// 不存在verify，return -1，默认为true</span><br>bootm_find_os(); <span class="hljs-comment">// 填充bootm_headers_t images</span><br>  <span class="hljs-comment">// 获取kernel image的data起始地址和长度</span><br>  os_hdr = boot_get_kernel(&amp;images.os.image_start, &amp;images.os.image_len);<br>    img_addr = genimg_get_kernel_addr_fit(); <span class="hljs-comment">// 获取kernel地址</span><br>    genimg_get_image(img_addr);<br>    image_get_kernel(img_addr, images-&gt;verify);<br>           image_print_contents(); <span class="hljs-comment">// 打印信息</span><br>      image_check_dcrc(); <span class="hljs-comment">// check crc</span><br>    images.os.type = image_get_type(os_hdr); <span class="hljs-comment">/// Kernel Image</span><br>    images.os.comp = image_get_comp(os_hdr); <span class="hljs-comment">/// uncompressed</span><br>    images.os.os = image_get_os(os_hdr); <span class="hljs-comment">/// Linux</span><br>    images.os.end = image_get_image_end(os_hdr);<br>    images.os.load = image_get_load(os_hdr); <span class="hljs-comment">/// 0x81000000</span><br>    images.os.arch = image_get_arch(os_hdr); <span class="hljs-comment">/// ARM</span><br>  images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy); <span class="hljs-comment">/// 0x81000000</span><br>  images.os.start = map_to_sysmem(os_hdr); <span class="hljs-comment">// 0xC0000</span><br>bootm_find_other();<br>  bootm_find_images();<br>    boot_get_fdt(&amp;images.ft_addr, &amp;images.ft_len); <span class="hljs-comment">// 获取fdt地址和长度</span><br>bootm_disable_interrupts();<br>bootm_load_os(images, <span class="hljs-number">0</span>);<br>  image_decomp(); <span class="hljs-comment">// 这里会拷贝kernel image从flash到load address</span><br>boot_fn = bootm_os_get_boot_func(images-&gt;os.os);<br>boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);<br>  do_bootm_linux(); <span class="hljs-comment">//arch/arm/lib/bootm.c</span><br>    boot_prep_linux(); <span class="hljs-comment">//arch/arm/lib/bootm.c</span><br>      image_setup_linux(); <span class="hljs-comment">// common/image.c</span><br>        boot_relocate_fdt();<br>        image_setup_libfdt();<br>      board_prep_linux(); <span class="hljs-comment">// skip</span><br>boot_selected_os(argc, argv, BOOTM_STATE_OS_GO, images, boot_fn);<br>    boot_fn(state, argc, argv, images);<br>      do_bootm_linux();<br>        boot_jump_linux();<br>          kernel_entry = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, uint))images-&gt;ep;<br>          kernel_entry(<span class="hljs-number">0</span>, machid, r2); <span class="hljs-comment">// 进入kernel entry point</span><br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/ooonebook/category_6484145.html">U-boot专栏</a></p><p><a href="%5B%3Chttps://xyc-1316422823.cos.ap-shanghai.myqcloud.com/uboot_introduction.ppt%3E%5D(%3Chttps://xyc-1316422823.cos.ap-shanghai.myqcloud.com/uboot_introduction.ppt%3E)">Uboot PPT</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>U-Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C subsystem</title>
    <link href="/2023/04/13/linux_subsystem/I2C/"/>
    <url>/2023/04/13/linux_subsystem/I2C/</url>
    
    <content type="html"><![CDATA[<h1 id="用户层测试指令"><a href="#用户层测试指令" class="headerlink" title="用户层测试指令"></a>用户层测试指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检测当前系统有几组i2c总线</span><br>i2cdetect -l<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看i2c-0接口上的设备</span><br>i2cdetect -y -a 0 # Force scanning of non-regular addresses<br>i2cdetect -y -r 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取指定设备的全部寄存器的值</span><br>i2cdump -f -y 0 0x68<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取指定i2c设备的某个寄存器的值，如下读取i2c-0地址为0x68器件中的0x01寄存器</span><br>i2cget -f -y 0 0x68 0x01<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入指定i2c设备的某个寄存器的值，如下写入i2c-0地址为0x68器件中的0x01寄存器值为0x6f</span><br>i2cset -f -y 0 0x68 0x01 0x6f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入i2c-0地址为0x50的eeprom，从偏移为0x64地址读8个byte。</span><br>i2ctransfer -f -y 0 w1@0x50 0x64 r8<br></code></pre></td></tr></table></figure><h1 id="I2C-基础知识"><a href="#I2C-基础知识" class="headerlink" title="I2C 基础知识"></a>I2C 基础知识</h1><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><ul><li>主芯片要发出一个start信号</li><li>然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读&#x2F;写，0表示写，1表示读)</li><li>从设备回应(用来确定这个设备是否存在)，然后就可以传输数据</li><li>主设备发送一个字节数据给从设备，并等待回应</li><li>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</li><li>数据发送完之后，主芯片就会发送一个停止信号。</li></ul><p>下图：白色背景表示”主→从”，灰色背景表示”从→主”</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143312.png"></p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143336.png"></p><h2 id="I2C信号"><a href="#I2C信号" class="headerlink" title="I2C信号"></a>I2C信号</h2><p>I2C协议中数据传输的单位是字节，也就是8位。但是要用到9个时钟：前面8个时钟用来传输8数据，第9个时钟用来传输回应信号。传输时，先传输最高位(MSB)。</p><ul><li>开始信号（S）：SCL为高电平时，SDA山高电平向低电平跳变，开始传送数据。</li><li>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li><li>响应信号(ACK)：接收器在接收到8位数据后，在第9个时钟周期，拉低SDA</li><li>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化</li></ul><p>I2C协议信号如下：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143408.png"></p><h2 id="SMBus协议"><a href="#SMBus协议" class="headerlink" title="SMBus协议"></a>SMBus协议</h2><p>System Management Bus，系统管理总线。<strong>是I2C协议的一个子集</strong></p><ul><li><p>VDD的极限值不一样</p><ul><li>I2C协议：范围很广，甚至讨论了高达12V的情况</li><li>SMBus：1.8V~5V</li></ul></li><li><p>最小时钟频率、最大的Clock Stretching</p><ul><li>Clock Stretching含义：某个设备需要更多时间进行内部的处理时，它可以把SCL拉低占住I2C总线</li><li>I2C协议：时钟频率最小值无限制，Clock Stretching时长也没有限制</li><li>SMBus：时钟频率最小值是10KHz，Clock Stretching的最大时间值也有限制</li></ul></li><li><p>地址回应(Address Acknowledge)</p><ul><li>一个I2C设备接收到它的设备地址后，是否必须发出回应信号？</li><li>I2C协议：没有强制要求必须发出回应信号</li><li>SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了</li></ul></li><li><p>SMBus协议明确了数据的传输格式</p><ul><li>I2C协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义</li><li>SMBus：定义了几种数据格式(后面分析)</li></ul></li><li><p>REPEATED START Condition(重复发出S信号)</p><ul><li><p>比如读EEPROM时，涉及2个操作：</p><ul><li>把存储地址发给设备</li><li>读数据</li></ul></li><li><p>在写、读之间，可以不发出P信号，而是直接发出S信号：这个S信号就是<code>REPEATED START</code></p></li><li><p>如下图所示</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143735.png"></p></li></ul></li><li><p>SMBus Low Power Version</p><ul><li>SMBus也有低功耗的版本</li></ul></li></ul><h1 id="I2C-provider"><a href="#I2C-provider" class="headerlink" title="I2C provider"></a>I2C provider</h1><p><a href="http://www.wowotech.net/comm/i2c_provider.html">http://www.wowotech.net/comm/i2c_provider.html</a></p><p><code>i2c_adapter</code>抽象I2C控制器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span>  <span class="hljs-comment">/* classes to allow probing for */</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span> <span class="hljs-comment">/* the algorithm to access the bus */</span><br>  <span class="hljs-type">void</span> *algo_data;<br><br>  <span class="hljs-comment">/* data fields that are valid for all devices*/</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_lock_operations</span> *<span class="hljs-title">lock_ops</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">bus_lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">mux_lock</span>;</span><br><br>  <span class="hljs-type">int</span> timeout;<span class="hljs-comment">/* in jiffies */</span><br>  <span class="hljs-type">int</span> retries;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* the adapter device */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_flags;<span class="hljs-comment">/* owned by the I2C core */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_ALF_IS_SUSPENDED    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_ALF_SUSPEND_REPORTED  1</span><br><br>  <span class="hljs-type">int</span> nr;<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">48</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">userspace_clients_lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">userspace_clients</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_bus_recovery_info</span> *<span class="hljs-title">bus_recovery_info</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter_quirks</span> *<span class="hljs-title">quirks</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_domain</span> *<span class="hljs-title">host_notify_domain</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>i2c_algorithm</code>抽象了通过I2C总线发送和接收数据的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> &#123;</span><br>  <span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs,<br>         <span class="hljs-type">int</span> num);<br>    <span class="hljs-comment">// 功能跟master_xfer一样，在atomic context环境下使用</span><br>  <span class="hljs-type">int</span> (*master_xfer_atomic)(<span class="hljs-keyword">struct</span> i2c_adapter *adap,<br>           <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num);<br>    <span class="hljs-comment">// 实现SMBus传输，如果不提供这个函数，SMBus传输会使用master_xfer来模拟</span><br>  <span class="hljs-type">int</span> (*smbus_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<br>        u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<br>  <span class="hljs-type">int</span> (*smbus_xfer_atomic)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<br>         u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<br><br>  <span class="hljs-comment">/* To determine what the adapter supports */</span><br>  u32 (*functionality)(<span class="hljs-keyword">struct</span> i2c_adapter *adap);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span><br>    <span class="hljs-comment">// reg_slave就是把一个i2c_client注册到I2C Adapter，就是让这个I2C Adapter模拟该i2c_client</span><br>  <span class="hljs-type">int</span> (*reg_slave)(<span class="hljs-keyword">struct</span> i2c_client *client);<br>  <span class="hljs-type">int</span> (*unreg_slave)(<span class="hljs-keyword">struct</span> i2c_client *client);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>I2C传输以<code>i2c_msg</code>为单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> &#123;</span><br>  __u16 addr;<span class="hljs-comment">/* slave address*/</span><br>  __u16 flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RD    0x0001<span class="hljs-comment">/* read data, from slave to master */</span></span><br>          <span class="hljs-comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_TEN    0x0010<span class="hljs-comment">/* this is a ten bit chip address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_DMA_SAFE    0x0200<span class="hljs-comment">/* the buffer of this message is DMA safe */</span></span><br>          <span class="hljs-comment">/* makes only sense in kernelspace */</span><br>          <span class="hljs-comment">/* userspace buffers are copied anyway */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RECV_LEN    0x0400<span class="hljs-comment">/* length will be first received byte */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NO_RD_ACK    0x0800<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_IGNORE_NAK  0x1000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NOSTART    0x4000<span class="hljs-comment">/* if I2C_FUNC_NOSTART */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_STOP    0x8000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br>  __u16 len;<span class="hljs-comment">/* msg length*/</span><br>  __u8 *buf;<span class="hljs-comment">/* pointer to msg data*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="I2C-consumer"><a href="#I2C-consumer" class="headerlink" title="I2C consumer"></a>I2C consumer</h1><p><a href="http://www.wowotech.net/comm/i2c_consumer.html">http://www.wowotech.net/comm/i2c_consumer.html</a></p><p><strong>形态1</strong>：CPU和设备之间的所有数据交互，都是通过I2C总线进行。</p><p><strong>形态2</strong>：I2C只是CPU和设备之间进行数据交互的一种，例如HDMI，图像以及音频数据通过TDMS接口传输，EDID等信息的交互通过I2C总线。</p><p><strong>形态1</strong>：直接在device tree中i2c设备节点下加一个子节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;i2c1 &#123;<br>        clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br>        pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br>        pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br>        status = <span class="hljs-string">&quot;okay&quot;</span>;<br>        …<br>        pmic: pf0100@<span class="hljs-number">08</span> &#123;<br>                compatible = <span class="hljs-string">&quot;fsl,pfuze100&quot;</span>;<br>                …<br>        &#125;;<br></code></pre></td></tr></table></figure><p><strong>形态2</strong>：在自己的设备节点下引用i2c节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;hdmi &#123;<br>       ddc-i2c-bus = &lt;&amp;i2c2&gt;;<br>        status = <span class="hljs-string">&quot;okay&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="驱动编写步骤"><a href="#驱动编写步骤" class="headerlink" title="驱动编写步骤"></a>驱动编写步骤</h2><p><strong>形态1</strong>：需要编写一个<code>i2c driver</code>。定义一个<code>struct i2c_driver</code>类型的变量，并调用<code>module_i2c_driver</code>接口将其注册到<code>I2C core</code>中。</p><p>以<code>struct i2c_client</code>指针为参数，可以调用<code>i2c_master_send/i2c_master_recv</code>接口进行简单的I2C传输，同时，也可以通过该指针获得所属的<code>I2C adapter</code>指针，然后通过<code>i2c_transfer</code>接口，进行更为复杂的read、write操作。</p><p><strong>形态2</strong>：通过设备树API接口获得<code>struct i2c_adapter</code>指针，通过<code>i2c_transfer</code>接口，进行read、write操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">adap = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">&quot;ddc-i2c-bus&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (adap) &#123;<br>        panel-&gt;adap = of_find_i2c_adapter_by_node(adap); <span class="hljs-comment">//获取i2c adapter指针</span><br>        of_node_put(adap);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>i2c client</code>抽象i2c设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags;<span class="hljs-comment">/* flags，指示该I2C slave device一些特性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_PEC    0x04<span class="hljs-comment">/* Use Packet Error Checking */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_TEN    0x10<span class="hljs-comment">/* we have a ten bit chip address */</span></span><br>          <span class="hljs-comment">/* Must equal I2C_M_TEN below */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_SLAVE  0x20<span class="hljs-comment">/* we are the slave */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_HOST_NOTIFY  0x40<span class="hljs-comment">/* We want to use I2C host notify */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_WAKE    0x80<span class="hljs-comment">/* for board_info; true iff can wake */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_SCCB    0x9000<span class="hljs-comment">/* Use Omnivision SCCB protocol */</span></span><br>          <span class="hljs-comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr;<span class="hljs-comment">/* 该设备的7-bit的slave地址。*/</span><br>          <span class="hljs-comment">/* addresses are stored in the*/</span><br>          <span class="hljs-comment">/* _LOWER_ 7 bits*/</span><br>  <span class="hljs-type">char</span> name[I2C_NAME_SIZE];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span><span class="hljs-comment">/* 该设备所在的I2C controller*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* the device structure*/</span><br>  <span class="hljs-type">int</span> init_irq;<span class="hljs-comment">/* irq set at initialization*/</span><br>  <span class="hljs-type">int</span> irq;<span class="hljs-comment">/* irq issued by device*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">detected</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span><br>  <span class="hljs-type">i2c_slave_cb_t</span> slave_cb;<span class="hljs-comment">/* callback for slave mode*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通常情况下，<code>struct i2c_client</code>变量是由I2C core在register adapter的时候，解析adapter的child node自行创建的。该数据结构中的有些信息，可通过DTS配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">xxx:xxx@<span class="hljs-number">08</span> &#123;<br>        reg = &lt;<span class="hljs-number">0x08</span>&gt;;                               <span class="hljs-comment">/* 对应struct i2c_client中的‘addr’*/</span><br>        interrupts = &lt;<span class="hljs-number">16</span> <span class="hljs-number">8</span>&gt;;                       <span class="hljs-comment">/* 对应struct i2c_client中的‘irq’*/</span><br>        wakeup-source;                             <span class="hljs-comment">/* 对应flags中的I2C_CLIENT_WAKE */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Synopsys-DesignWare-I2C-driver"><a href="#Synopsys-DesignWare-I2C-driver" class="headerlink" title="Synopsys DesignWare I2C driver"></a>Synopsys DesignWare I2C driver</h1><p>i2c 传输的频率可以通过设备树<code>&quot;clock-frequency&quot;</code>来设置<code>t-&gt;bus_freq_hz</code>。不设置则为默认的400kHz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">dw_i2c_plat_probe()<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dw_i2c_dev</span> *<span class="hljs-title">dev</span>;</span><br>    dw_i2c_plat_request_regs(dev);<br>    dev-&gt;base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br>  i2c_parse_fw_timings(&amp;pdev-&gt;dev, t, <span class="hljs-literal">false</span>);<br>  i2c_dw_configure();<br>          i2c_dw_configure_slave();<br>          i2c_dw_configure_master(); <span class="hljs-comment">// 设置一些dev-&gt;func dev-&gt;master_cfg等属性后续使用</span><br>     i2c_dw_probe()<br>          i2c_dw_probe_slave();<br>     i2c_dw_probe_master();<br><br>i2c_dw_probe_master(<span class="hljs-keyword">struct</span> dw_i2c_dev *dev)<br>    dev-&gt;init = i2c_dw_init_master;<br>  dev-&gt;disable = i2c_dw_disable;<br>  dev-&gt;disable_int = i2c_dw_disable_int;<br>  i2c_dw_init_regmap();<br>    i2c_dw_set_timings_master(); <span class="hljs-comment">//设置standard/fast h/lcnt</span><br>    i2c_dw_set_sda_hold(); <span class="hljs-comment">// 设置sda_hold,不过rts直接在dev-&gt;init中设置为20</span><br>    i2c_dw_set_fifo_size(); <span class="hljs-comment">//设置tx/rx_fifo_depth</span><br>  dev-&gt;init(); <span class="hljs-comment">// 写之前设置好配置的寄存器</span><br>    __i2c_dw_disable(); <span class="hljs-comment">// disable adapter</span><br>      __i2c_dw_disable_nowait();<br>    i2c_dw_configure_fifo_master();<span class="hljs-comment">//写tx/rx_fifo寄存器,根据dev-&gt;master_cfg写con寄存器</span><br>  i2c_dw_disable_int(); <span class="hljs-comment">// 先把中断mask全部置1，禁止中断</span><br>  devm_request_irq();<br>  i2c_dw_init_recovery_info();<br>  i2c_add_numbered_adapter();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buildroot</title>
    <link href="/2023/04/13/Buildroot/"/>
    <url>/2023/04/13/Buildroot/</url>
    
    <content type="html"><![CDATA[<p><code>./lanuch</code> 最终的操作是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd sdk_3921/buildroot-dist # 进入buildroot目录<br>make BR2_EXTERNAL=sdk_3921/platform/ O=sdk3921/out/rts3923_fpga/ rts3923_fpga_defconfig<br></code></pre></td></tr></table></figure><h2 id="Managing-the-build-andthe-configuration"><a href="#Managing-the-build-andthe-configuration" class="headerlink" title="Managing the build andthe configuration"></a>Managing the build andthe configuration</h2><h3 id="Out-of-tree-build"><a href="#Out-of-tree-build" class="headerlink" title="Out of tree build"></a>Out of tree build</h3><p>在<code>buildroot Makefile</code>中有</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(O)</span>,<span class="hljs-variable">$(CURDIR)</span>/output)<br>CONFIG_DIR := <span class="hljs-variable">$(CURDIR)</span><br>NEED_WRAPPER =<br><span class="hljs-keyword">else</span><br>CONFIG_DIR := <span class="hljs-variable">$(O)</span><br>NEED_WRAPPER = y<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>可以看出，如果<code>O != buildroot_dist/output</code>, <code>CONFIG_DIR = sdk3921/out/rts3923_fpga/ </code></p><p>在<code>CONFIG_DIR</code>目录下，保存着<code>.config</code>配置文件。</p><h3 id="Other-building-tips"><a href="#Other-building-tips" class="headerlink" title="Other building tips"></a>Other building tips</h3><p>Cleaning all the build output, but keeping the configuration file(删除build&#x2F;):</p><p><code>make clean</code></p><p>Cleaning everything, including the configuration file, and downloaded file if at the<br>default location (相当于删除了build&#x2F;和.config一系列配置文件，需要重新make menuconfig):</p><p><code>make distclean</code></p><h2 id="Buildroot-source-and-build-trees"><a href="#Buildroot-source-and-build-trees" class="headerlink" title="Buildroot source and build trees"></a>Buildroot source and build trees</h2><h3 id="Build-tree"><a href="#Build-tree" class="headerlink" title="Build tree"></a>Build tree</h3><ul><li><code>output/</code>对应<code>BASE_DIR</code></li><li><code>output/build/</code>对应<code>BUILD_DIR</code></li><li><code>output/host/</code>对应<code>HOST_DIR</code><ul><li>Contains both the tools built for the host (cross-compiler, etc.) and the sysroot of<br>the toolchain</li><li>Host tools are directly in <code>host/</code></li><li>The sysroot is in <code>host/&lt;tuple&gt;/sysroot/usr</code>E.g: <code>arm-unknown-linux-gnueabihf</code></li><li>Variable for the sysroot: <code>STAGING_DIR</code>. <code>ouput</code>目录下的<code>staging</code>目录也是软连接到这的</li></ul></li><li><code>output/target/</code>对应<code>TARGET_DIR</code><ul><li>Used to generate the final root filesystem images in<code> images/</code></li></ul></li><li><code>output/image/</code>对应<code>BINARIES_DIR</code></li></ul><h2 id="Managing-the-Linux-kernel-configuration"><a href="#Managing-the-Linux-kernel-configuration" class="headerlink" title="Managing the Linux kernel configuration"></a>Managing the Linux kernel configuration</h2><ul><li><code>make linux-update-config</code>, to save a full config file</li><li><code>make linux-update-defconfig</code>, to save a minimal defconfig</li></ul><h2 id="Root-filesystem-in-Buildroot"><a href="#Root-filesystem-in-Buildroot" class="headerlink" title="Root filesystem in Buildroot"></a>Root filesystem in Buildroot</h2><p>copy rootfs overlays-&gt;execute post-build scripts-&gt;execute post-image scripts</p><p><code>platform/board/rts3923/rootfs_overlay</code></p><p><code>platform/board/rts3923/post_build.sh</code></p><p><code>platform/board/rts3923/post_image.sh</code></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230412162924.png"></p><h2 id="Advanced-topics"><a href="#Advanced-topics" class="headerlink" title="Advanced topics"></a>Advanced topics</h2><h3 id="BR2-EXTERNAL"><a href="#BR2-EXTERNAL" class="headerlink" title="BR2_EXTERNAL"></a>BR2_EXTERNAL</h3><p>Ipcam sdk在make的时候指定</p><p><code>make BR2_EXTERNAL=sdk_3921/platform/ O=sdk3921/out/rts3923_fpga/ rts3923_fpga_defconfig</code></p><p>Each external directory must contain:</p><ul><li><code>external.desc</code>, which provides a name and description. The <code>$BR2_EXTERNAL_&lt;NAME&gt;_PATH</code> variable is available, where NAME is defined in <code>external.desc</code>.</li><li><code>Config.in</code>, configuration options that will be included in menuconfig（在menuconfig external options里）</li><li><code>external.mk</code>, will be included in the make logic</li></ul><p><code>make &lt;pkg&gt;-dirclean</code>, completely remove the package source code directory. The next make invocation will fully rebuild this package. 相当于直接删除<code>build/&lt;pkg&gt;</code></p><p><code>make &lt;pkg&gt;-rebuild</code>, force to re-execute the build and installation steps of the package.</p><p><code>make &lt;pkg&gt;-reconfigure</code>, force to re-execute the configure, build and installation steps of the package.</p><h1 id="Self-notes"><a href="#Self-notes" class="headerlink" title="Self notes"></a>Self notes</h1><p><code>platform/local.mk</code>: 指定自定义源码位置</p><p>在<code>local.mk</code>中还定义了：</p><p><code>make rr</code>: Reconstruct rootfs</p><p><code>make rp</code>: Rebuild external packages</p><h1 id="legacy"><a href="#legacy" class="headerlink" title="legacy"></a>legacy</h1><h2 id="添加自己的软件包"><a href="#添加自己的软件包" class="headerlink" title="添加自己的软件包"></a>添加自己的软件包</h2><h3 id="添加package-x2F-Config-in入口"><a href="#添加package-x2F-Config-in入口" class="headerlink" title="添加package&#x2F;Config.in入口"></a>添加package&#x2F;Config.in入口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kufds">config BR2_PACKAGE_HELLOWORLD<br>bool &quot;helloworld&quot;<br>help<br>  This is a demo to add myown(fuzidage) package.<br></code></pre></td></tr></table></figure><h3 id="配置APP对应的Config-in和mk文件"><a href="#配置APP对应的Config-in和mk文件" class="headerlink" title="配置APP对应的Config.in和mk文件"></a>配置APP对应的Config.in和mk文件</h3><p>在package中新增目录helloworld，并在里面添加Config.in和helloworld.mk<br><strong>Config.in</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fdsf">config BR2_PACKAGE_HELLOWORLD<br>bool &quot;helloworld&quot;<br>help<br>  This is a demo to add myown(fuzidage) package.<br></code></pre></td></tr></table></figure><p><strong>helloworld.mk</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dfsdf">HELLOWORLD_VERSION:= 1.0.0<br>HELLOWORLD_SITE:= $(BR2_EXTERNAL)/source/ipcam/helloworld<br>HELLOWORLD_SITE_METHOD:=local<br>HELLOWORLD_INSTALL_TARGET:=YES<br><br>$(eval $(cmake-package))<br><br></code></pre></td></tr></table></figure><h2 id="如何重新编译软件包"><a href="#如何重新编译软件包" class="headerlink" title="如何重新编译软件包"></a>如何重新编译软件包</h2><p>经过第一次完整编译后，如果我们需要对源码包重新配置，我们不能直接在buildroot上的根目录下直接make，buildroot是不知道你已经对源码进行重新配置，它只会将第一次编译出来的文件，再次打包成根文件系统镜像文件。</p><p>那么可以通过以下2种方式重新编译：</p><p><strong>1. 直接删除源码包,然后make all</strong></p><p>例如我们要重新编译helloworld，那么可以直接删除output&#x2F;build&#x2F;helloworld目录，那么当你make的时候，就会自动从dl文件夹下，解压缩源码包，并重新安装。这种效率偏低</p><p><strong>2. 进行xxx-rebuild,然后make all</strong></p><p>也是以helloworld为例子，我们直接输入make helloworld-rebuild，即可对build&#x2F;helloworld&#x2F;目录进行重新编译，然后还要进行make all(或者make helloworld)</p><h2 id="Config-in-语法"><a href="#Config-in-语法" class="headerlink" title="Config.in 语法"></a>Config.in 语法</h2><p>用Kconfig语言编写，用来配置packages</p><p>必须以<code>BR2_PACKAGE_&lt;PACKAGE&gt;</code>开头</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxwbwcmsauj30i303zt8t.jpg"></p><p>Config.in 是层级结构<code>package/&lt;pkg&gt;/Config.in</code>都被包含在<code>package/Config.in</code></p><h3 id="menu-x2F-endmenu"><a href="#menu-x2F-endmenu" class="headerlink" title="menu&#x2F;endmenu"></a>menu&#x2F;endmenu</h3><p>menuconfig中层级目录由<code>menu</code>来嵌套定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kbuild">menu &quot;Base System&quot;<br>source &quot;$BR2_EXTERNAL_platform_PATH/package/example/Config.in&quot;<br>source &quot;$BR2_EXTERNAL_platform_PATH/package/fstools/Config.in&quot;<br>endmenu<br><br>menu &quot;Test Package&quot;<br>source &quot;$BR2_EXTERNAL_platform_PATH/package/foobar/Config.in&quot;<br>endmenu<br><br>// Test Package在Base System下一级目录<br>menu &quot;Base System&quot;<br>menu &quot;Test Package&quot;<br>endmenu<br>endmenu<br></code></pre></td></tr></table></figure><h3 id="if-x2F-endif"><a href="#if-x2F-endif" class="headerlink" title="if&#x2F;endif"></a>if&#x2F;endif</h3><h3 id="choice-x2F-endchoice"><a href="#choice-x2F-endchoice" class="headerlink" title="choice&#x2F;endchoice"></a>choice&#x2F;endchoice</h3><h3 id="select、depends-on"><a href="#select、depends-on" class="headerlink" title="select、depends on"></a>select、depends on</h3><p>select是一种自动依赖，如果A select B，只要A被enable，B就会被enable，而且不可unselected</p><p>depends on是一种用户定义的依赖，如果A depends on B, A只有在B被enable后才可见</p><ul><li><code>make \&lt;pkg\&gt;-show-depend</code>: 查看pkg依赖的包</li><li><code>make \&lt;pkg\&gt;-show-rdepend</code>: 查看依赖pkg的包</li></ul><h2 id="mk文件"><a href="#mk文件" class="headerlink" title=".mk文件"></a>.mk文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">xxx_SITE_METHOD</span> = local<br><span class="hljs-attr">xxx_SITE</span> = 本地源码库地址<br><br><span class="hljs-attr">xxx_SITE_METHOD</span> = remote<br><span class="hljs-attr">xxx_SITE</span> = 远程URL<br></code></pre></td></tr></table></figure><p>Packages可以被安装到不同目录：</p><ul><li>target目录：<code>$(TARGET_DIR)</code></li><li>staging目录：<code>$(STAGING_DIR)</code></li><li>images目录：<code>$(BINARIES_DIR)</code></li></ul><p>分别由三个变量决定：</p><ul><li><code>&lt;pkg&gt;_INSTALL_TARGET</code> , defaults to <code>YES</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_TARGET_CMDS</code> will be called </li><li><code>&lt;pkg&gt;_INSTALL_STAGING</code> , defaults to <code>NO</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_STAGING_CMDS</code> will be called </li><li><code>&lt;pkg&gt;_INSTALL_IMAGES</code> , defaults to <code>NO</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_IMAGES_CMDS</code> will be called <br/><br/></li><li>Application Package一般只要安装到target</li><li>Shared library动态库必须安装到target与staging</li><li>header-based library和static-only library静态库只安装到staging</li><li>bootloader和linux要安装到images</li></ul><p>Config.in文件不规定编译顺序，.mk文件中的&lt;pkg&gt;_DEPENDENCIES可以规定编译顺序，&lt;pkg&gt;_DEPENDENCIES后面的软件包先编译。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/fuzidage/p/12049442.html">https://www.cnblogs.com/fuzidage/p/12049442.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Buildroot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWM subsystem</title>
    <link href="/2023/03/21/linux_subsystem/PWM/"/>
    <url>/2023/03/21/linux_subsystem/PWM/</url>
    
    <content type="html"><![CDATA[<h1 id="PWM-子系统"><a href="#PWM-子系统" class="headerlink" title="PWM 子系统"></a>PWM 子系统</h1><h1 id="PWM原理"><a href="#PWM原理" class="headerlink" title="PWM原理"></a>PWM原理</h1><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/Untitled.png"></p><p>利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，其本质是一种对模拟信号电平进行数字编码的方法。在嵌入式设备中，PWM多用于控制马达、LED、振动器等模拟器件。</p><ul><li>脉冲周期（T），单位是时间，ns, us ,ms。</li><li>脉冲频率（f），单位是赫兹（Hz），与脉冲周期成倒数关系，f&#x3D;1&#x2F;T。</li><li>脉冲宽度（W），简称“脉宽”，是脉冲高电平持续的时间。单位是时间，ns, us, ms。</li><li>占空比（D），脉宽除以脉冲周期的值。</li></ul><p>W &#x3D; ton</p><p>T &#x3D; ton + toff &#x3D; 1&#x2F;f</p><p>D &#x3D; ton &#x2F; (ton+ toff) &#x3D; ton &#x2F; T</p><h1 id="PWM-consumer"><a href="#PWM-consumer" class="headerlink" title="PWM consumer"></a>PWM consumer</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/linux/pwm.h */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_config</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm, <span class="hljs-type">int</span> duty_ns, <span class="hljs-type">int</span> period_ns)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_apply_state</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pwm_state *state)</span>;<br></code></pre></td></tr></table></figure><p><code>pwm_config</code>，用于控制PWM输出信号的频率和占空比，其中频率是以周期（<code>period_ns</code>）的形式配置的，占空比是以有效时间（<code>duty_ns</code>）的形式配置的。</p><p><code>pwm_enable/pwm_disable</code>，用于控制PWM信号输出与否。</p><p> <code>pwm_apply_state</code>需要定义一个<code>pwm_state</code>，可以一下子修改<code>period/duty_cycle/polarity/enabled</code>。</p><p>上面的API都以<code>struct pwm_device</code>类型的指针为操作句柄，该指针抽象了一个PWM设备，那么怎么获得PWM句柄呢？使用如下的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* include/linux/pwm.h */</span><br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">of_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">devm_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">devm_of_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">devm_pwm_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br></code></pre></td></tr></table></figure><p><code>pwm_get/devm_pwm_get</code>，从指定设备（dev）的DTS节点中，获得对应的PWM句柄。可以通过con_id指定一个名称，或者会获取和该设备绑定的第一个PWM句柄。设备的DTS文件需要用这样的格式指定所使用的PWM device：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bl: backlight &#123;       <br>pwms = &lt;&amp;pwm <span class="hljs-number">0</span> <span class="hljs-number">5000000</span> PWM_POLARITY_INVERTED&gt;;       <br>pwm-names = <span class="hljs-string">&quot;backlight&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果“con_id”为NULL，则返回DTS中“pwms”字段所指定的第一个PWM device；如果“con_id”不为空，如是“backlight”，则返回和“pwm-names ”字段所指定的name对应的PWM device。</p><p>上面“pwms”字段各个域的含义如下：<br>1）<code>&amp;pwm</code>，对DTS中pwm节点的引用；<br>2）<code>0</code>，pwm device的设备号，具体需要参考SOC以及pwm driver的实际情况；<br>3）<code>5000000</code>，PWM信号默认的周期，单位是纳秒（ns）；<br>4）<code>PWM_POLARITY_INVERTED</code>，可选字段，是否提供由pwm driver决定，表示pwm信号的极性，若为0，则正常极性，若为<code>PWM_POLARITY_INVERTED</code>，则反转极性。</p><p><code>of_pwm_get/devm_of_pwm_get</code>，和<code>pwm_get/devm_pwm_get</code>类似，区别是可以指定需要从中解析PWM信息的<code>device node</code>，而不是直接指定device指针。</p><h1 id="PWM-provider"><a href="#PWM-provider" class="headerlink" title="PWM provider"></a>PWM provider</h1><h3 id="2-1-pwm-chip"><a href="#2-1-pwm-chip" class="headerlink" title="2.1 pwm_chip"></a>2.1 pwm_chip</h3><p>抽象PWM控制器</p><p>在一个SOC中，可以同时支持多路PWM输出，以便同时控制多个PWM设备。这样每一路PWM输出，可以看做一个PWM设备（struct pwm_device）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct pwm_chip - abstract a PWM controller</span><br><span class="hljs-comment"> * @dev: device providing the PWMs</span><br><span class="hljs-comment"> * @ops: callbacks for this PWM controller</span><br><span class="hljs-comment"> * @base: number of first PWM controlled by this chip</span><br><span class="hljs-comment"> * @npwm: number of PWMs controlled by this chip</span><br><span class="hljs-comment"> * @of_xlate: request a PWM device given a device tree PWM specifier</span><br><span class="hljs-comment"> * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier</span><br><span class="hljs-comment"> * @list: list node for internal use</span><br><span class="hljs-comment"> * @pwms: array of PWM devices allocated by the framework</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_ops</span> *<span class="hljs-title">ops</span>;</span><br>  <span class="hljs-type">int</span> base; <span class="hljs-comment">// 动态指定pwm起始软件编号。旧的pwm_request会使用。在底层driver指定，传入-1即可。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npwm;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> * (*<span class="hljs-title">of_xlate</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> *<span class="hljs-title">pc</span>,</span><br><span class="hljs-class">          <span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">of_phandle_args</span> *<span class="hljs-title">args</span>);</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> of_pwm_n_cells;<br><br>  <span class="hljs-comment">/* only used internally by the PWM framework */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> *<span class="hljs-title">pwms</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>dev</code>，该pwm chip对应的设备，一般由pwm driver对应的platform驱动指定。必须提供！</p><p><code>ops</code>，操作PWM设备的回调函数，后面会详细介绍。必须提供！</p><p><code>npwm</code>，该pwm chip可以支持的pwm channel（也可以称作pwm device由struct pwm_device表示）个数，kernel会根据该number，分配相应个数的struct pwm_device结构，保存在pwms指针中。必须提供！</p><p><code>pwms</code>，保存所有pwm device的数组，kernel会自行分配，不需要driver关心。</p><p><code>base</code>，在将该chip下所有pwm device组成radix tree时使用，只有旧的pwm_request接口会使用，因此忽略它吧，编写pwm driver不需要关心。</p><p><code>of_pwm_n_cells</code>，该PWM chip所提供的DTS node的cell，一般是2或者3，例如：为3时，consumer需要在DTS指定pwm number、pwm period和pwm flag三种信息（如2.1中的介绍）；为2时，没有flag信息。</p><p><code>of_xlate</code>，用于解析consumer中指定的、pwm信息的DTS node的回调函数（如2.1中介绍的，pwms &#x3D; &lt;&amp;pwm 0 5000000 PWM_POLARITY_INVERTED&gt;）。</p><p>注2：一般情况下，of_pwm_n_cells取值为3，或者2（不关心极性），of_xlate则可以使用kernel提供的of_pwm_xlate_with_flags（解析of_pwm_n_cells为3的chip）或者of_pwm_simple_xlate（解析of_pwm_n_cells为2的情况）。</p><h3 id="2-2-pwm-ops"><a href="#2-2-pwm-ops" class="headerlink" title="2.2 pwm_ops"></a>2.2 pwm_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_ops</span> &#123;</span><br>  <span class="hljs-type">int</span> (*request)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">int</span> (*capture)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>           <span class="hljs-keyword">struct</span> pwm_capture *result, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout);<br>  <span class="hljs-type">int</span> (*apply)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>         <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pwm_state *state);<br>  <span class="hljs-type">void</span> (*get_state)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>        <span class="hljs-keyword">struct</span> pwm_state *state);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><br>  <span class="hljs-comment">/* Only used by legacy drivers 目前rts使用的是legacy接口 */</span><br>  <span class="hljs-type">int</span> (*config)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>          <span class="hljs-type">int</span> duty_ns, <span class="hljs-type">int</span> period_ns);<br>  <span class="hljs-type">int</span> (*set_polarity)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>          <span class="hljs-keyword">enum</span> pwm_polarity polarity);<br>  <span class="hljs-type">int</span> (*enable)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">void</span> (*disable)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些回调函数的操作对象是具体的<code>pwm device</code>，包括：</p><p><code>config</code>，配置<code>pwm device</code>的频率、占空比。必须提供！</p><p><code>enable/disable</code>，使能&#x2F;禁止pwm信号输出。必须提供！</p><p><code>request/free</code>，不再使用。</p><p><code>set_polarity</code>，设置pwm信号的极性。可选，具体需要参考<code>of_pwm_n_cells</code>的定义。</p><h3 id="2-3-pwm-device"><a href="#2-3-pwm-device" class="headerlink" title="2.3 pwm device"></a>2.3 pwm device</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hwpwm; <span class="hljs-comment">// pwm device对应的hardware pwm number，可用于寄存器的寻址操作</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pwm; <span class="hljs-comment">// chip-&gt;base + hwpwm</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> *<span class="hljs-title">chip</span>;</span><br>  <span class="hljs-type">void</span> *chip_data;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_args</span> <span class="hljs-title">args</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_state</span> <span class="hljs-title">state</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-4-pwmchip-add-x2F-pwmchip-remove"><a href="#2-4-pwmchip-add-x2F-pwmchip-remove" class="headerlink" title="2.4 pwmchip_add&#x2F;pwmchip_remove"></a>2.4 <strong>pwmchip_add&#x2F;pwmchip_remove</strong></h3><p>初始化完成后的pwm chip可以通过pwmchip_add接口注册到kernel中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>: <span class="hljs-type">int</span> <span class="hljs-title function_">pwmchip_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_chip *chip)</span>;<br><span class="hljs-number">2</span>: <span class="hljs-type">int</span> <span class="hljs-title function_">pwmchip_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_chip *chip)</span>;<br></code></pre></td></tr></table></figure><h1 id="API使用指南"><a href="#API使用指南" class="headerlink" title="API使用指南"></a>API使用指南</h1><h3 id="3-2-provider编写PWM-driver的步骤"><a href="#3-2-provider编写PWM-driver的步骤" class="headerlink" title="3.2 provider编写PWM driver的步骤"></a>3.2 provider编写PWM driver的步骤</h3><p>1）创建代表该pwm driver的DTS节点，并提供platform device有关的资源信息，例如：</p><p>2）定义一个<code>pwm chip</code>变量。</p><p>3）注册相应的platform driver，并在driver的.probe()接口中，初始化pwm chip变量，至少要包括如下字段：</p><p><code>dev</code>，使用platform device中的dev指针即可；<code>npwm；ops</code>，至少包括<code>config、enable、disable</code>三个回调函数。</p><p><strong>如果该pwm chip支持额外的flag（如PWM极性，或者自定义的flag），将PWM cell指定为3（of_pwm_n_cells），of_xlate指定为of_pwm_xlate_with_flags。</strong></p><p>4）每当consumer有API调用时，kernel会以pwm device为参数，调用pwm driver提供的pwm ops，相应的回调函数可以从pwm device中取出pwm number（该number的意义driver自行解释），并操作对应的寄存器即可。</p><h3 id="3-3-consumer使用PWM的步骤"><a href="#3-3-consumer使用PWM的步骤" class="headerlink" title="3.3 consumer使用PWM的步骤"></a>3.3 <strong>consumer使用PWM的步骤</strong></h3><p>1）查看pwm provider所提供的pwm dts binding信息（一般会在“Documentation&#x2F;devicetree&#x2F;bindings&#x2F;pwm”目录中），并以此在该device所在的dts node中添加“pwms ”以及“pwm-names ”相关的配置。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch\arm\boot\dts\imx23-evk.dts */</span><br><br>backlight &#123;       <br>compatible = <span class="hljs-string">&quot;pwm-backlight&quot;</span>;        <br>pwms = &lt;&amp;pwm <span class="hljs-number">2</span> <span class="hljs-number">5000000</span>&gt;;       <br>brightness-levels = &lt;<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span> <span class="hljs-number">128</span> <span class="hljs-number">255</span>&gt;;       <br><span class="hljs-keyword">default</span>-brightness-level = &lt;<span class="hljs-number">6</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）在driver的probe接口中，调用<strong>devm_pwm_get</strong>接口，获取<strong>pwm device</strong>句柄，并保存起来。</p><p>3）devm_pwm_get成功后，该pwm信号已经具备初始的周期和极性。后续根据需要，可以调用<strong>pwm_config</strong>更改该pwm信号的周期、占空比。</p><p>4）driver可以根据需要，调用<strong>pwm_enable&#x2F;pwm_disable</strong>接口，打开或者关闭pwm信号的输出。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>原理介绍：<a href="https://zhuanlan.zhihu.com/p/374083276">https://zhuanlan.zhihu.com/p/374083276</a></p><p>Driver解析：<a href="http://www.wowotech.net/comm/pwm_overview.html">http://www.wowotech.net/comm/pwm_overview.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Missing-semester_ch4_commandline_environment</title>
    <link href="/2023/02/07/Missing-semester-ch4-commandline-environment/"/>
    <url>/2023/02/07/Missing-semester-ch4-commandline-environment/</url>
    
    <content type="html"><![CDATA[<h1 id="Job-control"><a href="#Job-control" class="headerlink" title="Job control"></a>Job control</h1><p><code>jobs</code>: lists the unfinished jobs associated with the current terminal session.</p><p><code>fg + %num </code>: <code>num</code>是<code>jobs</code>命令显示进程对应的序号。</p><p><code>bg+ %num</code>: 让进程在后台从stopped-&gt;running。</p><p><code>ctrl + z</code>: 让当前进程进入后台并suspend。</p><h1 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h1><p><code>tmux</code>: open a new session.</p><p><code>C-b %</code>: 左右分屏。</p><p><code>C-b &quot;</code>: 上下分屏。</p><p><code>C-b &lt;arrow key&gt;</code>:在panes间移动。</p><p><code>exit</code> or hit <code>Ctrl-d</code>：退出当前pane。</p><p><code>C-b c</code>: new window.</p><p><code>C-b p</code>: previous window.</p><p><code>C-b n</code>: next window.</p><p><code>C-b &lt;number&gt;</code> : move to window n.</p><p><code>tmux ls</code>: list sessions.</p><p><code>tmux attach -t 0</code>: attach to 0 session.</p><p><code>C-b ?</code>: help message.</p><p><code>C-b z</code>: make a pane go full screen. Hit <code>C-b z</code> again to shrink it back to its previous size</p><p><code>C-b C-&lt;arrow key&gt;</code>: Resize pane in direction of <arrow key></p><p><code>C-b ,</code>: Rename the current window</p><p><code>&lt;C-b&gt; [</code> Start scrollback. You can then press <code>&lt;space&gt;</code> to start a selection and <code>&lt;enter&gt;</code> to copy that selection.</p><h2 id="my-configs"><a href="#my-configs" class="headerlink" title="my configs"></a>my configs</h2><p><code>C-b</code> -&gt; <code>C-a</code></p><p><code>C-b %</code> -&gt; <code>C-a |</code></p><p><code>C-b &quot;</code> -&gt; <code>C-a -</code></p><p><code>C-b &lt;arrow key&gt;</code> -&gt; <code>alt &lt;arrow key&gt;</code></p><p><a href="https://missing.csail.mit.edu/2020/command-line/">more commands click this</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>Missing semester</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS2022 PA2</title>
    <link href="/2023/01/31/ICS/ICS2022-PA2/"/>
    <url>/2023/01/31/ICS/ICS2022-PA2/</url>
    
    <content type="html"><![CDATA[<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><p>mul-longlong.c中check <code>0xaeb1c2aa * 0xaeb1c2aa = 0x19d29ab9db1a18e4LL</code></p><p>实现mulh指令遇到的一个问题：</p><p>由于<code>src1</code>和<code>src2</code>都是<code>unsigned int</code>，强制类型转换为<code>long</code>（零扩展），得到的是无符号相乘结果<code>0x7736200d</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// 直接u32*u32会溢出，乘出来还是u32</span><br>u32 src1 = <span class="hljs-number">0xaeb1c2aa</span>;<br>u32 src2 = <span class="hljs-number">0xaeb1c2aa</span><br>INSTPAT(<span class="hljs-string">&quot;...&quot;</span>, mulh, R, R(dest) = (((<span class="hljs-type">long</span>)src1 * (<span class="hljs-type">long</span>)src2) &gt;&gt; <span class="hljs-number">32</span>));<br></code></pre></td></tr></table></figure><p>先修改为<code>int</code>型，再改为<code>long</code>型（符号扩展）则可以顺利得到<code>0x19d29ab9</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">INSTPAT(<span class="hljs-string">&quot;...&quot;</span>, mulh, R, R(dest) = (((<span class="hljs-type">long</span>)(<span class="hljs-type">int</span>)src1 * (<span class="hljs-type">long</span>)(<span class="hljs-type">int</span>)src2) &gt;&gt; <span class="hljs-number">32</span>));<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230201173605.png"></div><div class="group-image-wrap"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230201173534.png"></div></div></div><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><h3 id="通过批处理模式运行NEMU"><a href="#通过批处理模式运行NEMU" class="headerlink" title="通过批处理模式运行NEMU"></a>通过批处理模式运行NEMU</h3><p><code>abstract-machine/scripts/platform/nemu.mk</code>中<code>NEMUFLAGS</code>加上<code>-b</code>，选择批处理模式，不用每次进入nemu都输入<code>c</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell scripts</title>
    <link href="/2023/01/30/Missing-semester_ch1_shell-scripts/"/>
    <url>/2023/01/30/Missing-semester_ch1_shell-scripts/</url>
    
    <content type="html"><![CDATA[<p><code>foo=bar</code> 变量定义<code>=</code>左右不能加空格。</p><p>用<code>&#39;</code>分隔的字符串是字面值字符串，不会替换变量值，而用<code>&quot;</code>分隔的字符串会。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo=bar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><br><span class="hljs-comment"># prints bar</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><br><span class="hljs-comment"># prints $foo</span><br></code></pre></td></tr></table></figure><p><code>$0</code>- Name of the script<br><code>$1</code>- to $9 - Arguments to the script. $1 is the first argument and so on.<br><code>$@</code>- All the arguments<br><code>$#</code>- Number of arguments<br><code>$?</code>- Return code of the previous command<br><code>$$</code>- Process identification number (PID) for the current script<br><code>!!</code>- Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code><br><code>$_</code>- Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by <code>.</code> or <code>Alt+.</code></p><p>The <code>true</code> program will always have a 0 return code and the <code>false</code> command will always have a 1 return code.</p><p><code>Command1 &amp;&amp; Command2</code> 如果Command1命令运行成功，则继续运行Command2命令。<br><code>Command1 || Command2</code> 如果Command1命令运行失败，则继续运行Command2命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Oops, fail&quot;</span><br><span class="hljs-comment"># Oops, fail</span><br><br><span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Things went well&quot;</span><br><span class="hljs-comment"># Things went well</span><br><br><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will always run&quot;</span><br><span class="hljs-comment"># This will always run</span><br><br><span class="hljs-literal">false</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will always run&quot;</span><br><span class="hljs-comment"># This will always run</span><br></code></pre></td></tr></table></figure><p><strong>command substitution</strong><br><code>$(CMD)</code> will execute CMD, get the output of the command and substitute it in place.<br><code>for file in $(ls)</code> will first call ls and then iterate over those values.</p><p><strong>process substitution</strong><br><code>&lt;(CMD)</code> will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name.<br><code>diff &lt;(ls foo) &lt;(ls bar)</code> will show differences between files in dirs foo and bar.</p><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># Date will be substituted</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null <span class="hljs-comment"># 标准输出和标准错误都重定向到/dev/null</span><br>    <span class="hljs-comment"># When pattern is not found, grep has exit status 1</span><br>    <span class="hljs-comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>try to use double brackets [[ ]] in favor of simple brackets [ ]</p>          </div><h2 id="shell-globbing-Wildcards-替换单个字符-替换后面所有字符-Curly-braces"><a href="#shell-globbing-Wildcards-替换单个字符-替换后面所有字符-Curly-braces" class="headerlink" title="shell globbing- Wildcards  - ?替换单个字符  - *替换后面所有字符- Curly braces {}"></a><strong>shell globbing</strong><br>- Wildcards<br>  - <code>?</code>替换单个字符<br>  - <code>*</code>替换后面所有字符<br>- Curly braces <code>&#123;&#125;</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<br><span class="hljs-comment"># Will expand to</span><br>convert image.png image.jpg<br><br><span class="hljs-built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<br><span class="hljs-comment"># Will expand to</span><br><span class="hljs-built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<br><br><span class="hljs-comment"># Globbing techniques can also be combined</span><br><span class="hljs-built_in">mv</span> *&#123;.py,.sh&#125; folder<br><span class="hljs-comment"># Will move all *.py and *.sh files</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Missing semester</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2023/01/13/Missing-semester_ch2_Vim/"/>
    <url>/2023/01/13/Missing-semester_ch2_Vim/</url>
    
    <content type="html"><![CDATA[<h1 id="Modal-editing"><a href="#Modal-editing" class="headerlink" title="Modal editing"></a>Modal editing</h1><ul><li><strong>Normal</strong>: for moving around a file and making edits</li><li><strong>Insert</strong>: <code>i</code> for inserting text</li><li><strong>Replace</strong>: <code>R</code> for replacing text</li><li><strong>Visual</strong>: (plain<code>v</code>, line<code>V</code>, or block<code>Ctrl+v</code>): for selecting blocks of text(use movement keys).</li><li><strong>Command-line</strong>: <code>:</code> for running a command</li></ul><p><code>&lt;ESC&gt;</code>  switch from any mode back to <strong>Normal mode</strong>.</p><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="Command-line"><a href="#Command-line" class="headerlink" title="Command-line"></a>Command-line</h2><ul><li><code>:q</code> quit (close window)</li><li><code>:w</code> save (“write”)</li><li><code>:wq</code> save and quit</li><li><code>:e &#123;name of file&#125;</code> open file for editing</li><li><code>:ls</code> show open buffers</li><li><code>:help &#123;topic&#125;</code> open help<ul><li><code>:help :w</code> opens help for the <code>:w</code> command</li><li><code>:help w</code> opens help for the <code>w</code> movement</li></ul></li></ul><h1 id="Vim’s-interface-is-a-programming-language"><a href="#Vim’s-interface-is-a-programming-language" class="headerlink" title="Vim’s interface is a programming language"></a>Vim’s interface is a programming language</h1><h2 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a>Movement</h2><p><strong>Movements in Vim are also called “nouns”.</strong></p><ul><li>Basic movement: <code>hjkl</code> (left, down, up, right)</li><li>Words: <code>w</code> (next word), <code>b</code> (beginning of word), <code>e</code> (end of word)</li><li>Lines: <code>0</code> (beginning of line), <code>^</code> (first non-blank character), <code>$</code> (end of line)</li><li>Screen: <code>H</code> (top of screen), <code>M</code> (middle of screen), <code>L</code> (bottom of screen)</li><li>Scroll: <code>Ctrl-u</code> (up), <code>Ctrl-d</code> (down)</li><li>File: <code>gg</code> (beginning of file), <code>G</code> (end of file)</li><li>Line numbers: <code>:&#123;number&#125;&lt;CR&gt;</code> or <code>&#123;number&#125;G</code> (line {number})</li><li>Misc: <code>%</code> (corresponding item)</li><li>Find: <code>f&#123;character&#125;</code>, <code>t&#123;character&#125;</code>, <code>F&#123;character&#125;</code>, <code>T&#123;character&#125;</code><ul><li>find&#x2F;to forward&#x2F;backward {character} on the current line</li><li><code>,</code> &#x2F; <code>;</code> for navigating matches</li></ul></li><li>Search: <code>/&#123;regex&#125;</code>, <code>n</code> &#x2F; <code>N</code> for navigating matches</li></ul><h2 id="Edits"><a href="#Edits" class="headerlink" title="Edits"></a>Edits</h2><p><strong>Vim’s editing commands are also called “verbs”</strong></p><ul><li><code>i</code> enter Insert mode</li><li><code>o</code> &#x2F; <code>O</code> insert line below &#x2F; above</li><li><code>d&#123;motion&#125;</code> delete {motion}<ul><li>e.g. <code>dw</code> is delete word, <code>d$</code> is delete to end of line, <code>d0</code> is delete to beginning of line</li></ul></li><li><code>c&#123;motion&#125;</code> change {motion}<ul><li>e.g. <code>cw</code> is change word. like <code>d&#123;motion&#125;</code> followed by <code>i</code></li></ul></li><li><code>x</code> delete character (equal do <code>dl</code>)</li><li><code>s</code> substitute character (equal to <code>cl</code>)</li><li>Visual mode + manipulation<ul><li>select text, <code>d</code> to delete it or <code>c</code> to change it</li></ul></li><li><code>u</code> to undo, <code>&lt;Ctrl+r&gt;</code> to redo</li><li><code>y</code> to copy &#x2F; “yank” (some other commands like <code>d</code> also copy)</li><li><code>p</code> to paste</li><li>Lots more to learn: e.g. <code>~</code> flips the case of a character</li></ul><h2 id="Counts"><a href="#Counts" class="headerlink" title="Counts"></a>Counts</h2><p>You can combine <strong>nouns</strong> and <strong>verbs</strong> with a <strong>count</strong>, which will perform a given action a number of times.</p><ul><li><code>3w</code> move 3 words forward</li><li><code>5j</code> move 5 lines down</li><li><code>7dw</code> delete 7 words</li></ul><h2 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h2><p>You can use modifiers to change the meaning of a noun. Some modifiers are <code>i</code>, which means “inner” or “inside”, and <code>a</code>, which means “around”.</p><blockquote><p>光标在括号中，<code>ci(</code>可以把括号内的内容替换并进入insert，类似<code>di(</code>也一样，相当于删除。<code>da(</code>连带括号一起删除。</p><p>这里的<code>i</code>和<code>a</code>不是edit中的含义，而是<strong>inner</strong>和<strong>around</strong>的意思。</p></blockquote><ul><li><code>ci(</code> change the contents inside the current pair of parentheses</li><li><code>ci[</code> change the contents inside the current pair of square brackets</li><li><code>da&#39;</code> delete a single-quoted string, including the surrounding single quotes</li></ul><h1 id="Customizing-Vim"><a href="#Customizing-Vim" class="headerlink" title="Customizing Vim"></a>Customizing Vim</h1><p><a href="https://github.com/YC-Xiang/dotfiles/blob/main/vim/.vimrc">my vim config</a></p><h1 id="Extending-Vim"><a href="#Extending-Vim" class="headerlink" title="Extending Vim"></a>Extending Vim</h1><p>Vim 8.0 之后自带插件管理工具，只要create the directory <code>~/.vim/pack/vendor/start/</code>, and put plugins in there (e.g. via <code>git clone</code>). <code>vendor</code>目录名好像可以替换。</p><h1 id="Advanced-Vim"><a href="#Advanced-Vim" class="headerlink" title="Advanced Vim"></a>Advanced Vim</h1><h2 id="Search-and-replace"><a href="#Search-and-replace" class="headerlink" title="Search and replace"></a>Search and replace</h2><p><code>:s</code> (substitute) command</p><ul><li><code>%s/foo/bar/g</code><ul><li>replace foo with bar globally in file</li><li><code>%s/\[.*\](\(.*\))/\1/g</code></li><li>replace named Markdown links with plain URL</li></ul></li></ul><h2 id="Multiple-windows"><a href="#Multiple-windows" class="headerlink" title="Multiple windows"></a>Multiple windows</h2><ul><li><code>:sp</code> &#x2F; <code>:vsp</code> to split windows</li><li>Can have multiple views of the same buffer.</li></ul><h2 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h2><p>to do</p><h1 id="Vimtutor"><a href="#Vimtutor" class="headerlink" title="Vimtutor"></a>Vimtutor</h1><h2 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h2><p><code>hjkl</code> 移动</p><p><code>x</code> 删除一个字符</p><p><code>i</code> 输入</p><p><code>a</code> append输入</p><h2 id="Lesson-2"><a href="#Lesson-2" class="headerlink" title="Lesson 2"></a>Lesson 2</h2><p><code>dw</code> 删除一个单词</p><p><code>d$</code> 输出到行尾</p><p><code>2w</code> <code>3b</code> <code>2e</code> 移动单词</p><p><code>d2w</code> 删除两个单词</p><p><code>dd</code> <code>2dd</code> 删除两行</p><p><code>u</code> 撤销 <code>U</code> 返回一行的原始状态 <code>Ctrl r</code> 复原</p><h2 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title="Lesson 3"></a>Lesson 3</h2><p><code>dd</code> 之后的一行可以 <code>p</code> 粘贴</p><p><code>rx</code> 替换某个字符为<code>x</code></p><p><code>ce</code> 删除光标后单词部分，并进入insert mode <code>c$</code> 输出光标到行尾，并进入insert mode</p><h2 id="Lesson-4"><a href="#Lesson-4" class="headerlink" title="Lesson 4"></a>Lesson 4</h2><p><code>Ctrl g</code> 显示当前行状态 <code>G</code> 文件末尾 <code>gg</code> 文件开头</p><p><code>/</code> 向后搜索 <code>?</code>向前搜索 <code>ctrl o</code> 返回 <code>ctrl i</code> 前进</p><p><code>%</code> 跳转到对应匹配的<code>) ] &#125;</code></p><p><code>s/thee/the/g</code> 替换一个<code>thee</code>成<code>the</code></p><p><code>s/thee/the/g</code> 一行中<code>thee</code>替换成<code>the</code></p><p><code>:%s/thee/the/g</code> 整个文件的<code>thee</code>替换成<code>the</code></p><p><code>:%s/thee/the/gc</code> 整个文件的<code>thee</code>替换成<code>the</code>，每个替换会有命令提示</p><p><code>:#,#s/thee/the/g</code> <code>#</code> 是替换的行范围</p><h2 id="Lesson-5"><a href="#Lesson-5" class="headerlink" title="Lesson 5"></a>Lesson 5</h2><p><code>! + command</code> 执行外部命令</p><p><code>:w FILENAME</code> 文件另存为</p><p><code>v</code> 进入visual模式选中再 <code>:w FILENAME</code> 保存部分内容</p><p><code>:r FILENAME</code> 将文件内容追加到光标下</p><p><code>:r !ls</code> 将ls内容加到光标下</p><h2 id="Lesson-6"><a href="#Lesson-6" class="headerlink" title="Lesson 6"></a>Lesson 6</h2><p><code>o</code> 光标下插入新行 <code>O</code>光标上插入新行</p><p><code>R</code> replace mode</p><p><code>2y</code> 复制两行</p><p><code>:set ic</code> 接下来搜索大小写都会包括</p><h2 id="Lesson-7"><a href="#Lesson-7" class="headerlink" title="Lesson 7"></a>Lesson 7</h2><p><code>:</code>接<code>ctrl d</code>可以自动显示命令</p><p>&#96;&#96;</p><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><p><a href="https://vim-adventures.com/">Vim Adventures</a> is a game to learn Vim</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Missing semester</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/01/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/01/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://regexone.com/">RegexOne</a></p><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">github正则表达式</a></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230112170412.png"></p><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><h2 id="Lesson-1-The-123s"><a href="#Lesson-1-The-123s" class="headerlink" title="Lesson 1 The 123s"></a>Lesson 1 The 123s</h2><p><code>\d</code>any single digit character</p><p><code>\D</code>any single non-digit character</p><h2 id="Lesson-2-The-Dot"><a href="#Lesson-2-The-Dot" class="headerlink" title="Lesson 2: The Dot"></a>Lesson 2: The Dot</h2><p><code>.</code>any single character</p><p><code>\.</code>period</p><h2 id="Lesson-3-Matching-specific-characters"><a href="#Lesson-3-Matching-specific-characters" class="headerlink" title="Lesson 3: Matching specific characters"></a>Lesson 3: Matching specific characters</h2><p><code>[abc]</code>only a, b, c single character</p><h2 id="Lesson-4-Excluding-specific-characters"><a href="#Lesson-4-Excluding-specific-characters" class="headerlink" title="Lesson 4: Excluding specific characters"></a>Lesson 4: Excluding specific characters</h2><p><code>[^abc]</code>not a, b or c</p><h2 id="Lesson-5-Character-ranges"><a href="#Lesson-5-Character-ranges" class="headerlink" title="Lesson 5: Character ranges"></a>Lesson 5: Character ranges</h2><p><code>[a-z]</code>characters a to z</p><p><code>[0-9]</code>number 0 to 9</p><p><code>\w</code>字母，数字，下划线。等价于<code>[A-Za-z0-9_]</code></p><p><code>\W</code>等价于<code>\[^A-Za-z0-9_]</code></p><h2 id="Lesson-6-Catching-some-zzz’s"><a href="#Lesson-6-Catching-some-zzz’s" class="headerlink" title="Lesson 6: Catching some zzz’s"></a>Lesson 6: Catching some zzz’s</h2><p><code>&#123;m&#125;</code>m repetitions</p><p><code>&#123;m, n&#125;</code>m to n repetitions</p><p>Examples:</p><p><code>w&#123;3&#125;</code> (three w)</p><p><code>[wxy]&#123;5&#125;</code> (five characters, each of which can be a w, x, or y)</p><h2 id="Lesson-7-Mr-Kleene-Mr-Kleene"><a href="#Lesson-7-Mr-Kleene-Mr-Kleene" class="headerlink" title="Lesson 7: Mr. Kleene, Mr. Kleene"></a>Lesson 7: Mr. Kleene, Mr. Kleene</h2><p><code>*</code> <strong>zero</strong> or more repetitions *前的字符可以重复0次或者更多次</p><p><code>+</code><strong>one</strong> or more repetitions +前的字符可以重复1次或者更多次</p><p>Match<code>aaaabcc</code></p><p>Match<code>aabbbbc</code></p><p>Match<code>aacc</code></p><p>Skip<code>a</code></p><p>answer: <code>aa+b*c+</code></p><h2 id="Lesson-8-Characters-optional"><a href="#Lesson-8-Characters-optional" class="headerlink" title="Lesson 8: Characters optional"></a>Lesson 8: Characters optional</h2><p><code>?</code>optional character ?前的字符可以出现0次或者1次</p><p><code>ab?c</code> will match either the strings “<code>abc</code>“ or “<code>ac</code>“</p><h2 id="Lesson-9-All-this-whitespace"><a href="#Lesson-9-All-this-whitespace" class="headerlink" title="Lesson 9: All this whitespace"></a>Lesson 9: All this whitespace</h2><p><code>\s</code>代替any whitespace 包括space, tab(\t), new line(\n), return(\r)</p><p><code>\S</code>相反</p><h2 id="Lesson-10-Starting-and-ending"><a href="#Lesson-10-Starting-and-ending" class="headerlink" title="Lesson 10: Starting and ending"></a>Lesson 10: Starting and ending</h2><p><code>^...$</code>starts and ends</p><p><code>^Mission: successful$</code>文本必须以Mission: 开头, successful结尾</p><h2 id="Lesson-11-Match-groups"><a href="#Lesson-11-Match-groups" class="headerlink" title="Lesson 11: Match groups"></a>Lesson 11: Match groups</h2><p><code>(...)</code>capture group</p><p><code>(a(bc))</code>capture sub-group</p><p><code>(.*)</code>capture all</p><h2 id="Lesson-14-It’s-all-conditional"><a href="#Lesson-14-It’s-all-conditional" class="headerlink" title="Lesson 14: It’s all conditional"></a>Lesson 14: It’s all conditional</h2><p><code>(abc|def)</code>matches abc or def</p><h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h1><h2 id="Problem-1-Matching-a-decimal-numbers"><a href="#Problem-1-Matching-a-decimal-numbers" class="headerlink" title="Problem 1: Matching a decimal numbers"></a>Problem 1: Matching a decimal numbers</h2><table><thead><tr><th>Task</th><th>Text</th></tr></thead><tbody><tr><td>Match</td><td>3.14529</td></tr><tr><td>Match</td><td>-255.34</td></tr><tr><td>Match</td><td>128</td></tr><tr><td>Match</td><td>1.9e10</td></tr><tr><td>Match</td><td>123,340.00</td></tr><tr><td>Skip</td><td>720p</td></tr></tbody></table><p>answer:<code>^-?\d+(,\d+)*(\.\d+(e\d+)?)?$</code></p><h2 id="Problem-2-Matching-phone-numbers"><a href="#Problem-2-Matching-phone-numbers" class="headerlink" title="Problem 2: Matching phone numbers"></a>Problem 2: Matching phone numbers</h2><p>后面还有很多problems</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表示式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沉默的大多数</title>
    <link href="/2023/01/11/reading/%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B9%90%E8%B6%A3/"/>
    <url>/2023/01/11/reading/%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B9%90%E8%B6%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="思维的乐趣"><a href="#思维的乐趣" class="headerlink" title="思维的乐趣"></a>思维的乐趣</h1><p>假如一个人每天吃一样的饭，干一样的活，再加上把八个样板戏翻过来倒过去地看，看到听了上句就知道下句的程度，就值得我最大的同情。我最赞同罗素先生的一句话：“须知参差多态，乃是幸福本源”。</p><p>在我们生活的这个世界上，最大的不幸就是有些人完全拒绝新奇。</p><p>这世界上有人喜欢丰富，有人喜欢单纯；我未见过喜欢丰富的人妒恨，伤害喜欢单纯的人，我见到的情形总是相反。</p><p>据此我认为我们国家自汉代以后，一直在进行思想上的大屠杀；而我能够这样想，只说明我是幸存者之一。除了对此表示悲伤之外，我想不到别的了。</p>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICS_2022 PA1</title>
    <link href="/2023/01/10/ICS/ICS2022%20PA1/"/>
    <url>/2023/01/10/ICS/ICS2022%20PA1/</url>
    
    <content type="html"><![CDATA[<h1 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h1><p><a href="https://www.jianshu.com/p/ae4ae0ef57bc">getopt_long函数</a></p><p><code>strtok</code>函数：分割字符串</p><p><code>atoi</code>函数：字符串数字转为int类型。</p><p><code>strtol</code>函数：可以根据字符串数字为十进制&#x2F;十六进制…，并转化为<code>long int</code>。如<code>strtol(0xabc, NULL, 16)</code>。</p><p>打印<code>unsigned int</code>使用<code>%u</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># nemu/scripts/native.mk</span><br><br><span class="hljs-section">compile_git:</span><br>  <span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, &quot;compile NEMU&quot;)</span><br><span class="hljs-variable">$(BINARY)</span>: compile_git<br><br><span class="hljs-keyword">override</span> ARGS ?= --log=<span class="hljs-variable">$(BUILD_DIR)</span>/nemu-log.txt<br><span class="hljs-keyword">override</span> ARGS += <span class="hljs-variable">$(ARGS_DIFF)</span> <span class="hljs-comment"># nemu/tools/difftest.mk中CONFIG_DIFFTEST未定义，所以ARGS_DIFF不存在</span><br><br>IMG ?=<br><br>NEMU_EXEC := <span class="hljs-variable">$(BINARY)</span> <span class="hljs-variable">$(ARGS)</span> <span class="hljs-variable">$(IMG)</span><br><br><span class="hljs-section">run: run-env</span><br>  <span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, &quot;run NEMU&quot;)</span><br>  <span class="hljs-variable">$(NEMU_EXEC)</span><br><br></code></pre></td></tr></table></figure><p>由makefile可知，输入<code>make run</code>启动nemu时，传递给<code>monitor.c parse_args(argc, argv)</code>的参数为<br><code>--log=$(BUILD_DIR)/nemu-log.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    init_monitor(argc, argv);<br>    parse_args(argc, argv);<br>      init_rand();<br>      init_log(log_file);<br>      init_mem(); <span class="hljs-comment">// 随机初始化内存</span><br>    init_isa();<br>      <span class="hljs-built_in">memcpy</span>(guest_to_host(RESET_VECTOR), img, <span class="hljs-keyword">sizeof</span>(img)); <span class="hljs-comment">//加载内置客户程序</span><br>      restart(); <span class="hljs-comment">// 初始化pc和0寄存器</span><br>      load_img();<br>    init_sdb();<br>    welcome();<br>    engine_start();<br>     sdb_mainloop();<br>        str = rl_gets(); <span class="hljs-comment">// 获取在(nemu)中输入的字符串</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(cmd, cmd_table[i].name) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据输入的字符串调用不同的handler函数</span><br>        <span class="hljs-keyword">if</span> (cmd_table[i].handler(args) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span>; &#125;<br>      <span class="hljs-keyword">break</span>;<br>      cmd_c();<br>        cpu_exec();<br>          execute(n);<br>            exec_once(&amp;s, cpu.pc);<br>              isa_exec_once(s);<br>            trace_and_difftest(&amp;s, cpu.pc);<br>      cmd_q();<br>      cmd_si();<br>      cmd_info();<br>      cmd_x();<br>      cmd_help();<br>      &#125;<br></code></pre></td></tr></table></figure><h1 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h1><h2 id="配置系统和项目构建"><a href="#配置系统和项目构建" class="headerlink" title="配置系统和项目构建"></a>配置系统和项目构建</h2><p>在<code>nemu</code>目录下执行<code>make menuconfig</code>,结果会保存至<code>nemu/.config</code></p><p>生成</p><p>可以被包含到C代码中的宏定义：<code>nemu/include/generated/autoconf.h</code></p><p>可以被包含到Makefile中的变量定义：<code>nemu/include/config/auto.conf</code></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第十章 RISC-V特权架构</title>
    <link href="/2023/01/09/RISC-V%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2023/01/09/RISC-V%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="10-1-导言"><a href="#10-1-导言" class="headerlink" title="10.1 导言"></a>10.1 导言</h2><p>到目前为止，本书主要关注RISC-V 对通用计算的支持：我们引入的所有指令都在用户模式（User mode 应用程序的代码在此模式下运行）下可用。本章介绍两种新的权限模式：运行最可信的代码的机器模式（machine mode），以及为Linux，FreeBSD 和Windows 等操作系统提供支持的监管者模式（supervisor mode）。</p><p>图10.1是RISC-V 特权指令的图形表示，图10.2列出了这些指令的操作码。显然，特权架构添加的指令非常少。作为替代，几个新的控制状态寄存器（CSR）显示了附加的功能。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.1.png"></p><h2 id="10-2-简单嵌入式系统的机器模式"><a href="#10-2-简单嵌入式系统的机器模式" class="headerlink" title="10.2 简单嵌入式系统的机器模式"></a>10.2 简单嵌入式系统的机器模式</h2><p>机器模式（缩写为M模式， M-mode）是 RISC-V中（hart hardware thread，硬件线程）可以执行的最高权限模式。程）可以执行的最高权限模式。在M模式下运行的hart对内存，I&#x2F;O和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准RISC-V处理器都必须实现的权限模式。实际上简单的 RISC-V微控制器仅支持 M模式。</p><p>机器模式最重要的特性是拦截和处理异常的能力。RISC-V将异常分为两类。一类是同步异常。另一类是中断，它是与指令流异步的外部事件，比如鼠标的单击。</p><p>在 M模式运行期间可能发生的同步异常有五种：</p><ul><li><p>访问错误异常：当物理内存的地址不支持访问类型时发生（例如尝试写入 ROM）。</p></li><li><p>断点异常：在执行 ebreak指令，或者地址或数据与调试触发器匹配时发生。</p></li><li><p>环境调用异常：在执行 ecall指令时发生。</p></li><li><p>非法指令异常：在译码阶段发现无效操作码时发生。</p></li><li><p>非对齐地址异常：在有效地址不能被访问大小整除时发生，例如地址为0x12的amoadd.w。</p></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.3.png"></p><p>有三种标准的中断源：软件、时钟和外部来源。软件中断通过向内存映射寄存器中存数来触发。</p><h2 id="10-3-机器模式下的异常处理"><a href="#10-3-机器模式下的异常处理" class="headerlink" title="10.3 机器模式下的异常处理"></a>10.3 机器模式下的异常处理</h2><p>八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：</p><ul><li>mtvec (Machine Trap Vector) 它保存发生异常时处理器需要跳转到的地址。</li><li>mepc (Machine Exception PC) 它指向发生异常的指令。</li><li>mcause (Machine Exception Cause) 它指示发生异常的种类。</li><li>mie (Machine Interrupt Enable) 它指出处理器目前能处理和必须忽略的中断。</li><li>mip (Machine Interrupt Pending) 它列出目前正准备处理的中断。</li><li>mtval (Machine Trap Value) 它保存了陷入 trap 的附加信息：地址例外中出错的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0。</li><li>mscratch (Machine Scratch) 它暂时存放一个字大小的数据。</li><li>mstatus (Machine Status) 它保存全局中断使能，以及许多其他的状态，如图10.4所示。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.4.png"></p><p>处理器在M模式下运行时，只有在全局中断使能位mstatus.MIE置1时才会产生中断。此外，每个中断在控制状态寄存器mie中都有自己的使能位。这些位在mie中的位置对应于图10.3中的中断代码。例如，mie[7]对应于M模式中的时钟中断。控制状态寄存器mip具有相同的布局，并且它指示当前待处理的中断。。将所有三个控制状态寄存器合在一起考虑，如果 mstatus.MIE &#x3D; 1，mie[7] &#x3D; 1，且 mip[7] &#x3D; 1，则可以处理机器的时钟中断。</p><p>当一个hart发生异常时，硬件自动经历如下的状态转换：</p><div class="note note-info">            <p>hart是硬件线程 (hardware thread) 的缩略形式 。我们用该术语将它们与大多数程序员熟悉的软件线程区分开来。软件线程在 harts上进行分时复用。大多数处理器核都只有一个hart。</p>          </div><ul><li><p>异常指令的PC被保存在mepc中，PC被设置为 mtvec。（对于同步异常， mepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）</p></li><li><p>根据异常来源设置 mcause（如图 10.3所示），并将 mtval设置为出错的地址或者其它适用于特定异常的信息字。</p></li><li><p>把控制状态寄存器 mstatus中的 MIE位置零以禁用中断，并把先前的 MIE值保留到 MPIE中。</p></li><li><p>发生异常之前的权限模式保留在mstatus的MPP域中，再把权限模式更改为M。图 10.5显示了MPP域的编码（如果处理器仅实现M模式，则有效地跳过这个步骤）。</p></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.5.png" alt="img"></p><p>为避免覆盖整数寄存器中的内容，中断处理程序先在最开始用mscratch和整数寄存器（例如 a0）中的值交换。通常，软件会让 mscratch包含指向附加临时内存空间的指针，处理程序用该指针来保存其主体中将会用到的整数寄存器。在主体执行之后，中断程序会恢复它保存到内存中的寄存器，然后再次使用 mscratch和 a0交换，将两个寄存器恢复到它们在发生异常之前的值。最后，处理程序用 mret指令（ M模式特有的指令）返回。 mret将 PC设置为mepc，通过将mstatus的 MPIE域复制到MIE来恢复之前的中断使能设置，并将权限模式设置为 mstatus的MPP域中的值。这基本是前一段中描述的逆操作。</p><p>图10.6展示了遵循此模式的基本时钟中断处理程序的 RISC-V汇编代码。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.6.png"></p><p>除了上面介绍的mret指令之外，M模式还提供了另外一条指令：wfi (Wait For Interrupt)。 wfi通 知处理器目前没有任何有用的工作，所有它应该进入低功耗模式，直到任何使能有效的中断等待处理，即 mie&amp;mip≠0。</p><div class="note note-info">            <p>操作 CSR 的指令在 RISC-V 的 <code>Zicsr</code> 扩展模块中定义。包括伪指令在内，共有以下 7 种操作类型：</p><ol><li><code>csrr</code>，读取一个 CSR 的值到通用寄存器。如：<code>csrr t0, mstatus</code>，读取 <code>mstatus</code> 的值到 <code>t0</code> 中。</li><li><code>csrw</code>，把一个通用寄存器中的值写入 CSR 中。如：<code>csrw mstatus, t0</code>，将 <code>t0</code> 的值写入 <code>mstatus</code>。</li><li><code>csrs</code>，把 CSR 中指定的 bit 置 1。如：<code>csrsi mstatus, (1 &lt;&lt; 2)</code>，将 <code>mstatus</code> 的右起第 3 位置 1。</li><li><code>csrc</code>，把 CSR 中指定的 bit 置 0。如：<code>csrci mstatus, (1 &lt;&lt; 2)</code>，将 <code>mstatus</code> 的右起第 3 位置 0。</li><li><code>csrrw</code>，读取一个 CSR 的值到通用寄存器，然后把另一个值写入该 CSR。如：<code>csrrw t0, mstatus, t0</code>，将 <code>mstatus</code> 的值与 <code>t0</code> 的值交换。</li><li><code>csrrs</code>，读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 1。</li><li><code>csrrc</code>，读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 0。</li></ol>          </div><h2 id="10-4-嵌入式系统中的用户模式和进程隔离"><a href="#10-4-嵌入式系统中的用户模式和进程隔离" class="headerlink" title="10.4 嵌入式系统中的用户模式和进程隔离"></a>10.4 嵌入式系统中的用户模式和进程隔离</h2><p>必须禁止不可信的代码执行特权指令（如 mret）和访问特权控制状态寄存器（如mstatus），因为这将允许程序控制系统。这样的限制很容易实现，只要加入一种额外的权限模式： 用户模式（U模式）。这种模式拒绝使用这些功能，并在尝试执行M模式指令或访问CSR的时候产生非法指令异常。其它时候，U模式和M模式的表现十分相似。通过将mstatus.MPP设置为U（如图 10.5所示，编码为 0），然后执行mret指令，软件可以从M模式进入U模式。如果在U模式下发生异常，则把控制移交给M模式。</p><p>这些不可信的代码还必须被限制只能访问自己那部分内存。实现了M和U模式的处理器具有一个叫做<strong>物理内存保护</strong> （PMP Physical Memory Protection）的功能，允许M模式指定U模式可以访问的内存地址。PMP包括几个地址寄存器（通常为8到16个）和相应的配置寄存器。这些配置寄存器可以授予或拒绝读、写和执行权限。当处于U模式的处理器尝试取指或执行load或 store操作时，将地址和所有的PMP地址寄存器比较。</p><p>图 10.7显示了PMP地址寄存器和配置寄存器的布局。两者都是CSR。地址寄存器右移两位，因为PMP以四字节为单位。配置寄存器密集地填充在CSR中以加速上下文切换，如图10.8所示。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.7.png"></p><h2 id="10-5-现代操作系统的监管者模式"><a href="#10-5-现代操作系统的监管者模式" class="headerlink" title="10.5 现代操作系统的监管者模式"></a>10.5 现代操作系统的监管者模式</h2><p>更复杂的 RISC-V处理器用和几乎所有通用架构相同的方式处理这些问题：使用基于页面的虚拟内存。这个功能构成了监管者模式（S模式）的核心，这是一种可选的权限模式，旨在支持现代类Unix操作系统，如Linux。S模式比 U模式权限更高，但比M模式低。与U模式一样，S模式下运行的软件不能使用M模式的CSR和指令，并且受到PMP的限制。</p><p>mideleg（Machine Interrupt Delegation），机器中断委托 CSR控制将哪些中断委托给S模式。与mip和mie一样，mideleg中的每个位对应于图10.3中相同的异常。例如，mideleg[5]对应于S模式的时钟中断，如果把它置位，S模式的时钟中断将会移交S模式的异常处理程序，而不是M模式的异常处理程序。</p><p>委托给S模式的任何中断都可以被S模式的软件屏蔽。sie (Supervisor Interrupt enable) 和sip (Superivisor Interrupt pending) CSR是S模式的控制状态寄存器。他们是mie和mip的子集。它们有着和M模式下相同的布局，但在sie和sip中只有与由mideleg委托的中断对应的位才能读写。那些没有被委派的中断对应的位始终为零。</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第三、四章 RISC-V汇编语言，乘法和除法指令</title>
    <link href="/2023/01/06/RISC-V%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0/"/>
    <url>/2023/01/06/RISC-V%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-RISC-V汇编语言"><a href="#第三章-RISC-V汇编语言" class="headerlink" title="第三章 RISC-V汇编语言"></a>第三章 RISC-V汇编语言</h1><h2 id="3-2-函数调用规范"><a href="#3-2-函数调用规范" class="headerlink" title="3.2 函数调用规范"></a>3.2 函数调用规范</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.2.png" alt="图3.2"></p><h2 id="3-3-汇编器"><a href="#3-3-汇编器" class="headerlink" title="3.3 汇编器"></a>3.3 汇编器</h2><p>这类指令在巧妙配置常规指令的基础上实现，称为<strong>伪指令</strong>。图 3.3和 3.4列出了 RISC-V伪指令。</p><p>汇编程序的开头是一些汇编指示符，它们是汇编器的命令。图 3.9是RISC-V的汇编指示符。其中图 3.6中用到的指示符有：</p><ul><li>.text：进入代码段。</li><li>.align 2：后续代码按2^2字节对齐。</li><li>.globl main：声明全局符号 “main”</li><li>.section .rodata：进入只读数据段</li><li>.balign 4：数据段按4字节对齐</li><li>.string “Hello, %s!\n”: 创建空字符结尾的字符串</li><li>.string “world”: 创建空字符结尾的字符串</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.3.png" alt="图3.3"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.4.png" alt="图3.4"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.6.png" alt="图3.6"></p><h2 id="3-4-链接器"><a href="#3-4-链接器" class="headerlink" title="3.4 链接器"></a>3.4 链接器</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/3.9.png" alt="图3.9"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/3.10.png" alt="图3.10"></p><h2 id="3-5-静态链接和动态链接"><a href="#3-5-静态链接和动态链接" class="headerlink" title="3.5 静态链接和动态链接"></a>3.5 静态链接和动态链接</h2><p>上一节对 静态链接进行了说明，在程序运行前所有的库都进行了链接和加载。如果这样的库很大，链接一个库到多个程序中会十分占用内存。另外，链接时库是绑定的，即使它们后来的更新修复了 bug，强制的静态链接的代码仍然会使用旧的、有bug的版本。</p><p>为了解决这两个问题，现在的许多系统使用动态链接，外部的函数在第一次被调用时才会加载和链接。后续所有调用都使用快速链接，因此只会产生一次动态开销。每次程序开始运行，它都会按照需要链接最新版本的库函数。另外，如果多个程序使用了同一个动态链接库，库代码在内存中只会加载一次。</p><p>编译器产生的代码和静态链接的代码很相似。其不同之处在于，跳转的目标不是实际的函数，而是一个只有三条指令的存根函数（ stub function）。存根函数会从内存中的一个表中加载实际的函数的地址并跳转。不过，在第一次调用时，表中还没有实际的函数的地址，只有一个动态链接的过程的地址。当这个动态链接过程被调用时，动态链接器通过符号表找到实际要调用的函数，复制到内存中，更新记录实际的函数地址的表。后续的每次调用的开销就是存根函数的三条指令的开销。</p><h1 id="第四章-乘法和除法指令"><a href="#第四章-乘法和除法指令" class="headerlink" title="第四章 乘法和除法指令"></a>第四章 乘法和除法指令</h1><p>RV32M向RV32I中添加了整数乘法和除法指令。图4.1是RV32M扩展指令集的图形表示，图4.2列出了它们的操作码。</p><p>RV32M具有有符号和无符号整数的除法指令：divide(div)和divide unsigned(divu)，它们将商放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV32M提供remainder(rem)和remainder unsigned(remu)，它们在目标寄存器写入余数，而不是商。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.1.png" alt="图4.1"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.2.png" alt="图4.2"></p><p>将两个32位数相乘得到的是64位的乘积。为了正确地得到一个有符号或无符号的64位积，RISC-V中带有四个乘<br>法指令。要得到整数要得到整数32位乘积（ 64位中的低 32位）就用 mul指令。要得到高32位，如果操作数都是有符号数，就用mulh指令；如果操作数都是无符号数，就用mulhu指令。指令；如果一个有符号一个无符号，可以用mulhsu指令。在一条指令中完成把64位积写入两个 32位寄存器的操作会使硬件设计变得复杂，所以RV32M需要两条乘法指令才能得到一个完整的64位积。</p><p>对许多微处理器来说，整数除法是相对较慢的操作。如前述，除数为2的幂次的无符号除法可以用右移来代替。事实证明，通过乘以近似倒数再修正积的高32位的方法，可以优化除数为其它数的除法。例如，图 4.3显示了 3为除数的无符号除法的代码。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.3.png" alt="图4.3"></p><div class="note note-danger">            <p>lui t0, 0xaaaab 为什么t0&#x3D;0xaaaaaaab而不是0xaaaab000</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第二章 RV32I基础整数指令集</title>
    <link href="/2023/01/06/RISC-V%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/01/06/RISC-V%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2-模块化与增量型-ISA"><a href="#1-2-模块化与增量型-ISA" class="headerlink" title="1.2 模块化与增量型 ISA"></a>1.2 模块化与增量型 ISA</h2><p>​和几乎所有以往的 ISA不同，RISC-V是模块化的。它的核心是一个名为RV32I的基础 ISA，运行一个完整的软件栈。RV32I是固定的，永远不会改变。模块化来源于可选的标准扩展，根据应用程序的需要，硬件可以包含或不包含这些扩展。可以生成当前硬件条件下的最佳代码。惯例是把代表扩展的字母附加到指令集名称之后作为指示。例如，RV32IMFD将乘法（ RV32M），单精度浮点（RV32F）和双精度浮点（RV32D）的扩展添加到了基础指令集 RV32I）中。</p><h2 id="2-2-RV32I-指令格式"><a href="#2-2-RV32I-指令格式" class="headerlink" title="2.2 RV32I 指令格式"></a>2.2 RV32I 指令格式</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RV32I%E6%8C%87%E4%BB%A4%E5%9B%BE%E7%A4%BA.png" alt="图2.1: RV32指令图示"></p><p>​用于寄存器-寄存器操作的R类型指令，用于短立即数和访存load操作的I型指令，用于访存store操作的S型指令，用于条件跳转操作的B类型指令，用于长立即数的U型指令和用于无条件跳转的J型指令。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RISC%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="图2.2"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230131113244.png" alt="图2.3"></p><h2 id="2-3-RV32I-寄存器"><a href="#2-3-RV32I-寄存器" class="headerlink" title="2.3 RV32I 寄存器"></a>2.3 RV32I 寄存器</h2><p>​RV32I有31寄存器加上一个值恒为0的x0寄存器。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RV32I%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="图2.4"></p><h2 id="2-4-RV32I-整数计算"><a href="#2-4-RV32I-整数计算" class="headerlink" title="2.4 RV32I 整数计算"></a>2.4 RV32I 整数计算</h2><p>​简单的算术指令（add, sub）、逻辑指令（and, or, xor），以及图2.1中的移位指令（sll, srl, sra）和其他ISA差不多。他们从寄存器读取两个32位的值，并将32位结果写入目标寄存器。</p><p>​程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I提供一个当小于时置位的指令（slt）。</p><p>​图2.1剩下的两条整数计算指令主要用于构造大的常量数值和链接。加载立即数到高位（lui）将20位常量加载到寄存器的高20位。接着便可以使用标准的立即指令来创建32位常量。</p><p><strong>有什么不同之处？</strong></p><ul><li>RISC-V中没有字节或半字宽度的整数计算操作。操作始终是以完整的寄存器宽度。</li><li>RV32I也不包含乘法和除法，它们包含在可选的RV32M扩展中。</li></ul><h2 id="2-5-RV32I-的Load-和-Store"><a href="#2-5-RV32I-的Load-和-Store" class="headerlink" title="2.5 RV32I 的Load 和 Store"></a>2.5 RV32I 的Load 和 Store</h2><p>​除了提供32位字（lw，sw）的加载和存储外，图2.1中说明，RV32I 支持加载有符号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）。有符号字节和半字符号扩展为32位再写入目的寄存器。即使是自然数据类型更窄，低位宽数据也是被扩展后再处理，这使得后续的整数计算指令能正确处理所有的32位。在文本和无符号整数中常用的无符号字节和半字，在写入目标寄存器之前都被无符号扩展到32位。</p><h2 id="RV32I-条件分支"><a href="#RV32I-条件分支" class="headerlink" title="RV32I 条件分支"></a>RV32I 条件分支</h2><p>​相等（beq），不相等 （bne），大于等于（bge），或小于（blt）。最后两种比较有符号比较，RV32I也提供相应的无符号版本比较的：bgeu和bltu。<strong>分支指令的寻址方式是12位的立即数乘以2，符号扩展它，然后将得到值加到PC上作为分支的跳转地址。</strong><span class="label label-danger">这句话没理解</span></p><div class="note note-info">            <p><strong>补充说明：获取PC</strong></p><p>当前的PC可以通过将auipc的U立即数字段设置为0来获得。</p>          </div><h2 id="2-7-RV32I无条件跳转"><a href="#2-7-RV32I无条件跳转" class="headerlink" title="2.7 RV32I无条件跳转"></a>2.7 RV32I无条件跳转</h2><p>​图2.1中的跳转并链接指令（jal）具有双重功能。若将下一条指令PC + 4的地址保存到目标寄存器中，通常是返回地址寄存器ra（见图2.4），便可以用它来实现过程调用。如果<strong>使用零寄存器（x0）替换ra作为目标寄存器</strong>，则可以实现无条件跳转，因为x0不能更改。像分支一样，jal将其20位分支地址乘以2，进行符号扩展后再添加到PC上，便得到了跳转地址。</p><div class="note note-info">            <p><code>jal x1, X</code> means jump to X, and save the return address which is normally PC+4 to the x1.</p><p><code>jal x0 0(x1)</code>  use indirect address (<code>x1</code>) plus a constant of 12bits (0 in your example). set <code>x0</code> as return address register because you «don’t care».</p>          </div><h2 id="2-8-RV32I-杂项"><a href="#2-8-RV32I-杂项" class="headerlink" title="2.8 RV32I 杂项"></a>2.8 RV32I 杂项</h2><p>​图2.1中的控制状态寄存器指令 (csrrc、csrrs、csrrw、csrrci、csrrsi、csrrwi)，使我们可以轻松地访问一些程序性能计数器。对于这些64位计数器, 我们一次可以读取32位。这些计数器包括了系统时间, 时钟周期以及执行的指令数目。</p><p>​在RISC-V指令集中，<strong>ecall</strong>指令用于向运行时环境发出请求，例如系统调用。调试器使用<strong>ebreak</strong>指令将控制转移到调试环境。</p><p>​<strong>fence</strong>指令对外部可见的访存请求，如设备I &#x2F; O和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。fence.i指令同步指令和数据流。在执行fence.i指令之前，对于同一个硬件线程，RISC-V不保证用存储指令写到内存指令区的数据可以被取指令取到。</p><h2 id="2-10-结束语"><a href="#2-10-结束语" class="headerlink" title="2.10 结束语"></a>2.10 结束语</h2><ul><li>32位字节可寻址的地址空间</li><li>所有指令均为32位长</li><li>31个寄存器，全部32位宽，寄存器0硬连线为零</li><li>所有操作都在寄存器之间（没有寄存器到内存的操作）</li><li>加载&#x2F;存储字加上有符号和无符号加载&#x2F;存储字节和半字</li><li>所有算术，逻辑和移位指令都有立即数版本的指令</li><li>立即数总是符号扩展</li><li>仅提供一种数据寻址模式（寄存器+立即数）和PC相对分支</li><li>无乘法或除法指令</li><li>一个指令，用于将大立即数加载到寄存器的高位，这样加载32位常量到寄存器只需要两条指令</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.riscvbook.com/greencard-20181213.pdf">RISC-V Green Card</a></p><p><a href="http://www.riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V-Reader-Chinese-v2p1.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown and theme Fluid syntax</title>
    <link href="/2023/01/05/Ref/Markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/05/Ref/Markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><p>Method 1:</p><div class="note note-success">            <p>Markdown</p>          </div><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">&#123;% note success %&#125;<br>success<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><p>Method 2:</p><p class="note note-info">html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-info&quot;</span>&gt;</span>info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Support various colors:</p><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><p><strong>inline tags</strong>:</p><span class="label label-danger">text</span> <span class="label label-warning">text</span><span class="label label-info">text</span> <span class="label label-success">text</span><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><blockquote><p>This is a blockquote with two paragraphs. This is first paragraph.</p><p> This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>red</li><li>green</li><li>blue</li></ul><h2 id="Task-list"><a href="#Task-list" class="headerlink" title="Task list"></a>Task list</h2><p>Method 1：</p><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>Method 2：</p><div>            <input type="checkbox" disabled >a task list item          </div><div>            <input type="checkbox" disabled checked="checked">a task list item          </div>            <input type="checkbox" disabled >a task list item          <p><a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">勾选框</a></p><h2 id="Code-block"><a href="#Code-block" class="headerlink" title="Code block"></a>Code block</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;redcarpet&#x27;</span><br>markdown = <span class="hljs-title class_">Redcarpet</span>.new(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>puts markdown.to_html<br></code></pre></td></tr></table></figure><p>inline code:<br><code>int a = 123</code></p><h2 id="Math-block"><a href="#Math-block" class="headerlink" title="Math block"></a>Math block</h2><p class="note note-warning">需要在front-matter中指定math：true</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;<br>\begin{bmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{bmatrix}<br>$$</p><p class="note note-danger">矩阵没法换行，有bug，以后换个LaTeX引擎</p><p>Inline math:<br>$\lim_{x \to \infty} \exp(-x) &#x3D; 0$</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是对应的脚注">[1]</span></a></sup></p><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><hr><h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><p class="note note-warning">需要在front-matter中指定mermaid：true</p><pre><code class=" mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>This is <a href="http://www.baidu.com/" title="Baidu">Baidu</a> inline link.</p><h3 id="Internal-Links"><a href="#Internal-Links" class="headerlink" title="Internal Links"></a>Internal Links</h3><p><a href="#Tags">Internal link</a></p><h3 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links"></a>Reference Links</h3><p>看起来和Links的区别就是可以在文章其他地方定义链接</p><p>This is <a href="http://www.baidu.com/" title="Optional Title Here">Baidu</a> reference-style link.</p><h2 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h2><p>直接放网址的方式：</p><p><a href="https://yc-xiang.github.io/">https://yc-xiang.github.io/</a></p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><div align="center"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png" width="50%"></div><p><strong>Method 1</strong>: html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Method 2</strong>: Markdown</p><p>不能改格式大小<br><img src="/img/default.png" alt="图片标题"></p><p><strong>Method 3</strong>: Tags 插件</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div></div></div><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><p><del>Mistaken text</del> <u>underline</u><br><strong>Bold</strong> <em>italic</em></p><!-- This is some comments --><h2 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h2><p>:smile:<br>:dog:</p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><!-- This is some comments --><p>注释：<code>&lt;!-- This is some comments --&gt;</code></p><p>空行：<code>&lt;br /&gt;</code></p><h2 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h2><ul><li>表格：<code>ctrl+t</code></li><li>选中一整行：<code>ctrl+l</code></li><li>选中单词：<code>ctrl+d</code></li><li>插入图片：<code>ctrl+shift+i</code></li><li>插入链接：<code>ctrl + k</code></li><li>代码行: ctrl + shift + `</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://hexo.fluid-dev.com/docs/guide/">Hexo Fluid 用户手册</a></p><br /><br /><br /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令</title>
    <link href="/2023/01/04/Git/"/>
    <url>/2023/01/04/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h1 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git push [远程主机名][本地分支名]:[远程分支名]</span><br>$ git push origin HEAD:master<br><span class="hljs-comment"># HEAD是当前指向的分支,可以用git show HEAD 查看</span><br>$ git show HEAD<br>$ git branch -a<br><span class="hljs-comment"># 需要code view 时要加/refs/for</span><br>$ git push origin HEAD:refs/for/master<br><br><span class="hljs-comment"># 不加远程分支名</span><br>$ git push origin dev<br><span class="hljs-comment"># 相当于,如果远程分支不存在则会自动创建, 并创建联系</span><br>$ git push origin dev:dev<br>$ git branch --set-upstream-to=origin/dev<br><span class="hljs-comment"># 删除远程分支，直接推送空分支到远程分支</span><br>$ git push origin :dev<br></code></pre></td></tr></table></figure><h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看unstaged的改动(还没git add)</span><br>$ git diff<br><span class="hljs-comment"># 查看staged的改动(git add过的)</span><br>$ git diff --staged<br><span class="hljs-comment"># 显示出branch1和branch2中差异的部分</span><br>$ git diff branch1 branch2 --<span class="hljs-built_in">stat</span><br><span class="hljs-comment"># 显示指定文件的详细差异</span><br>$ git diff branch1 branch2 具体文件路径<br><span class="hljs-comment"># 显示出所有有差异的文件的详细差异</span><br>$ git diff branch1 branch2<br><span class="hljs-comment"># 显示本地master分支与远程master分支的区别</span><br>$ git diff master origin/master<br><span class="hljs-comment"># 比较两个commit</span><br>git diff commit id1 commit id2<br></code></pre></td></tr></table></figure><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看前两个commit的修改</span><br>$ git <span class="hljs-built_in">log</span> -p -2<br><span class="hljs-comment"># 查看改动了哪些文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><span class="hljs-comment"># 每个commit一行展示</span><br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<br><span class="hljs-comment"># 展示合并历史</span><br>$ git <span class="hljs-built_in">log</span> --graph<br><span class="hljs-comment"># 从一定时间开始的commit</span><br>$ git <span class="hljs-built_in">log</span> --since=2.weeks<br>$ git <span class="hljs-built_in">log</span> --since=2008-01-15<br>$ git <span class="hljs-built_in">log</span> --since=2 years 1 day 3 minutes ago<br><span class="hljs-comment"># 查看哪些commit修改了function_name</span><br>$ git <span class="hljs-built_in">log</span> -S function_name<br><span class="hljs-comment"># 查看某个文件的commit</span><br>$ git <span class="hljs-built_in">log</span> -- path/to/file<br></code></pre></td></tr></table></figure><p>You can also filter the list to commits that match some search criteria. The <code>--author</code> option allows<br>you to filter on a specific author, and the <code>--grep</code> option lets you search for keywords in the commit<br>messages.<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230116143526.png"></p><h1 id="git-rebase-git-merge"><a href="#git-rebase-git-merge" class="headerlink" title="git rebase, git merge"></a>git rebase, git merge</h1><p>git merge：在dev分支git merge main，&#x2F;&#x2F; 将main最新的commit拉到dev，有合并记录</p><p>git rebase：在dev分支git rebase main &#x2F;&#x2F;修改dev分支，将main最新的commit拉到dev，将dev最新的commit 接到main后面</p><p>e.g 在本地一个分支上有了C5，C6两个自己的commit，但此时远程master分支上别人又合并了两个C3,C4分支。如果用git pull（git fetch + git merge）会有一个新的merge commit。此时需要git rebase 将c5,c6接到最新的master代码(c4)上。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git2.png"></p><h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>git branch -f dev HEAD^  &#x2F;&#x2F;让dev分支指向HEAD^</p><p>本地撤销当前提交：git reset HEAD^</p><p>远程撤销当前提交：git revert HEAD</p><p>git remote show origin：查看远程信息</p><p>git branch –set-upstream-to&#x3D;origin&#x2F;develop（远程分支） develop：关联远程分支</p><p>那么如何查看已经配置分支关联信息呢，通过下述三条命令均可：</p><ol><li>git branch -vv</li><li>git remote show origin</li><li>cat .git&#x2F;config</li></ol><p>在一个分支上修改，突然要切到另一个分支：</p><ol><li>把现在的修改 git commit</li><li>git stash 暂存起来，注意这个stash 也会带到另一个分支。注意git stash pop和apply的区别，apply不会将栈弹出</li></ol><h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>git stash save “add style to our site” 添加stash信息</p><p>git stash clear :注意这是清空你所有的内容</p><p>git stash drop stash@{0} 这是删除第一个队列</p><p>git stash apply 不会删除内容</p><p>git stash pop 删除内容</p><p>git stash 不能stash untracked的文件，需要先git add，或者git stash -u</p><p>查看某个stash的具体内容：git stash show -p stash@{1}</p><h1 id="git-放弃修改-放弃增加文件操作"><a href="#git-放弃修改-放弃增加文件操作" class="headerlink" title="git 放弃修改, 放弃增加文件操作"></a>git 放弃修改, 放弃增加文件操作</h1><p>1.本地修改了一些文件 (并没有使用 git add 到暂存区)，想放弃修改:</p><ul><li>单个文件: <code>git checkout -- filename</code></li><li>所有文件&#x2F;文件夹: <code>git checkout .</code></li></ul><p>2.本地新增了一些文件 (并没有 git add 到暂存区)，想放弃修改:</p><ul><li>单个文件&#x2F;文件夹: <code>rm  -rf filename</code></li><li>所有文件: <code>git clean -nxfd</code></li></ul><blockquote><p>-f 删除untracked files <br/><br>-d 连untracked 的目录一起删掉 <br/><br>-x 连 gitignore 的untrack 文件&#x2F;目录也一起删掉（慎用,一般这个是用来删掉编译出来的.o之类的文件用的）<br/><br>-n 先看看会删掉哪些文件，防止重要文件被误删</p></blockquote><p>3.本地修改&#x2F;新增了一些文件，已经 git add 到暂存区，想放弃修改:</p><ul><li>单个文件&#x2F;文件夹: <code>git reset HEAD filename</code></li><li>所有文件&#x2F;文件夹: <code>git reset HEAD .</code></li></ul><p>4.本地通过 git add 和 git commit 后，想要撤销此次 commit：</p><ul><li><p>撤销 commit, 同时保留该 commit 修改：<code>git reset commit_id</code> (撤销之后，你所做的已经 commit 的修改还在工作区)</p></li><li><p>撤销 commit, 同时本地删除该 commit 修改：<code>git reset --hard commit_id</code> (撤销之后，你所做的已经 commit 的修改将会清除，仍在工作区&#x2F;暂存区的代码也将会清除)</p></li></ul><blockquote><p>这里的commit id可以通过git log查看选取前6位，commit_id是想要回到的节点</p></blockquote><h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><blockquote><p>不要通过rebase对任何已经提交到公共仓库中的commit进行修改（你自己一个人玩的分支除外）</p></blockquote><h2 id="合并多个commit为一个完整commit"><a href="#合并多个commit为一个完整commit" class="headerlink" title="合并多个commit为一个完整commit"></a>合并多个commit为一个完整commit</h2><p><a href="https://www.jianshu.com/p/4a8f4af4e803">https://www.jianshu.com/p/4a8f4af4e803</a></p><p><code>git rebase -i HEAD~3</code> 修改HEAD往后三个分支（包括HEAD)</p><p>或者<code>git rebase -i 某个commit</code> 修改某个commit前的所有提交</p><p>然后<code>git push -f</code>可以修改远程的commit记录</p><h2 id="将某一段commit粘贴到另一个分支上"><a href="#将某一段commit粘贴到另一个分支上" class="headerlink" title="将某一段commit粘贴到另一个分支上"></a>将某一段commit粘贴到另一个分支上</h2><h1 id="git-patch"><a href="#git-patch" class="headerlink" title="git patch"></a>git patch</h1><h2 id="生成patch"><a href="#生成patch" class="headerlink" title="生成patch"></a>生成patch</h2><ol><li>git diff</li><li>git format-patch</li></ol><p>生成某个提交的补丁:</p><ul><li>git diff &gt; xxx.patch</li><li>生成单个commit的patch: git format-patch &lt;commit_id&gt; -1</li></ul><h2 id="git-apply"><a href="#git-apply" class="headerlink" title="git apply"></a>git apply</h2><p>git apply是另外一种打patch的命令，其与git am的区别是：git apply并不会将<strong>commit message</strong>等打上去，打完patch后需要重新<strong>git add和git commit</strong>。</p><p>2.检查补丁是否有冲突</p><p>git apply –check xxx.patch</p><p>3.无冲突打补丁</p><p>git apply xxx.patch</p><h2 id="git-am"><a href="#git-am" class="headerlink" title="git am"></a>git am</h2><p>git am会直接将patch的<strong>所有信息</strong>打上去，而且不用重新git add和git commit，author也是<strong>patch的author</strong>而不是打patch的人。</p><p>git am 之前可以git apply –check一下</p><p>无冲突：git am xxx.patch</p><p>有冲突：git am –reject xxx.patch</p><p>此时会在有冲突的文件相同文件夹生产一个以原来文件名加后缀为.rej的新文件，里面会告知哪些地方冲突了，</p><p>参考这些冲突的地方修改原文件即可</p><p>修改完成后添加到缓冲区 git add xxx1.c xxx2.c ….</p><p>最后 git am –continue 即可完成打补丁。</p><p>git commit –amend -s 可以添加自己的signed-off</p><p><a href="https://blog.csdn.net/u013318019/article/details/114860407">https://blog.csdn.net/u013318019/article/details/114860407</a></p><h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><p><a href="https://www.runoob.com/git/git-tag.html">https://www.runoob.com/git/git-tag.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有标签</span><br>$ git tag<br><br><span class="hljs-comment"># 创建</span><br>$ git tag -a v1.0<br><br><span class="hljs-comment"># 删除</span><br>$ git tag -d v1.0<br><br><span class="hljs-comment">#查看</span><br>$ git show v1.0<br><br><span class="hljs-comment"># 切换</span><br>git checkout v1.0<br></code></pre></td></tr></table></figure><p>tag 需要单独上传<code>git push origin &lt;tagname&gt;</code> 和删除&#96;&#96;git push origin –delete <tagname>&#96;</p><h1 id="创建分支并与远程某分支关联："><a href="#创建分支并与远程某分支关联：" class="headerlink" title="创建分支并与远程某分支关联："></a>创建分支并与远程某分支关联：</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以先更新远程分支信息</span><br>git remote update origin --prune<br><br><span class="hljs-comment"># git checkout -b 本地新分支 远程分支。远程分支可以git branch -a查看</span><br>git checkout -b <span class="hljs-built_in">test</span> origin/test<br><br><span class="hljs-comment"># 查看本地分支与远程分支匹配</span><br>git branch -vv<br><br><span class="hljs-comment"># 用下面的操作两个分支会对不上，无法git push，因为test分支可能是从master分支新建过来的，git log都不对应，需要一个干净的分支</span><br>git chekcout -b <span class="hljs-built_in">test</span><br>git branch --set-upstream-to=origin/develop<br></code></pre></td></tr></table></figure><h1 id="Pro-Git"><a href="#Pro-Git" class="headerlink" title="Pro Git"></a>Pro Git</h1><h2 id="First-Time-Git-Setup"><a href="#First-Time-Git-Setup" class="headerlink" title="First-Time Git Setup"></a>First-Time Git Setup</h2><ol><li><code>[path]/etc/gitconfig</code> system全局配置。pass the option <code>--system</code> to <code>git config</code>。</li><li><code>~/.gitconfig</code> or <code>~/.config/git/config</code> user全局配置。<code>--global</code>。</li><li><code>config</code> file in the Git directory (that is, <code>.git/config</code>) 某个库的本地配置。<code>--local</code>。</li></ol><p>You can view all of your settings and where they are coming from using:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list --show-origin<br></code></pre></td></tr></table></figure><h2 id="Your-Identity"><a href="#Your-Identity" class="headerlink" title="Your Identity"></a>Your Identity</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span><br>$ git config --global user.email johndoe@example.com<br></code></pre></td></tr></table></figure><h2 id="Your-Editor"><a href="#Your-Editor" class="headerlink" title="Your Editor"></a>Your Editor</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor vim<br></code></pre></td></tr></table></figure><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><p>在repository中不小心上传了大文件或者隐私数据：<br><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</a></p><p><strong>git alias</strong>: <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias">https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias</a></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://learngitbranching.js.org/">An online game to learn Git</a><br><a href="https://git-scm.com/book/en/v2">Pro Git</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养学习笔记</title>
    <link href="/2022/01/27/legacy/2022-1-27-%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <url>/2022/01/27/legacy/2022-1-27-%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="第二部分-静态链接"><a href="#第二部分-静态链接" class="headerlink" title="第二部分 静态链接"></a>第二部分 静态链接</h1><h2 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h2><h3 id="2-1-1-预编译："><a href="#2-1-1-预编译：" class="headerlink" title="2.1.1 预编译："></a>2.1.1 <strong>预编译：</strong></h3><p>$gcc –E hello.c –o hello.i</p><ul><li>展开宏定义</li><li>处理预编译指令 “#if”、“#ifdef”等等</li><li>处理 “#include ”预编译指令</li><li>删除注释</li><li>添加行号和文件名标识</li><li>保留所有的 #pragma 编译器指令</li></ul><h3 id="2-1-2-编译"><a href="#2-1-2-编译" class="headerlink" title="2.1.2 编译"></a>2.1.2 编译</h3><p>编译：$gcc –S hello.i –o hello.s</p><p>预编译+编译：$gcc –S hello.c –o hello.s</p><p>汇编：$gcc –c hello.c –o hello.o</p><h2 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h2><h3 id="3-1-目标文件的格式"><a href="#3-1-目标文件的格式" class="headerlink" title="3.1 目标文件的格式"></a>3.1 目标文件的格式</h3><ul><li>可重定位文件 .o, .a</li><li>可执行文件</li><li>共享目标文件 .so</li><li>核心转储文件</li></ul><p><code>file</code> 命令可以查看文件格式</p><p>binutils的objdump工具查看obj内部的结构(隐藏的段不显示)：</p><p>objdump -h u-boot</p><p>readelf -S u-boot （把段表结构打印出来）</p><p>objdump -s -d u-boot</p><p>-s参数：将所有段内容以16进制方式打印出来</p><p>-d参数：将所有包含指令的段反汇编</p><p>size命令用来查看ELF文件的代码段、数据段、BSS段的长度</p><p>size u-boot</p><p>查看ELF文件头：</p><p>readelf -h u-boot</p><p>在全局变量或函数之前加上“__ attribute__((section(“name”))) ”属性就可以把相应的变量或函数放到以“ name ”作为段名的段中。</p><p><strong>attribute</strong>((section(“FOO”))) int global &#x3D; 42;<strong>attribute</strong>((section(“BAR”))) void foo()</p><h1 id="第四章-静态连接"><a href="#第四章-静态连接" class="headerlink" title="第四章 静态连接"></a>第四章 静态连接</h1><h2 id="4-2-符号解析和重定位"><a href="#4-2-符号解析和重定位" class="headerlink" title="4.2 符号解析和重定位"></a>4.2 符号解析和重定位</h2><h3 id="4-2-2-重定位表"><a href="#4-2-2-重定位表" class="headerlink" title="4.2.2 重定位表"></a>4.2.2 重定位表</h3><p>.text ⇒ .rel.text</p><p>.data ⇒ .rel.data</p><p>查看目标文件重定位表：objdump -r a.o</p><h3 id="4-2-4-指令修正方式"><a href="#4-2-4-指令修正方式" class="headerlink" title="4.2.4 指令修正方式"></a>4.2.4 指令修正方式</h3><ul><li>绝对寻址修正</li><li>相对寻址修正</li></ul><h2 id="4-3-COMMON块"><a href="#4-3-COMMON块" class="headerlink" title="4.3 COMMON块"></a>4.3 COMMON块</h2><p>把未初始化的全局变量标记为一个COMMON类型的变量。</p><p>链接完成后，在最终输出文件的BSS段为其分配空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员的自我修养</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux输入输出重定向</title>
    <link href="/2021/12/31/legacy/2021-12-31-linux%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2021/12/31/legacy/2021-12-31-linux%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>&amp;&gt;file  意思是把标准输出 和 标准错误输出 都重定向到文件file中</p><p>&#x2F;dev&#x2F;null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</p><ul><li>command &gt; filename 把标准输出重定向到一个新文件中</li><li>command &gt;&gt; filename 把标准输出重定向到一个文件中(追加)</li><li>command 1 &gt; fielname 把标准输出重定向到一个文件中(和 &gt; 一样的)</li><li>command &gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到一个文件中</li><li>command 2 &gt; filename 把标准错误重定向到一个文件中</li><li>command 2 &gt;&gt; filename 把标准输出重定向到一个文件中(追加)</li><li>command &gt;&gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到一个文件中(追加)</li><li>command &lt; filename &gt;filename2 把command命令以filename文件作为标准输入，以filename2文件作为标准输出</li><li>command &lt; filename 把command命令以filename文件作为标准输入</li><li>command &lt;&lt; delimiter 把从标准输入中读入，直至遇到delimiter分界符</li><li>command &lt;&amp;m 把文件描述符m作为标准输入</li><li>command &gt;&amp;m 把标准输出重定向到文件描述符m中</li><li>command &lt;&amp;- 把关闭标准输入</li></ul><p><a href="https://blog.csdn.net/alex_xhl/article/details/5719381">原文链接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac Homebrew和gem下载源修改</title>
    <link href="/2021/12/24/legacy/2021-12-24-Homebrew-gem/"/>
    <url>/2021/12/24/legacy/2021-12-24-Homebrew-gem/</url>
    
    <content type="html"><![CDATA[<p>mac环境</p><h1 id="Homebrew下载源修改"><a href="#Homebrew下载源修改" class="headerlink" title="Homebrew下载源修改:"></a>Homebrew下载源修改:</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">替换brew.git:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科大:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换homebrew-core.git:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科大:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换homebrew-bottles:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科大:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.zshrc</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">应用生效:</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew update</span><br></code></pre></td></tr></table></figure><h1 id="Gem下载源修改："><a href="#Gem下载源修改：" class="headerlink" title="Gem下载源修改："></a>Gem下载源修改：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移除gem默认源，改成ruby-china源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gem sources -r https://rubygems.org/ -a https://gems.ruby-china.com/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Gemfile和Bundle的项目，可以做下面修改，就不用修改Gemfile的<span class="hljs-built_in">source</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除Bundle的一个镜像源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bundle config --delete <span class="hljs-string">&#x27;mirror.https://rubygems.org&#x27;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
