<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Operating Systems Three Easy Pieces(OSTEP)</title>
    <link href="/2024/03/21/Book/24-03-21_OSTEP_ch3_11/"/>
    <url>/2024/03/21/Book/24-03-21_OSTEP_ch3_11/</url>
    
    <content type="html"><![CDATA[<p>这篇文章是阅读OSTEP Chapter3~11的笔记，主要讲的是Virtualization中Virtualize CPU的部分。</p><h1 id="Chapter-4-Process"><a href="#Chapter-4-Process" class="headerlink" title="Chapter 4 Process"></a>Chapter 4 Process</h1><h2 id="4-2-Process-API"><a href="#4-2-Process-API" class="headerlink" title="4.2 Process API"></a>4.2 Process API</h2><p>一般OS会提供以下的进程API来操作进程：</p><ul><li><strong>Create</strong>: 创建进程。</li><li><strong>Destory</strong>: 结束进程。</li><li><strong>Wait</strong>: Wait a process to stop running. 等待进程结束。</li><li><strong>Miscellaneous Control</strong>: Suspend/Resume… 休眠，唤醒等等。</li><li><strong>Status</strong>: 查看进程状态。</li></ul><h2 id="4-3-Process-Creation"><a href="#4-3-Process-Creation" class="headerlink" title="4.3 Process Creation"></a>4.3 Process Creation</h2><ol><li>首先OS将存储在disk or SSD的program程序加载进memory内存。<br>这边有两种方式，一种是在运行前把code和static data全部加载进内存。现代操作系统一般会使用第二种方式，<strong>懒加载</strong>，只加载即将使用的code和data。</li><li>分配栈。</li><li>分配堆。</li><li>分配三个文件描述符，标准输入0，标准输出1，错误2。</li></ol><h2 id="4-4-Process-Status"><a href="#4-4-Process-Status" class="headerlink" title="4.4 Process Status"></a>4.4 Process Status</h2><p>进程的状态有：</p><ul><li><strong>Running</strong>: 正在使用CPU执行指令。</li><li><strong>Ready</strong>: 进程就绪态。</li><li><strong>Blocked</strong>: 比如进程在和disk IO交互，这时会把CPU让出给其他进程使用，进入阻塞态。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240321160042.png"></p><h2 id="4-5-Data-Struct"><a href="#4-5-Data-Struct" class="headerlink" title="4.5 Data Struct"></a>4.5 Data Struct</h2><p>PCB, Process Control Block 用来描述进程的数据结构。</p><p>参考xv6中描述进程的数据结构：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span><br>  <span class="hljs-type">char</span> *mem; <span class="hljs-comment">// Start of process memory</span><br>  uint sz; <span class="hljs-comment">// Size of process memory</span><br>  <span class="hljs-type">char</span> *kstack; <span class="hljs-comment">// Bottom of kernel stack</span><br>  <span class="hljs-comment">// for this process</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span> <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">int</span> pid; <span class="hljs-comment">// Process ID</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-type">void</span> *chan; <span class="hljs-comment">// If !zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed; <span class="hljs-comment">// If !zero, has been killed</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span> <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span> <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span> <span class="hljs-comment">// Switch here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span> <span class="hljs-comment">// Trap frame for the current interrupt</span><br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="Chapter-5-Process-API"><a href="#Chapter-5-Process-API" class="headerlink" title="Chapter 5 Process API"></a>Chapter 5 Process API</h1><h2 id="5-1-fork-system-call"><a href="#5-1-fork-system-call" class="headerlink" title="5.1 fork() system call"></a>5.1 fork() system call</h2><p><code>pid_t fork(void)</code></p><p>fork系统调用用来创建进程。子进程返回0，父进程返回子进程PID。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>  <span class="hljs-type">int</span> rc = fork();<br>  <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// fork failed</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"fork failed\n"</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// child (new process)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// parent goes down this path (main)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent of %d (pid:%d)\n"</span>, rc, (<span class="hljs-type">int</span>) getpid());<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">prompt&gt; </span><span class="language-bash">./p1</span><br>hello (pid:29146)<br>parent of 29147 (pid:29146) # 这条和下面一条出现顺序随机<br>child (pid:29147)<br><span class="hljs-meta prompt_">prompt&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="5-2-wait-system-call"><a href="#5-2-wait-system-call" class="headerlink" title="5.2 wait() system call"></a>5.2 wait() system call</h2><p><code>pid_t wait(int *wstatus)</code></p><p>wait系统调用会block等待子进程结束。<code>wstatus</code>可以传入NULL，也可以传入一个指针，通过进一步其他的API来获取子进程状态。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>  <span class="hljs-type">int</span> rc = fork();<br>  <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// fork failed; exit</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"fork failed\n"</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) { <span class="hljs-comment">// child (new process)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// parent goes down this path</span><br>    <span class="hljs-type">int</span> rc_wait = wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent of %d (rc_wait:%d) (pid:%d)\n"</span>, rc, rc_wait, (<span class="hljs-type">int</span>) getpid());<br>  }<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">prompt&gt; ./p2<br>hello (pid:29266)<br>child (pid:29267) <span class="hljs-comment"># 这条和吓一条顺序是确定的</span><br>parent of 29267 (rc_wait:29267) (pid:29266)<br>prompt&gt;<br></code></pre></td></tr></tbody></table></figure><h2 id="5-3-exec-system-call"><a href="#5-3-exec-system-call" class="headerlink" title="5.3 exec() system call"></a>5.3 exec() system call</h2><p><code>exec()</code>系列系统调用，直接在当前进程加载另一个program, 运行另一个进程，不返回。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>  <span class="hljs-type">int</span> rc = fork();<br>  <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// fork failed; exit</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"fork failed\n"</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) { <span class="hljs-comment">// child (new process)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child (pid:%d)\n"</span>, (<span class="hljs-type">int</span>) getpid());<br>    <span class="hljs-type">char</span> *myargs[<span class="hljs-number">3</span>];<br>    myargs[<span class="hljs-number">0</span>] = strdup(<span class="hljs-string">"wc"</span>); <span class="hljs-comment">// program: "wc"</span><br>    myargs[<span class="hljs-number">1</span>] = strdup(<span class="hljs-string">"p3.c"</span>); <span class="hljs-comment">// arg: input file</span><br>    myargs[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// mark end of array</span><br>    execvp(myargs[<span class="hljs-number">0</span>], myargs); <span class="hljs-comment">// runs word count</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"this shouldn’t print out"</span>);<br>  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// parent goes down this path</span><br>    <span class="hljs-type">int</span> rc_wait = wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent of %d (rc_wait:%d) (pid:%d)\n"</span>, rc, rc_wait, (<span class="hljs-type">int</span>) getpid());<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">prompt&gt; ./p3<br>hello (pid:29383)<br>child (pid:29384)<br>29 107 1030 p3.c<br>parent of 29384 (rc_wait:29384) (pid:29383)<br>prompt&gt;<br></code></pre></td></tr></tbody></table></figure><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><code>kill()</code>, <code>signal()</code>, <code>pipe()</code></p><h1 id="Chapter-6-Limited-Direct-Execution"><a href="#Chapter-6-Limited-Direct-Execution" class="headerlink" title="Chapter 6 Limited Direct Execution"></a>Chapter 6 Limited Direct Execution</h1><h2 id="6-1-Problem-1-Restricted-Operations"><a href="#6-1-Problem-1-Restricted-Operations" class="headerlink" title="6.1 Problem#1 Restricted Operations"></a>6.1 Problem#1 Restricted Operations</h2><p>User space要与kernel space隔离，通过system call的方式来访问硬件。</p><p>OS启动，以及user程序system call与kernel交互流程：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240321175447.png"></p><h2 id="6-2-Problem-2-Switching-Between-Processes"><a href="#6-2-Problem-2-Switching-Between-Processes" class="headerlink" title="6.2 Problem#2 Switching Between Processes"></a>6.2 Problem#2 Switching Between Processes</h2><ul><li>Cooperative Approach：协作式，等process自己主动交出CPU控制权。</li><li>Non-cooperative Approach: 抢占式，OS通过timer interrupt，给每个process一定的时间片执行，到了timer的时间就要交出CPU控制权。</li></ul><p><strong>Context Switch</strong></p><p>进程A和进程B进行切换的上下文交换过程：</p><blockquote><p>注意每个进程都有自己的kernel stack。</p></blockquote><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322113305.png"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>CPU跑OS需要支持<strong>user mode</strong>和<strong>kernel mode</strong>。</li><li>user mode使用<strong>system call</strong> trap into kernel。</li><li>kernel启动过程中准备好了<strong>trap table</strong>。</li><li>OS完成system call后，通过<strong>return-from-trap</strong>指令返回user code。</li><li>kernel利用<strong>timer interrupt</strong>来防止一个用户进程一直占用CPU。</li><li>进程间交换需要<strong>context switch</strong>。</li></ol><h1 id="Chapter-7-Scheduling-Introduction"><a href="#Chapter-7-Scheduling-Introduction" class="headerlink" title="Chapter 7 Scheduling: Introduction"></a>Chapter 7 Scheduling: Introduction</h1><p>几个衡量性能的指标：</p><p>转换时间=完成时间-到达时间<br>$T_{turnaround}=T_{completion}-T_{arrival}$</p><p>响应时间=开始执行时间-到达时间<br>$T_{response}=T_{firstrun}-T_{arrival}$</p><h2 id="7-3-FIFO"><a href="#7-3-FIFO" class="headerlink" title="7.3 FIFO"></a>7.3 FIFO</h2><p>先进先出原则，如果进程一起到来，按先后顺序执行。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322170741.png"></p><p>存在的问题是，如果前面的进程运行时间长，平均的turnaround时间就会变得很长：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322170605.png"></p><h2 id="7-4-Shortest-Job-first-SJF"><a href="#7-4-Shortest-Job-first-SJF" class="headerlink" title="7.4 Shortest Job first(SJF)"></a>7.4 Shortest Job first(SJF)</h2><p>先执行时间短的进程。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322170759.png"></p><p>存在的问题是，如果几个进程不是同时到来，先执行到时间长的进程，仍然有和FIFO调度一样的问题：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322170536.png"></p><h2 id="7-5-Shortest-Time-to-Completion-First-STCF"><a href="#7-5-Shortest-Time-to-Completion-First-STCF" class="headerlink" title="7.5 Shortest Time-to-Completion First(STCF)"></a>7.5 Shortest Time-to-Completion First(STCF)</h2><p>在SJF调度上加入抢占式机制。当有新进程到来时，调度器会判断谁的执行时间更短，来执行时间更短的进程。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322170714.png"></p><h2 id="7-7-Round-Robin"><a href="#7-7-Round-Robin" class="headerlink" title="7.7 Round Robin"></a>7.7 Round Robin</h2><p>Response time比前面的调度算法都好。</p><p>每个进程执行一段时间后切换。要考虑context switch的消耗，选择合适的时间片。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322171956.png"></p><h2 id="7-8-Incorporating-I-x2F-O"><a href="#7-8-Incorporating-I-x2F-O" class="headerlink" title="7.8 Incorporating I/O"></a>7.8 Incorporating I/O</h2><p>执行IO的时候，调度别的进程。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240322174407.png"></p><h1 id="Chapter-8-Sheduling-The-Multi-Level-Feedback-Queue-MLFQ"><a href="#Chapter-8-Sheduling-The-Multi-Level-Feedback-Queue-MLFQ" class="headerlink" title="Chapter 8 Sheduling: The Multi-Level Feedback Queue(MLFQ)"></a>Chapter 8 Sheduling: The Multi-Level Feedback Queue(MLFQ)</h1><p>MLFQ算法会维护一系列<strong>Queues</strong>, 拥有不同的优先级。</p><ul><li><strong>Rule1</strong>: Priority(A)&gt;Priority(B), 运行进程A.</li><li><strong>Rule2</strong>: Priority(A)=Priority(B), A和B以RR(Round Robin)规则运行.</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240323151420.png"></p><ul><li><strong>Rule3</strong>: 一个进程刚到来时，属于最高优先级。</li><li><strong>Rule4a</strong>: 如果进程用完了自己的allotment, 会降低一个优先级。</li><li><strong>Rule4b</strong>: 如果进程在用完allotment前放弃了CPU(比如进行IO操作)，会停留在当前优先级，allotment重置。(Figure 8.3b)</li></ul><p>Examples:</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240323152425.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240323152443.png"></p><p><strong>目前为止MLFQ存在的问题</strong></p><ul><li>Starvation饥饿问题。如果有太多短时的进程，运行时间长的进程会拿不到CPU。</li><li>Game the scheduler欺骗调度器。一个恶意的用户程序，可以在每次即将用完allotment时，进行一次IO操作，这样又可以停留在最高优先级了。</li></ul><h2 id="Priority-boost"><a href="#Priority-boost" class="headerlink" title="Priority boost"></a>Priority boost</h2><p>为了解决饥饿问题，增加第五条规则：</p><ul><li><strong>Rule5</strong>: 经过固定时间S, 把所有进程的优先级都调到最高。</li></ul><p>这个时间S也称作voo-doo constants，比如把voo-doo constants设置为100ms:</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240323155652.png"></p><h2 id="Better-Accounting"><a href="#Better-Accounting" class="headerlink" title="Better Accounting"></a>Better Accounting</h2><p>为了解决Game the scheduler的问题，修改Rule 4a和4b，不再是计算单次使用CPU的alloment，而是：</p><ul><li><strong>Rule4</strong>: 当一个进程在某一优先级的总时间用完后，降低一个优先级。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240323161225.png"></p><h2 id="Tuning-MLFQ"><a href="#Tuning-MLFQ" class="headerlink" title="Tuning MLFQ"></a>Tuning MLFQ</h2><p>一些参数是可以调整的，Queue的数量，time slice，allotment，priority boost time。</p><p>一种可以优化的做法是越高优先级的队列，time slice越短。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240324095045.png"></p><h1 id="Chapter-9-Scheduling-Proportional-Share"><a href="#Chapter-9-Scheduling-Proportional-Share" class="headerlink" title="Chapter 9 Scheduling: Proportional Share"></a>Chapter 9 Scheduling: Proportional Share</h1><p>比例份额调度(proportinal-share)，也称公平份额调度(fair-share)。</p><h2 id="9-2-Lottery-Scheduling"><a href="#9-2-Lottery-Scheduling" class="headerlink" title="9.2 Lottery Scheduling"></a>9.2 Lottery Scheduling</h2><p>每个进程分配一个Ticket，生成一个位于0~sum_tickets随机数winner，如下图如果winner位于0~99，进程A执行; 100<del>149，进程B执行; 150</del>400，进程C执行。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240325214031.png"></p><p>实现代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// counter: used to track if we’ve found the winner yet</span><br><span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// winner: call some random number generator to</span><br><span class="hljs-comment">// get a value &gt;= 0 and &lt;= (totaltickets - 1)</span><br><span class="hljs-type">int</span> winner = getrandom(<span class="hljs-number">0</span>, totaltickets);<br><br><span class="hljs-comment">// current: use this to walk through the list of jobs</span><br><span class="hljs-type">node_t</span> *current = head;<br><span class="hljs-keyword">while</span> (current) {<br>counter = counter + current-&gt;tickets;<br><span class="hljs-keyword">if</span> (counter &gt; winner)<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// found the winner</span><br>current = current-&gt;next;<br>}<br><span class="hljs-comment">// ’current’ is the winner: schedule it...</span><br></code></pre></td></tr></tbody></table></figure><p>Lottery scheduling存在的问题有，如果job length很短的话会存在不公平的现象。还有一个是如何分配tickets。参考9.4和9.5章节。</p><h2 id="9-6-Stride-Scheduling"><a href="#9-6-Stride-Scheduling" class="headerlink" title="9.6 Stride Scheduling"></a>9.6 Stride Scheduling</h2><p>仍然给A,B,C分别分配tickets100,50,250，在Stride scheduling中需要一个总目标数，比如10000，用1000计算A,B,C的步长，10000/100=100, 10000/50=200, 10000/250=40。</p><p>Basic idea: at any given time, pick the process to run that has the lowest pass value so far; when you run a process, increment its pass counter by its stride.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">curr = remove_min(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// pick client with min pass</span><br>schedule(curr); <span class="hljs-comment">// run for quantum</span><br>curr-&gt;pass += curr-&gt;stride; <span class="hljs-comment">// update pass using stride</span><br>insert(<span class="hljs-built_in">queue</span>, curr); <span class="hljs-comment">// return curr to queue</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240325215738.png"></p><p>Pass Value相同时随机选择进程Run。</p><p>Stride Scheduling存在的问题有，如果新来一个进程，那么这个进程的pass value会是0，会持续运行该进程，占据CPU一段时间。</p><h2 id="9-7-The-Linux-Completely-Fair-Scheduler-CFS"><a href="#9-7-The-Linux-Completely-Fair-Scheduler-CFS" class="headerlink" title="9.7 The Linux Completely Fair Scheduler(CFS)"></a>9.7 The Linux Completely Fair Scheduler(CFS)</h2><p>所有竞争的进程公平地分配CPU使用。</p><p>每个进程运行会累计<strong>virtual runtime</strong>, CPU会选择vruntime最小的进程来run。</p><p>存在的问题有，如果CPU切换太快，context switch对系统的性能损耗太大。如果CPU切换太慢，进程间的公平性又会降低。</p><p>CFS算法为了解决上述问题，提供了一些控制参数：</p><ul><li><strong>sched_latency</strong>: context switch之前进程应该跑多久，典型值为48ms。如果此时有n个进程一起在running，sched_latency=48/n。如下图所示，一开始有4个进程一起跑，sched_latency比较短，后面只有两个进程在跑，sched_latency变长。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240326153422.png"></p><p>如果有太多进程一起在running，那么sched_latency就会被分的很小，为了解决这个问题，提出了第二个控制参数：</p><ul><li><strong>min_granularity</strong>: 典型值6ms。进程最短的运行时间，不能再被分割。</li></ul><h3 id="Weighting-Niceness"><a href="#Weighting-Niceness" class="headerlink" title="Weighting(Niceness)"></a>Weighting(Niceness)</h3><p>Unix系统可以通过修改<strong>nice</strong>值来调整进程权重，可选值为-20~+19。</p><p>根据权重再调整进程的time_slice。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240326164317.png"></p><p>n为总进程数，k为当前进程。weight：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240326164432.png"></p><p>vruntime计算也需要调整：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240326164849.png"></p><h3 id="Using-Red-Black-Trees"><a href="#Using-Red-Black-Trees" class="headerlink" title="Using Red-Black Trees"></a>Using Red-Black Trees</h3><p>进程用链表查找太慢了，CFS使用红黑树来管理正在running的进程。</p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_chapter4 traps</title>
    <link href="/2024/02/26/Project/xv6/xv6_chapter4/"/>
    <url>/2024/02/26/Project/xv6/xv6_chapter4/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h1><p>gdb调试shell write函数的syscall过程：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0xdec # 在0xde8地址设置断点<br>(gdb) c<br>(gdb) delete 1 # 删除断点<br>(gdb) print $pc<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 = (void (*)()) 0xdec</span><br>(gdb) info r<br>(gdb) x/3i 0xde8 # 打印0xdfe开始的三条指令<br>0xdfe: li a7,16<br>0xe00: ecall<br>0xe04: ret<br>(gdb) p/x $stvec<br><span class="hljs-meta prompt_">$</span><span class="language-bash">2 = 0x3ffffff000 <span class="hljs-comment"># user space virtual address顶部一个page，trampoline page对应kernel trap handler.</span></span><br>(gdb) stepi<br></code></pre></td></tr></tbody></table></figure><p class="这边gdb调试进不去kernel，ecall之后stepi直接到了ret">warning</p><h1 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h1><p>Traps：</p><ul><li>system call. 通过ecall进入kernel</li><li>exception. 除0，invalid virtual address.</li><li>interrupt. 进入kernel device driver.</li></ul><p>根据处理代码不同，可分为三种traps：</p><ul><li>traps from user space</li><li>traps from kernel space</li><li>timer interrupts</li></ul><h2 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h2><p>一些重要的CPU控制寄存器：</p><ul><li><code>stvec</code>: 保存trap handler的地址。</li><li><code>sepc</code>: trap发生时，保存pc指针。接着pc指针被改写成<code>stvec</code>中保存的trap handler地址。<code>sret</code>指令把<code>sepc</code>的值拷贝回pc指针。</li><li><code>scause</code>: 保存发生trap的原因。</li><li><code>sscratch</code>:</li><li><code>sstatus</code>: <code>SIE</code> bit控制设备中断使能。<code>SPP</code>表示trap来自user mode还是supervisor mode。</li></ul><p>RISC-V硬件处理traps流程(除timer中断)：</p><ol><li>如果是设备中断，而且<code>sstatus</code>的<code>SIE</code>bit没有被开启，下面都不会执行。</li><li>禁止掉<code>SIE</code> in <code>sstatus</code>。</li><li>拷贝<code>pc</code>到<code>sepc</code>。</li><li>保存当前mode(user/supervisor)到<code>sstatus</code>的<code>SPP</code>。</li><li>设置<code>scause</code>发生异常的原因。</li><li>进入supervisor mode。</li><li>拷贝<code>stvec</code>到pc。</li><li>开始在新pc执行代码。</li></ol><h2 id="4-2-Trap-from-user-space"><a href="#4-2-Trap-from-user-space" class="headerlink" title="4.2 Trap from user space"></a>4.2 Trap from user space</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240227224055.png"></p><p>user space trap流程：<code>trampoline.S</code><br><code>uservec</code>-&gt;<code>usertrap</code><br>返回的时候：<code>usertrapret</code>-&gt;<code>userret</code></p><p>为什么user space能执行到kernel的trap处理代码呢？user space调用<code>ecall</code>, 会进入<code>stvec</code>设置的trap handler，此时CPU使用的还是user space的page table，还没有切换到kernel space的page table。所以<code>stvec</code>中存储的是user space的virtual address<code>TRAPPOLINE</code>。user space实现了<code>trampoline page</code>。把virtual address的最后一个page<code>TRAPPOLINE</code>映射到了kernel trap handler。</p><p>进入<code>uservec</code>的时候，需要保存user space所有32个寄存器到某个memory地址，这时候没有一个空闲的寄存器，怎么办呢？RISC-V提供了<code>scratch</code>寄存器，在之前保存了某个地址<code>p-&gt;trapframe</code>。但这是kernel的结构体，此时<code>satp</code>还保存着user space的page table，所以user space还映射了一个page<code>TRAPFRAME</code>，在<code>TRAPOLINE</code>下面。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240227220131.png"></p><p>接着可以将<code>sccrach</code>与a0交换值：</p><p><code>csrrw a0, sscratch, a0</code></p><p>这样我们就可以使用a0了，将其他31个寄存器的值保存到此时a0(p-&gt;trapframe)对应的offset，最后再将<code>sscratch</code>中保存的旧a0值加载进对应的内存地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">csrr t0, sscratch<br>sd t0, <span class="hljs-number">112</span>(a0)<br></code></pre></td></tr></tbody></table></figure><p>接着将之前就设置好的<br>kernel栈指针<code>p-&gt;trapframe-&gt;kernel_sp</code>加载到<code>sp</code>。<br>cpu id<code>p-&gt;trapframe-&gt;kernel_haltid</code>加载到<code>tp</code>。<br>kernel trap入口<code>p-&gt;trapframe-&gt;kernel_trap</code>加载到<code>t0</code>。<br>kernel page table<code>p-&gt;trapframe-&gt;kernel_satp</code>加载到<code>satp</code>。</p><blockquote><p>这边加载了kernel的page table后还能继续执行代码，因为kernel也将相同的virtual address(trampoline page)映射到了与user space trampoline page相同的物理地址。</p></blockquote><h2 id="4-3-4-4-Code-Calling-system-calls"><a href="#4-3-4-4-Code-Calling-system-calls" class="headerlink" title="4.3-4.4 Code: Calling system calls"></a>4.3-4.4 Code: Calling system calls</h2><p>见xv_chapter2.md。</p><h2 id="4-5-Traps-from-kernel-code"><a href="#4-5-Traps-from-kernel-code" class="headerlink" title="4.5 Traps from kernel code"></a>4.5 Traps from kernel code</h2><p>user space发生trap进入kernel space后，<code>stvec</code>会被设置为<code>kernelvec</code>，接着kernel中发生的设备中断和异常会进入<code>kernelvec</code>。</p><h2 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h2><p>RISC-V区分三种page faults:</p><ul><li>load page fault: load指令中的虚拟地址不能正确翻译</li><li>store page fault: store指令中的虚拟地址不能正确翻译</li><li>instruction page fault: pc指针的虚拟地址不能正确翻译</li></ul><p><code>scause</code>中展示了page fault的种类，<code>stval</code>保存了不能翻译的地址。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6 calling conventions and stack frames RISC-V</title>
    <link href="/2024/02/25/Project/xv6/xv6_TA/"/>
    <url>/2024/02/25/Project/xv6/xv6_TA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240225201553.png"></p><p>caller: not preserved across fn call. 需要调用函数来保存寄存器。参考下面例子中的ra寄存器值。<br>callee: preserved across fn call. 被调用函数来保存寄存器。</p><br><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240225223002.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">sum_to:<br>  mv t0, a0<br>  li a0, <span class="hljs-number">0</span><br>    loop:<br>  add a0, a0, t0<br>  addi t0, t0, <span class="hljs-number">-1</span><br>  bnez t0, loop<br>  ret <span class="hljs-comment">// 返回到li t0, 2</span><br><br>sum_then_double:<br>  addi sp, sp, <span class="hljs-number">-16</span>; <span class="hljs-comment">// 分配栈空间</span><br>  sd ra, <span class="hljs-number">0</span>(sp) <span class="hljs-comment">// ra的值存入sp+0地址。caller保存sum_the_double执行完的返回地址</span><br>  call sum_to <span class="hljs-comment">// 这里调用call，ra的值被设置为下一条指令地址，即li t0, 2</span><br>  li t0, <span class="hljs-number">2</span><br>  mul a0, a0, t0<br>  ld ra, <span class="hljs-number">0</span>(sp) <span class="hljs-comment">// 恢复sum_them_double的返回地址</span><br>  addi sp, sp, <span class="hljs-number">16</span><br>  ret<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_lab3 pgtbl</title>
    <link href="/2024/02/01/Project/xv6/xv6_lab3_pgbtl/"/>
    <url>/2024/02/01/Project/xv6/xv6_lab3_pgbtl/</url>
    
    <content type="html"><![CDATA[<h2 id="Q1-Speed-up-system-call"><a href="#Q1-Speed-up-system-call" class="headerlink" title="Q1 Speed up system call"></a>Q1 Speed up system call</h2><p>这个实验的目的是将用户程序的虚拟地址<code>USYSCALL</code>映射到保存有进程<code>pid</code>的物理地址。<br>这样不用通过系统调用<code>getpid()</code>的方式，直接通过<code>ugetpid()</code>访问虚拟地址就可以直接得到映射的进程pid。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE) <span class="hljs-comment">// USYSCALL位于虚拟地址顶部Trapframe下面一个page</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ugetpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">u</span> =</span> (<span class="hljs-keyword">struct</span> usyscall *)USYSCALL; <span class="hljs-comment">// 直接访问虚拟地址</span><br>  <span class="hljs-keyword">return</span> u-&gt;pid;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在<code>struct proc</code>进程结构体中增加<code>struct usyscall *usyscall</code>, 在分配进程函数<code>allocproc</code>中初始化, 分配<code>p-&gt;pid</code>给<code>p-&gt;usyscall-&gt;pid</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>)<br>{<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>p-&gt;usyscall-&gt;pid = p-&gt;pid;<br></code></pre></td></tr></tbody></table></figure><p>在给进程分配页表的函数<code>proc_pagetable()</code>中映射指定的虚拟地址。</p><blockquote><p>注意要加上PTE_U</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;pagetable = proc_pagetable(p);<br><br><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>{<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// map the USYSCALL just below trapframe.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,<br>              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>){<br>    uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br>  <span class="hljs-comment">// ...</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Q2-Print-a-page-table"><a href="#Q2-Print-a-page-table" class="headerlink" title="Q2 Print a page table"></a>Q2 Print a page table</h2><p>实现<code>vmprint</code>函数，打印进程<code>pid==1</code>的page table。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span><br>{<br>  <span class="hljs-type">static</span> uint8 level;<br>  <span class="hljs-type">static</span> uint8 once = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (once == <span class="hljs-number">0</span>)<br>  {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"page table %p\n"</span>, pagetable);<br>  once = <span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++){<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>){<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)<br>      {<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">".. "</span>);<br>      }<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"..%d: pte %p pa %p\n"</span>, i, pte, PTE2PA(pte));<br>      <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>      level++;<br>      uint64 child = PTE2PA(pte);<br>      vmprint((<span class="hljs-type">pagetable_t</span>)child);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pte &amp; PTE_V){ <span class="hljs-comment">// 肯定是最后的根节点</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">".. .. ..%d: pte %p pa %p\n"</span>, i, pte, PTE2PA(pte));<br>    }<br>  }<br>  level = <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先打印页表的物理地址<code>printf("page table %p\n", pagetable);</code>。</p><p>valid位为1，R/W/X为0的pte，不是叶节点，需要进一步索引到下一级页表。<br>valid位为1，R/W/X有为1的pte，是叶节点。</p><p><code>%p</code>打印pte的内容和pte对应的物理地址。<br>%p对变量进行的格式化是将变量值以16进制打印，并在前面添加0x<br>不是所谓的打印变量地址！</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">page table 0x0000000087f6e000<br>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000 # 此pte不是叶节点，pa指向下一级页表的起始地址<br>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000<br>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000<br>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br>.. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000<br>.. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000<br>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000<br></code></pre></td></tr></tbody></table></figure><h2 id="Q3-Detecting-which-pages-have-been-accessed"><a href="#Q3-Detecting-which-pages-have-been-accessed" class="headerlink" title="Q3 Detecting which pages have been accessed"></a>Q3 Detecting which pages have been accessed</h2><p>实现系统调用<code>pgaccess</code>, 传入要检查pages的起始虚拟地址<code>void *base</code>，要检查pages的数量<code>int len</code>，返回的bitmask<code>void *mask</code>，保存是否含有<code>PTE_A</code>标志的pages，根据<code>len</code>从LSB位开始按顺序保存：<br><code>int pgaccess(void *base, int len, void *mask);</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_pgaccess(<span class="hljs-type">void</span>)<br>{<br>  <span class="hljs-comment">// lab pgtbl: your code here.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> num;<br>  uint64 p;<br>  uint64 user_bitmap_addr;<br><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;p) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 获取user space传入的虚拟地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;num) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 获取要检查pages的数量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">2</span>, &amp;user_bitmap_addr) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 获取需要返回的bitmap地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> pgaccess(p, num, user_bitmap_addr);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pgaccess</span><span class="hljs-params">(uint64 va, <span class="hljs-type">int</span> num, uint64 user_bitmap_addr)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-type">int</span> ret;<br>  uint32 bitmap;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>  {<br>    pte = walk(p-&gt;pagetable, va + i * PGSIZE, <span class="hljs-number">0</span>); <span class="hljs-comment">// 根据传入的virtual address找到对应的最后一层pte</span><br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_A)<br>    {<br>      *pte &amp;= ~PTE_A; <span class="hljs-comment">// 需要这一步清除，不然会一直置起。RISC-V硬件会在访问到该页的时候自动置起PTE_A</span><br>      bitmap |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>    }<br>  }<br><br>  ret = copyout(p-&gt;pagetable, user_bitmap_addr, (<span class="hljs-type">char</span> *)&amp;bitmap, <span class="hljs-number">8</span>); <span class="hljs-comment">// 拷贝bitmap回user space，即user_bitmap_addr地址。</span><br><br>  <span class="hljs-keyword">return</span> ret;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6 Misc</title>
    <link href="/2024/02/01/Project/xv6/xv6_misc/"/>
    <url>/2024/02/01/Project/xv6/xv6_misc/</url>
    
    <content type="html"><![CDATA[<h1 id="xv6运行"><a href="#xv6运行" class="headerlink" title="xv6运行"></a>xv6运行</h1><p><code>make qemu</code><br><code>make clean</code></p><p><code>Ctrl-p</code> 打印进程。<br><code>Ctrl-a x</code> 退出qemu。</p><p><code>make grade</code> 检查所有lab得分。<br><code>./grade-lab-util sleep</code> or <code>make GRADEFLAGS=sleep grade</code> 检查某一项作业得分。</p><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p><code>sudo aptitude install gdb-multiarch</code>: 解决ubuntu22.04 gdb版本不匹配的问题。</p><p>一个shell运行<code>make qemu-gdb</code>， 另一个shell运行<code>gdb-multiarch</code>，会自动加载<code>.gdbinit</code>。如果出现如下错误：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">warning: File "/home/xyc/MIT-6.S081-Operation-System/.gdbinit" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".<br>To enable execution of this file add<br>        add-auto-load-safe-path /home/xyc/MIT-6.S081-Operation-System/.gdbinit<br>line to your configuration file "/home/xyc/.config/gdb/gdbinit".<br></code></pre></td></tr></tbody></table></figure><p>按照提示操作，将<code>add-auto-load-safe-path /home/xyc/MIT-6.S081-Operation-System/.gdbinit</code>加到<code>/home/xyc/.config/gdb/gdbinit</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Board Porting Guide</title>
    <link href="/2024/02/01/Note/Zephyr/EnvBuild/24-02-01_Porting/"/>
    <url>/2024/02/01/Note/Zephyr/EnvBuild/24-02-01_Porting/</url>
    
    <content type="html"><![CDATA[<h2 id="Board-x2F"><a href="#Board-x2F" class="headerlink" title="Board/"></a>Board/</h2><p>添加自定义的board：<code>boards/&lt;arch&gt;/&lt;board&gt;/</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">boards/&lt;ARCH&gt;/plank<br>├── board.cmake<br>├── CMakeLists.txt<br>├── doc<br>│   ├── plank.png<br>│   └── index.rst<br>├── Kconfig.board<br>├── Kconfig.defconfig<br>├── plank_defconfig<br>├── plank.dts<br>└── plank.yaml<br></code></pre></td></tr></tbody></table></figure><p>必须要有的文件：</p><ol><li><code>plank.dts</code>：设备树。</li><li><code>Kconfig.board</code>, <code>Kconfig.defconfig</code>, <code>plank_defconfig</code>: Kconfig文件。</li></ol><p>可选文件：</p><ol><li><code>board.cmake</code>: 用于<code>west flash</code>和<code>west debug</code>。</li><li><code>CMakeLists.txt</code>: 如果在<code>board/</code>下加其他<code>*.c</code>的话需要。</li><li><code>doc/</code>: 文档。</li><li><code>plank.yaml</code>: Test Runner(Twister)需要使用。</li></ol><br><p><code>Kconfig.board</code>: 至少需要<code>config BOARD_PLANK</code>选项。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">config BOARD_PLANK<br>   bool <span class="hljs-string">"Plank board"</span><br>   depends on SOC_SERIES_YOUR_SOC_SERIES_HERE<br>   select SOC_PART_NUMBER_ABCDEFGH<br></code></pre></td></tr></tbody></table></figure><p><code>Kconfig.defconfig</code>: 板子的一些固定Kconfig选项，需要包括在 <code>if BOARD_PLANK/endif</code>中间。通常是invisible Kconfig Symbol，没有prompt。需要依赖default值或者其他Kconfig依赖，无法在配置菜单中选择。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> BOARD_PLANK<br># Always set CONFIG_BOARD here. This isn<span class="hljs-string">'t meant to be customized,</span><br><span class="hljs-string"># but is set as a "default" due to Kconfig language restrictions.</span><br><span class="hljs-string">config BOARD</span><br><span class="hljs-string">   default "plank"</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Other options you want enabled by default go next. Examples:</span><br><span class="hljs-string"></span><br><span class="hljs-string">config FOO</span><br><span class="hljs-string">   default y</span><br><span class="hljs-string"></span><br><span class="hljs-string">if NETWORKING</span><br><span class="hljs-string">config SOC_ETHERNET_DRIVER</span><br><span class="hljs-string">   default y</span><br><span class="hljs-string">endif # NETWORKING</span><br><span class="hljs-string"></span><br><span class="hljs-string">endif # BOARD_PLANK</span><br></code></pre></td></tr></tbody></table></figure><p><code>plank_defconfig</code>: 选择soc，时钟，串口等等CONFIG_开关。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CONFIG_SOC_${VENDOR_XYZ3000}=y                # select your SoC<br>CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=<span class="hljs-number">120000000</span>  # set up your clock, etc<br>CONFIG_SERIAL=y<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Misc</title>
    <link href="/2024/01/31/Note/Zephyr/24-01-31_Misc/"/>
    <url>/2024/01/31/Note/Zephyr/24-01-31_Misc/</url>
    
    <content type="html"><![CDATA[<p>执行如下命令, 再编译后, build目录下生成 <code>compile_commands.json</code>, 可以帮忙IDE进行代码的诊断, 补全和跳转:</p><p><code>west config build.cmake-args -- -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code></p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Kconfig</title>
    <link href="/2024/01/31/Note/Zephyr/EnvBuild/24-01-31_Kconfig/"/>
    <url>/2024/01/31/Note/Zephyr/EnvBuild/24-01-31_Kconfig/</url>
    
    <content type="html"><![CDATA[<h2 id="Setting-Kconfig-configuration-values"><a href="#Setting-Kconfig-configuration-values" class="headerlink" title="Setting Kconfig configuration values"></a>Setting Kconfig configuration values</h2><p>生成的配置文件:<br><code>zephyr/build/.config</code>: for CMake use.<br><code>zephyr/build/zephyr/include/generated/autoconf.h</code>: for c file use.</p><p>所有的Kconfig配置会merge如下路径的Kconfig files：</p><ol><li><code>board/&lt;arch&gt;/&lt;BOARD&gt;/&lt;BOARD&gt;_defconfig</code></li><li>CMake中定义的<code>CONFIG_XXX</code></li><li>Application configuration(APP 目录下的Kconfig相关文件)</li></ol><p>第三点Application configuration又会从如下路径获取Kconfig，默认使用<code>prj.conf</code>:</p><ol><li>如果定义了<code>CONF_FILE</code>, 会把该文件的Kconfig merge进来。<code>CONF_FILE</code>可以在如下定义<ol><li>App的<code>CMakeLists.txt</code>, 在<code>find_package(zephyr)</code>前定义。</li><li>west直接传入<code>-DCONF_FILE=&lt;conf file(s)&gt;</code></li><li>From the CMake variable cache</li></ol></li><li>如果未定义<code>CONF_FILE</code>, 如果存在<code>prj_&lt;BOARD&gt;.conf</code>，merge进<code>prj.conf</code>。</li><li>如果存在<code>board/&lt;BOARD&gt;.conf</code>，merge进<code>prj.conf</code>。</li><li>如果存在<code>board/&lt;BOARD&gt;_&lt;revision&gt;.conf</code>，merge进<code>prj.conf</code>。</li><li>merge必须有的<code>prj.conf</code>。</li></ol><p>如果<code>board/</code>下的<code>&lt;BOARD&gt;_defconfig</code>和<code>APP/</code>下的Kconfig冲突了，以APP的为准。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Kernel Init</title>
    <link href="/2024/01/30/Note/Zephyr/Kernel/24-01-30_KernelInit/"/>
    <url>/2024/01/30/Note/Zephyr/Kernel/24-01-30_KernelInit/</url>
    
    <content type="html"><![CDATA[<h2 id="Vector-table-S"><a href="#Vector-table-S" class="headerlink" title="Vector_table.S"></a>Vector_table.S</h2><p>以arm cortex-M系列的启动流程为例，<code>arch/arm/core/cortex_m</code>:</p><p><code>vector_table.S</code>: 定义了中断向量表<code>_vector_table</code>。其中arm cortex-M规定0x0地址存放栈的起始地址（栈顶）。0x4开始存放reset handler,…<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240130152631.png"></p><blockquote><p>没看到定义外部中断的地址</p></blockquote><p>上电后跳转至<code>z_arm_reset</code>函数，进入<code>reset.S</code>。</p><h2 id="Reset-S"><a href="#Reset-S" class="headerlink" title="Reset.S"></a>Reset.S</h2><p>目前大部分的宏定义都没打开。这里关注下通用的一些流程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">movs.n r0, #_EXC_IRQ_DEFAULT_PRIO<br>msr BASEPRI, r0<br></code></pre></td></tr></tbody></table></figure><p>设置BASEPRI寄存器, 中断的base prioriity, 低于或等于该优先级的中断都会被屏蔽。<br>这里<code>#_EXC_IRQ_DEFAULT_PRIO</code>宏展开为3，说明中断优先级只能配置为0/1/2。</p><br><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ldr r0, =z_interrupt_stacks<br>ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE<br>adds r0, r0, r1<br>msr PSP, r0 <span class="hljs-comment">// write r0 to PSP</span><br>mrs r0, CONTROL <span class="hljs-comment">// read CONTROL to r0</span><br>movs r1, #<span class="hljs-number">2</span><br>orrs r0, r1 <span class="hljs-comment">/* CONTROL_SPSEL_Msk */</span><br>msr CONTROL, r0 <span class="hljs-comment">// write 0x2 to CONTROL</span><br>isb<br>bl z_arm_prep_c<br></code></pre></td></tr></tbody></table></figure><p>1.设置进程堆栈指针PSP, process stack pointer。<br>2.写CONTROL寄存器bit1，使用PSP作为当前的stack。<br>3.跳转至<code>z_arm_prep_c</code></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240130155822.png"></p><h2 id="Prep-c-c"><a href="#Prep-c-c" class="headerlink" title="Prep_c.c"></a>Prep_c.c</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">z_arm_prep_c</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  relocate_vector_table();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_CPU_HAS_FPU)</span><br>  z_arm_floating_point_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  z_bss_zero();<br>  z_data_copy();<br>  z_arm_interrupt_init();<br>  z_cstart();<br>  CODE_UNREACHABLE;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>z_bss_zero()</code>: 清bss段。<br><code>z_data_copy()</code>: 把data段数据从ROM拷贝到RAM。<br><code>z_arm_interrupt_init()</code>: 设置外部中断优先级先都为1。<br><code>z_cstart()</code>: 跳转至<code>init.c</code>。</p><h1 id="Init-c"><a href="#Init-c" class="headerlink" title="Init.c"></a>Init.c</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">z_cstart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-comment">/* initialize early init calls */</span><br>  z_sys_init_run_level(INIT_LEVEL_EARLY);<br>  <span class="hljs-comment">/* perform any architecture-specific initialization */</span><br>  arch_kernel_init();<br>  LOG_CORE_INIT();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_MULTITHREADING)</span><br>  <span class="hljs-comment">/* Note: The z_ready_thread() call in prepare_multithreading() requires</span><br><span class="hljs-comment">   * a dummy thread even if CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN=y</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">k_thread</span> <span class="hljs-title">dummy_thread</span>;</span><br>  z_dummy_thread_init(&amp;dummy_thread);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/* do any necessary initialization of static devices */</span><br>  z_device_state_init();<br>  <span class="hljs-comment">/* perform basic hardware initialization */</span><br>  z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);<br>  z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MULTITHREADING</span><br>  switch_to_main_thread(prepare_multithreading());<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>  }<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_MULTITHREADING */</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p>删掉了一些没打开的宏相关代码。</p><p><code>z_sys_init_run_level(INIT_LEVEL_EARLY)</code><br><code>z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1)</code><br><code>z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2)</code><br>根据优先级，初始化系统中所有driver的init函数和通过<code>SYS_INIT()</code>定义的init函数。<br>参考<code>DEVICE_DT_DEFINE</code>-&gt;<code>Z_DEVICE_INIT_ENTRY_DEFINE</code>宏定义的driver,会在<code>z_sys_init_run_level</code>函数中调用<code>.init_fn-&gt;.dev(dev)</code>。<br>而<code>SYS_INIT()</code>会调用到<code>.init_fn-&gt;sys()</code></p><p>初始化完成后进入死循环。</p><br><p>其中<code>arch_kernel_init</code>函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> ALWAYS_INLINE <span class="hljs-type">void</span> <span class="hljs-title function_">arch_kernel_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  z_arm_interrupt_stack_setup();<br>  z_arm_exc_setup();<br>  z_arm_fault_init();<br>  z_arm_cpu_idle_init();<br>  z_arm_clear_faults();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_ARM_MPU)</span><br>  z_arm_mpu_init();<br>  z_arm_configure_static_mpu_regions();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_ARM_MPU */</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p><code>z_arm_interrupt_stack_setup()</code>: 设置msp, interrupt使用的stack。<br><code>z_arm_exc_setup()</code>: 设置好系统异常的中断优先级。<br><code>z_arm_fault_init()</code>: 设置CPU CCR寄存器，打开除0异常。非对齐访问异常由宏开关控制是否打开，默认不打开。<br><code>z_arm_cpu_idle_init()</code>: 设置CPU SCR寄存器，设置中断可以唤醒CPU idle状态。<br><code>z_arm_clear_faults()</code>: reset all faults，清除所有异常。</p><br><p><code>switch_to_main_thread(prepare_multithreading())</code>: 创建一个kernel线程，接着会跑进<code>bg_thread_main</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">bg_thread_main</span><span class="hljs-params">(<span class="hljs-type">void</span> *unused1, <span class="hljs-type">void</span> *unused2, <span class="hljs-type">void</span> *unused3)</span><br>{<br>  ARG_UNUSED(unused1);<br>  ARG_UNUSED(unused2);<br>  ARG_UNUSED(unused3);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU</span><br>  z_mem_manage_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_MMU */</span></span><br>  z_sys_post_kernel = <span class="hljs-literal">true</span>;<br>  z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);<br>  boot_banner();<br>  <span class="hljs-comment">/* Final init level before app starts */</span><br>  z_sys_init_run_level(INIT_LEVEL_APPLICATION);<br>  z_init_static_threads();<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU</span><br>  z_mem_manage_boot_finish();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_MMU */</span></span><br><br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br>  (<span class="hljs-type">void</span>)main();<br>}<br></code></pre></td></tr></tbody></table></figure><p>包括一些低优先级的driver, <code>SYS_INIT()</code>初始化，MMU初始化，<code>boot_banner</code>会打印LOGO。这时kernel已经初始化完毕，之后跳转进应用程序的<code>main()</code>函数。</p><h1 id="linker-ld"><a href="#linker-ld" class="headerlink" title="linker.ld"></a>linker.ld</h1><p><code>include/zephyr/arch/arm/cortex_m/scripts/linker.ld</code>链接脚本。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Interrupt Subsystem</title>
    <link href="/2024/01/26/Note/Zephyr/Driver/24-01-29_Interrupt/"/>
    <url>/2024/01/26/Note/Zephyr/Driver/24-01-29_Interrupt/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><a href="https://docs.zephyrproject.org/latest/kernel/services/interrupts.html">https://docs.zephyrproject.org/latest/kernel/services/interrupts.html</a></p><h2 id="Multi-level-Interrupt-Handling"><a href="#Multi-level-Interrupt-Handling" class="headerlink" title="Multi-level Interrupt Handling"></a>Multi-level Interrupt Handling</h2><p>如果要支持中断嵌套，需要打开<code>CONFIG_MULTI_LEVEL_INTERRUPTS</code>。<code>CONFIG_2ND_LEVEL_INTERRUPTS</code>, <code>CONFIG_3RD_LEVEL_INTERRUPTS</code>也需要根据硬件架构来选择是否打开。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">          <span class="hljs-number">9</span>         <span class="hljs-number">4</span>   <span class="hljs-number">2</span>   <span class="hljs-number">0</span><br>    _ _ _ _ _ _ _ _ _ _ _ _ _         (LEVEL <span class="hljs-number">1</span>)<br>  <span class="hljs-number">5</span>   <span class="hljs-number">3</span>   |         A   |     <span class="hljs-number">2</span><br>_ _ _ _ _ _ _         _ _ _ _ _ _ _   (LEVEL <span class="hljs-number">2</span>)<br>  |   C                       B<br>_ _ _ _ _ _ _                         (LEVEL <span class="hljs-number">3</span>)<br>        D<br></code></pre></td></tr></tbody></table></figure><p>Level 1第一级中断控制器有12条interrupt lines, 其中第2条和第9条接到了Level2优先级更高的中断控制器。第4条上接了设备A。<br>Level 2有两个中断控制器，左边的第3条interrupt line接了设备C, 第5条接到Level3中断控制器。<br>右边的第二条接了设备B。<br>Level 3中断控制器上第2条interrupt line接到了设备D。</p><p>因此各设备对应的interrupt numbers如下。其中Level 2之后的offset会+1, 因为0表示该级别不存在中断号。<br>设备A直接就是0x4对应Level 1 interrupt controller的第4条interrupt line。<br>设备B首先从Level 1 interrupt controller的第2条interrupt line找到level 2 interrupt controller, 再对应到Level 2 interrupt controller的第3条interrupt line。<br>设备C/D同理。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">A -&gt; <span class="hljs-number">0x00000004</span><br>B -&gt; <span class="hljs-number">0x00000302</span><br>C -&gt; <span class="hljs-number">0x00000409</span><br>D -&gt; <span class="hljs-number">0x00030609</span><br></code></pre></td></tr></tbody></table></figure><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Regular-ISR"><a href="#Regular-ISR" class="headerlink" title="Regular ISR"></a>Regular ISR</h2><p>Define irq: <code>IRQ_CONNECT(irq_p, priority_p, isr_p, isr_param_p, flags_p)</code><br>其中<code>irq_p</code>是中断号，<code>priority_p</code>是中断优先级，<code>isr_param_p</code>是传递给中断处理函数的参数，<code>flags_p</code>是中断flags。</p><p>e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_CFG_IRQ(idx, n)</span><br>  IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, idx, irq),<br>    COND_CODE_1(DT_INST_IRQ_HAS_CELL(n, priority),<br>    DT_INST_IRQ(n, priority), (<span class="hljs-number">0</span>)), gpio_altera_irq_handler,<br>    DEVICE_DT_INST_GET(n), <span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><p>Enable irq: <code>irq_enable(irq)</code><br>其中<code>irq</code>是中断号。</p><h2 id="Direct-ISR"><a href="#Direct-ISR" class="headerlink" title="Direct ISR"></a>Direct ISR</h2><p><code>IRQ_DIRECT_CONNECT(irq_p, priority_p, isr_p, flags_p)</code></p><p>开销更少的ISR定义。如果打开了power management, 大部分时间设备处于idle状态，如果来了一个中断，所有的hardware需要resume，再进中断处理函数，这个耗时很长。可以通过Direct ISR解决。</p><h2 id="Sharing-an-interrupt-line"><a href="#Sharing-an-interrupt-line" class="headerlink" title="Sharing an interrupt line"></a>Sharing an interrupt line</h2><p>打开<code>CONFIG_SHARED_INTERRUPTS</code></p><p>一个中断号对应两个中断处理函数，两个函数都会进入，根据<code>IRQ_CONNECT</code>中传入isr的参数不同，通过软件处理来选择执行哪个函数（不需要的另一个函数，可以通过参数判断提前return）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_DEV_IRQ 24               <span class="hljs-comment">/* device uses INTID 24 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_DEV_IRQ_PRIO 2           <span class="hljs-comment">/* device uses interrupt priority 2 */</span></span><br><span class="hljs-comment">/*  this argument may be anything */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_FST_ISR_ARG INT_TO_POINTER(1)</span><br><span class="hljs-comment">/*  this argument may be anything */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_SND_ISR_ARG INT_TO_POINTER(2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_IRQ_FLAGS 0              <span class="hljs-comment">/* IRQ flags */</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_first_isr</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>{<br>   ... <span class="hljs-comment">/* some magic happens here */</span><br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_second_isr</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>{<br>   ... <span class="hljs-comment">/* even more magic happens here */</span><br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_isr_installer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>   ...<br>   IRQ_CONNECT(MY_DEV_IRQ, MY_DEV_IRQ_PRIO, my_first_isr, MY_FST_ISR_ARG, MY_IRQ_FLAGS);<br>   IRQ_CONNECT(MY_DEV_IRQ, MY_DEV_IRQ_PRIO, my_second_isr, MY_SND_ISR_ARG, MY_IRQ_FLAGS);<br>   ...<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- GPIO Subsystem</title>
    <link href="/2024/01/26/Note/Zephyr/Driver/24-01-26_GPIO/"/>
    <url>/2024/01/26/Note/Zephyr/Driver/24-01-26_GPIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Device-Tree"><a href="#Device-Tree" class="headerlink" title="Device Tree"></a>Device Tree</h1><p><code>dts/binding/gpio/gpio-controller.yaml</code>描述了设备树中支持的属性。</p><p>gpio-controller节点：<br>其中<code>gpio-controller</code>和<code>gpio-cells</code>两个属性是必须的。<br>前者表示gpio controller节点，后者表示其他节点使用gpio specifier需要几个item来描述。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">gpio: gpio@<span class="hljs-number">0x400ff000</span> {<br>  compatible = <span class="hljs-string">"nxp, kinetis-gpio"</span>;<br>  status = <span class="hljs-string">"disabled"</span>;<br>  reg = &lt;<span class="hljs-number">0x400ff000</span> <span class="hljs-number">0x40</span>&gt;;<br>  interrupts = &lt;<span class="hljs-number">59</span> <span class="hljs-number">2</span>&gt;;<br>  gpio-controller;<br>  <span class="hljs-meta">#gpio-cells = <span class="hljs-string">&lt;2&gt;</span>;</span><br>  ngpios = &lt;<span class="hljs-number">32</span>&gt;; <span class="hljs-comment">// optional, default 32</span><br>  gpio-reserved-ranges = &lt;<span class="hljs-number">3</span> <span class="hljs-number">2</span>&gt;, &lt;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>&gt;; <span class="hljs-comment">// optional, &lt;index size&gt;表示第&lt;index&gt;起&lt;size&gt;个gpio不能使用。</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>consumer节点:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">xxx-gpios/gpios = &lt;&amp;&lt;gpio-controller节点&gt; &lt;gpio_number&gt; &lt;配置属性&gt;&gt;<br><br>xxx-gpios = &lt;&amp;gpio <span class="hljs-number">5</span> (GPIO_PULL_UP | GPIO_ACTIVE_LOW)&gt;,<br>    &lt;&amp;gpio <span class="hljs-number">6</span> (GPIO_PULL_DOWN | GPIO_ACTIVE_LOW)&gt;;<br></code></pre></td></tr></tbody></table></figure><p><code>GPIO_ACTIVE_LOW</code>表示逻辑电平和实际电平相反，逻辑1代表低电平。</p><p>配置属性可在<code>include/zephyr/dt-bindings/gpio/gpio.h</code>中查找。</p><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><p><strong>方法一:</strong> 设备树API</p><p>从设备树获取的gpio信息会保存到<code>gpio_dt_spec</code>结构体。包括gpio controller, pin number, config flag。对应上面device tree中consumer节点的node。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dt_spec</span> {</span><br>  <span class="hljs-comment">/** GPIO device controlling the pin */</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">port</span>;</span><br>  <span class="hljs-comment">/** The pin's number on the device */</span><br>  <span class="hljs-type">gpio_pin_t</span> pin;<br>  <span class="hljs-comment">/** The pin's configuration flags as specified in devicetree */</span><br>  <span class="hljs-type">gpio_dt_flags_t</span> dt_flags;<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以通过<code>GPIO_DT_SPEC_GET_BY_IDX()</code>或其他一系列变种函数解析dts获取<code>gpio_dt_spec</code>结构体。<br><code>node_id</code>对应consumer的node，<code>prop</code>为<code>xxx-gpios</code>, <code>idx</code>为<code>xxx-gpios</code>下的第x条属性。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_DT_SPEC_GET_BY_IDX(node_id, prop, idx)             \</span><br><span class="hljs-meta">  {       \</span><br><span class="hljs-meta">    .port = DEVICE_DT_GET(DT_GPIO_CTLR_BY_IDX(node_id, prop, idx)),\</span><br><span class="hljs-meta">    .pin = DT_GPIO_PIN_BY_IDX(node_id, prop, idx),       \</span><br><span class="hljs-meta">    .dt_flags = DT_GPIO_FLAGS_BY_IDX(node_id, prop, idx),       \</span><br><span class="hljs-meta">  }</span><br></code></pre></td></tr></tbody></table></figure><p>得到<code>gpio_dt_spec</code>结构体后，就可以调用一系列设备树函数来进行GPIO操作了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断gpio controller是否ready</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">gpio_is_ready_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec)</span>;<br><span class="hljs-comment">/** 设置GPIO中断, 可传入的gpio_flags_t有, 具体含义参考drivers/gpio.h:</span><br><span class="hljs-comment"> * GPIO_INT_EDGE_RISING</span><br><span class="hljs-comment"> * GPIO_INT_EDGE_FALLING</span><br><span class="hljs-comment"> * GPIO_INT_EDGE_BOTH</span><br><span class="hljs-comment"> * GPIO_INT_LEVEL_LOW</span><br><span class="hljs-comment"> * GPIO_INT_LEVEL_HIGH</span><br><span class="hljs-comment"> * ...</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_interrupt_configure_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec,</span><br><span class="hljs-params">              <span class="hljs-type">gpio_flags_t</span> flags)</span>;<br><span class="hljs-comment">// 配置一个pin的config, 结果为spec-&gt;dt_flags | extra_flags</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_configure_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec,</span><br><span class="hljs-params">          <span class="hljs-type">gpio_flags_t</span> extra_flags)</span><br><span class="hljs-comment">// 判断pin是否为input</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_is_input_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec)</span><br><span class="hljs-comment">// 判断pin是否为output</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_is_output_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec)</span><br><span class="hljs-comment">// 获取pin的config保存到flags中</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_get_config_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec,</span><br><span class="hljs-params">          <span class="hljs-type">gpio_flags_t</span> *flags)</span><br><span class="hljs-comment">// 获取input pin value</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_get_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec)</span><br><span class="hljs-comment">// 设置ouput pin value</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_set_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec, <span class="hljs-type">int</span> value)</span><br><span class="hljs-comment">// toggle gpio</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_toggle_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_add_callback_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> gpio_dt_spec *spec,</span><br><span class="hljs-params">          <span class="hljs-keyword">struct</span> gpio_callback *callback)</span><br></code></pre></td></tr></tbody></table></figure><p><strong>方法二:</strong> 直接传入<code>device</code>结构体，不需要从设备树获取数据。</p><p>可以通过<code>DEVICE_DT_GET</code>宏得到<code>device</code>结构体。<br><code>include/zephyr/devicetree/gpio.h</code>中封装了许多gpio操作devicetree的宏，用来获取gpio pin flag等属性。</p><p>和上面的device tree APIs的底层实现是相同的，不过这些APIs需要指定pin, flags等参数传入。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_interrupt_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">             <span class="hljs-type">gpio_pin_t</span> pin,</span><br><span class="hljs-params">             <span class="hljs-type">gpio_flags_t</span> flags)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">         <span class="hljs-type">gpio_pin_t</span> pin,</span><br><span class="hljs-params">         <span class="hljs-type">gpio_flags_t</span> flags)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_get_direction</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port, <span class="hljs-type">gpio_port_pins_t</span> <span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">              <span class="hljs-type">gpio_port_pins_t</span> *inputs, <span class="hljs-type">gpio_port_pins_t</span> *outputs)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_pin_get_config</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port, <span class="hljs-type">gpio_pin_t</span> pin,</span><br><span class="hljs-params">          <span class="hljs-type">gpio_flags_t</span> *flags)</span>;<br><span class="hljs-comment">// 获取input value</span><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_get_raw</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">        <span class="hljs-type">gpio_port_value_t</span> *value)</span>;<br><span class="hljs-comment">// 设置output value</span><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_set_masked_raw</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">               <span class="hljs-type">gpio_port_pins_t</span> mask,</span><br><span class="hljs-params">               <span class="hljs-type">gpio_port_value_t</span> value)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_set_bits_raw</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">             <span class="hljs-type">gpio_port_pins_t</span> pins)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_clear_bits_raw</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">               <span class="hljs-type">gpio_port_pins_t</span> pins)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_port_toggle_bits</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,</span><br><span class="hljs-params">            <span class="hljs-type">gpio_port_pins_t</span> pins)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_get_pending_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev)</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="Driver-Example"><a href="#Driver-Example" class="headerlink" title="Driver Example"></a>Driver Example</h2><p><code>i2c_ite_enhance.c</code>在<code>dev-&gt;config</code>中保存了两个<code>gpio_dt_spec</code>结构体：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_enhance_config</span> {</span><br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-comment">/* SCL GPIO cells */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dt_spec</span> <span class="hljs-title">scl_gpios</span>;</span><br>  <span class="hljs-comment">/* SDA GPIO cells */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dt_spec</span> <span class="hljs-title">sda_gpios</span>;</span><br>  <span class="hljs-comment">//...</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>初始化时通过<code>GPIO_DT_SPEC_INST_GET</code>宏从设备树获取数据填充<code>gpio_dt_spec</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">i2c0: i2c@f04300 {<br>  compatible = <span class="hljs-string">"ite,enhance-i2c"</span>;<br>  scl-gpios = &lt;&amp;gpiob <span class="hljs-number">3</span> <span class="hljs-number">0</span>&gt;;<br>  sda-gpios = &lt;&amp;gpiob <span class="hljs-number">4</span> <span class="hljs-number">0</span>&gt;;<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_enhance_config</span> <span class="hljs-title">i2c_enhance_cfg_</span>##<span class="hljs-title">inst</span> =</span> {       \<br>  <span class="hljs-comment">//...</span><br>  .scl_gpios = GPIO_DT_SPEC_INST_GET(inst, scl_gpios),            \<br>  .sda_gpios = GPIO_DT_SPEC_INST_GET(inst, sda_gpios),            \<br>  <span class="hljs-comment">//...</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>在<code>i2c_enhance_recover_bus</code>函数中获取<code>dev-&gt;config</code>, 就可以调用gpio相关api了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_enhance_config</span> *<span class="hljs-title">config</span> =</span> dev-&gt;config;<br><span class="hljs-comment">/* Set SCL of I2C as GPIO pin */</span><br>gpio_pin_configure_dt(&amp;config-&gt;scl_gpios, GPIO_OUTPUT);<br><span class="hljs-comment">/* Set SDA of I2C as GPIO pin */</span><br>gpio_pin_configure_dt(&amp;config-&gt;sda_gpios, GPIO_OUTPUT);<br><br><span class="hljs-comment">/* Pull SCL and SDA pin to high */</span><br>gpio_pin_set_dt(&amp;config-&gt;scl_gpios, <span class="hljs-number">1</span>);<br>gpio_pin_set_dt(&amp;config-&gt;sda_gpios, <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="Test-Example"><a href="#Test-Example" class="headerlink" title="Test Example"></a>Test Example</h2><p><code>tests/drivers/gpio/</code>目录下有许多gpio相关的测试程序。</p><h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>可以实现的API:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">__subsystem <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_driver_api</span> {</span><br>  <span class="hljs-comment">// 配置output/input, pull up/down,</span><br>  <span class="hljs-type">int</span> (*pin_configure)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port, <span class="hljs-type">gpio_pin_t</span> pin,<br>           <span class="hljs-type">gpio_flags_t</span> flags);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GPIO_GET_CONFIG</span><br>  <span class="hljs-type">int</span> (*pin_get_config)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port, <span class="hljs-type">gpio_pin_t</span> pin,<br>            <span class="hljs-type">gpio_flags_t</span> *flags);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-type">int</span> (*port_get_raw)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>          <span class="hljs-type">gpio_port_value_t</span> *value);<br>  <span class="hljs-type">int</span> (*port_set_masked_raw)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>           <span class="hljs-type">gpio_port_pins_t</span> mask,<br>           <span class="hljs-type">gpio_port_value_t</span> value);<br>  <span class="hljs-type">int</span> (*port_set_bits_raw)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>         <span class="hljs-type">gpio_port_pins_t</span> pins);<br>  <span class="hljs-type">int</span> (*port_clear_bits_raw)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>           <span class="hljs-type">gpio_port_pins_t</span> pins);<br>  <span class="hljs-type">int</span> (*port_toggle_bits)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>        <span class="hljs-type">gpio_port_pins_t</span> pins);<br>  <span class="hljs-type">int</span> (*pin_interrupt_configure)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>               <span class="hljs-type">gpio_pin_t</span> pin,<br>               <span class="hljs-keyword">enum</span> gpio_int_mode, <span class="hljs-keyword">enum</span> gpio_int_trig);<br>  <span class="hljs-type">int</span> (*manage_callback)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port,<br>             <span class="hljs-keyword">struct</span> gpio_callback *cb,<br>             <span class="hljs-type">bool</span> <span class="hljs-built_in">set</span>);<br>  <span class="hljs-type">uint32_t</span> (*get_pending_int)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GPIO_GET_DIRECTION</span><br>  <span class="hljs-type">int</span> (*port_get_direction)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *port, <span class="hljs-type">gpio_port_pins_t</span> <span class="hljs-built_in">map</span>,<br>          <span class="hljs-type">gpio_port_pins_t</span> *inputs, <span class="hljs-type">gpio_port_pins_t</span> *outputs);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_GPIO_GET_DIRECTION */</span></span><br>};<br></code></pre></td></tr></tbody></table></figure><p>Driver需要定义一个device实例，其中<code>dev-&gt;config</code>和<code>dev-&gt;data</code>两个自定义结构体，需要首先包含<code>struct gpio_driver_config</code>和<code>struct gpio_driver_data</code>两个通用结构体，以<code>gpio_dw.h</code>为例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dw_config</span> {</span><br>  <span class="hljs-comment">/* gpio_driver_config needs to be first */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_driver_config</span> <span class="hljs-title">common</span>;</span><br>  <span class="hljs-type">uint32_t</span> ngpios;<br>  <span class="hljs-type">uint32_t</span> irq_num; <span class="hljs-comment">/* set to 0 if GPIO port cannot interrupt */</span><br>  <span class="hljs-type">gpio_config_irq_t</span> config_func;<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dw_runtime</span> {</span><br>  <span class="hljs-comment">/* gpio_driver_data needs to be first */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_driver_data</span> <span class="hljs-title">common</span>;</span><br>  <span class="hljs-type">uint32_t</span> base_addr;<br>  <span class="hljs-type">sys_slist_t</span> callbacks;<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_driver_config</span> {</span><br>  <span class="hljs-comment">/** Mask identifying pins supported by the controller.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Initialization of this mask is the responsibility of device</span><br><span class="hljs-comment">   * instance generation in the driver.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">gpio_port_pins_t</span> port_pin_mask;<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_driver_data</span> {</span><br>  <span class="hljs-comment">/** Mask identifying pins that are configured as active low.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Management of this mask is the responsibility of the</span><br><span class="hljs-comment">   * wrapper functions in this header.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">gpio_port_pins_t</span> invert;<br>};<br><br><span class="hljs-comment">// port_pin_mask需要在gpio controller driver中定义。以gpio_dw.c为例：</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_dw_config</span> <span class="hljs-title">gpio_dw_config_</span>##<span class="hljs-title">n</span> =</span> {        \<br>  .common = {\<br>    .port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\<br>  },\<br>  .irq_num = COND_CODE_1(DT_INST_IRQ_HAS_IDX(n, <span class="hljs-number">0</span>), (DT_INST_IRQN(n)), (<span class="hljs-number">0</span>)),\<br>  .ngpios = DT_INST_PROP(n, ngpios),\<br>  .config_func = gpio_config_#<span class="hljs-meta">#n##_irq,\</span><br><span class="hljs-meta">};</span><br><br><span class="hljs-comment">// invert会在抽象层gpio.h定义，不需要driver来实现，从设备树GPIO_ACTIVE_HIGH/LOW获取。</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Project1 Hog</title>
    <link href="/2024/01/25/Project/cs61a/Project1_Hog/"/>
    <url>/2024/01/25/Project/cs61a/Project1_Hog/</url>
    
    <content type="html"><![CDATA[<p>Rule1: Sow Sad. 选择摇1-10次骰子，得分为点数之和，如果摇到1，那得分就为1。<br>Rule2: Boar Brawl. 可以选择不摇骰子，直接获得3*abs(对手得分的十位数-自己得分的个位数)的分数。<br>Rule3: Sus Fuss. 如果得分数有3或4个公因子，比如21有1,3,7,21，自动把分数加到下一个质数，21-&gt;23。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clash如何开启终端代理</title>
    <link href="/2024/01/24/Misc/%E7%BB%88%E7%AB%AF%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86/"/>
    <url>/2024/01/24/Misc/%E7%BB%88%E7%AB%AF%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="MacOS-amp-Linux"><a href="#MacOS-amp-Linux" class="headerlink" title="MacOS&amp;Linux"></a>MacOS&amp;Linux</h2><p>参考：<br><a href="https://weilining.github.io/294.html">https://weilining.github.io/294.html</a></p><p>临时方法：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy=http://127.0.0.1:7890<br>export https_proxy=$http_proxy<br></code></pre></td></tr></tbody></table></figure><p>可以把命令写进<code>.bash_profile</code>或<code>.zprofile</code>永久生效：<br>7890为端口号。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">function proxy_on() {<br>    export http_proxy=http://127.0.0.1:7890<br>    export https_proxy=$http_proxy<br>    echo -e "终端代理已开启。"<br>}<br><br>function proxy_off(){<br>    unset http_proxy https_proxy<br>    echo -e "终端代理已关闭。"<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>source .bash_profile</code>后输入<code>proxy_on</code>开启，<code>proxy_off</code>关闭。</p><p>Windows下在git bash中操作一样。</p><h2 id="git-clone-ssh走代理"><a href="#git-clone-ssh走代理" class="headerlink" title="git clone ssh走代理"></a>git clone ssh走代理</h2><p>MacOS/Linux/Windows: <code>~/.ssh/config</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">全局</span><br>ProxyCommand connect -S 127.0.0.1:7890 %h %p<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只为特定域名设定</span><br>Host github.com<br>    ProxyCommand connect -S 127.0.0.1:7890 %h %p<br><br></code></pre></td></tr></tbody></table></figure><p>git 有两种协议，一种是https，还有一种是ssh。</p><p>如果是用https，设置终端代理即可，参考上面MacOS&amp;Linux的配置方法。如果是ssh，需要单独配置代理。</p><h3 id="SSH-通过443端口连接github"><a href="#SSH-通过443端口连接github" class="headerlink" title="SSH 通过443端口连接github"></a>SSH 通过443端口连接github</h3><p>有时候ssh的默认端口22被封了, 但443端口仍然可以访问。<br>只需要修改<code>~/.ssh/config</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Host github.com<br>  HostName ssh.github.com<br>  User git<br>  Port <span class="hljs-number">443</span><br></code></pre></td></tr></tbody></table></figure><h2 id="VMware虚拟机开启终端代理"><a href="#VMware虚拟机开启终端代理" class="headerlink" title="VMware虚拟机开启终端代理"></a>VMware虚拟机开启终端代理</h2><p>参考:<a href="https://www.cnblogs.com/bisa/p/17397950.html">https://www.cnblogs.com/bisa/p/17397950.html</a></p><p>Clash打开允许局域网连接。</p><p>虚拟机网络模式选择NAT模式。</p><p>查看VMware虚拟网卡的IP地址，最后一项为1。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240124215308.png"></p><p>虚拟机的IP地址最后一项应该为0，前三项相同。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240124215223.png"></p><p>在虚拟机终端开启终端代理：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy="http://192.168.168.1:7890"<br>export https_proxy="https://192.168.168.1:7890"<br></code></pre></td></tr></tbody></table></figure><p>注意这边的ip是主机端虚拟网卡的IP地址，端口号对应Clash中的端口。</p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode备忘录</title>
    <link href="/2024/01/23/Misc/vscode/"/>
    <url>/2024/01/23/Misc/vscode/</url>
    
    <content type="html"><![CDATA[<p><code>keybindings.json</code>: 键盘快捷方式json文件。<br><code>setting.json</code>: vscode设置文件。</p><p>块选择：<code>shift+箭头</code> /  <code>shift+Alt+鼠标</code></p><p>增加光标：<code>Ctrl+Alt+上/下箭头</code> / <code>Alt+click</code></p><p>复制一行：<code>Shift+Alt+上/下箭头</code></p><p>移动一行：<code>Alt+箭头</code></p><p>删除一行：<code>Ctrl+Shift+K</code></p><p>F2可以代码重构，对project下所有的函数名替换名称</p><p>格式化文档：<code>Shift+Alt+F</code> 格式化整个文档 / <code>Ctrl+K → Ctrl+F</code> 格式化某一行</p><p><code>Ctrl+Shift+[</code> / <code>Ctrl+Shift+]</code> 折叠函数</p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Week2</title>
    <link href="/2024/01/22/Project/cs61a/Week2/"/>
    <url>/2024/01/22/Project/cs61a/Week2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Control"><a href="#1-Control" class="headerlink" title="1. Control"></a>1. Control</h1><h3 id="1-4-1-Documentation"><a href="#1-4-1-Documentation" class="headerlink" title="1.4.1 Documentation"></a>1.4.1 Documentation</h3><p>docstring。在函数名后在``````中描述函数信息。第一行用来描述函数，接着空一行，接着可以描述参数等。</p><p>help(pressure)可以查看函数帮助信息。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n</span>):<br>        <span class="hljs-string">"""Compute the pressure in pascals of an ideal gas.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span><br><span class="hljs-string"></span><br><span class="hljs-string">        v -- volume of gas, in cubic meters</span><br><span class="hljs-string">        t -- absolute temperature in degrees kelvin</span><br><span class="hljs-string">        n -- particles of gas</span><br><span class="hljs-string">        """</span><br>        k = <span class="hljs-number">1.38e-23</span>  <span class="hljs-comment"># Boltzmann's constant</span><br>        <span class="hljs-keyword">return</span> n * k * t / v<br></code></pre></td></tr></tbody></table></figure><h3 id="1-4-2-Default-Argument-Values"><a href="#1-4-2-Default-Argument-Values" class="headerlink" title="1.4.2 Default Argument Values"></a>1.4.2 Default Argument Values</h3><p>带有默认值的函数形参在调用函数时不赋值表示使用默认值，可以用其他值代替。</p><h3 id="1-5-4-Conditional-Statements"><a href="#1-5-4-Conditional-Statements" class="headerlink" title="1.5.4 Conditional Statements"></a>1.5.4 Conditional Statements</h3><p><strong>Boolean contexts.</strong> 除了0，None，false其他都为True。</p><h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5 Iteration"></a>1.5.5 Iteration</h3><p><code>pred, curr = curr, pred + curr</code> 先计算=右边的表达式，才会更新=左边的值。</p><h2 id="Lab1-Functions-Control"><a href="#Lab1-Functions-Control" class="headerlink" title="Lab1 Functions, Control"></a>Lab1 Functions, Control</h2><h3 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">how_big</span>(<span class="hljs-params">x</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'huge'</span>)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">5</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'big'</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">0</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'small'</span>)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"nothing"</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>how_big(<span class="hljs-number">7</span>)<br>? big<br>-- Not quite. Try again! --<br><br>? <span class="hljs-string">'big'</span> <span class="hljs-comment">#</span><br>-- OK! --<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>how_big(<span class="hljs-number">12</span>)<br>? <span class="hljs-string">'huge'</span><br>-- Not quite. Try again! --<br><br>? huge<br>-- OK! --<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">how_big</span>(<span class="hljs-params">x</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'huge'</span>)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">5</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'big'</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'positive'</span>)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(how_big(<span class="hljs-number">12</span>))<br>(line <span class="hljs-number">1</span>)? huge<br>(line <span class="hljs-number">2</span>)? positive<br>(line <span class="hljs-number">3</span>)?<br>-- Not quite. Try again! --<br><br>(line <span class="hljs-number">1</span>)? huge<br>(line <span class="hljs-number">2</span>)? positive<br>(line <span class="hljs-number">3</span>)? <span class="hljs-literal">None</span><br>-- OK! --<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(how_big(<span class="hljs-number">1</span>), how_big(<span class="hljs-number">0</span>))<br>(line <span class="hljs-number">1</span>)? positive<br>(line <span class="hljs-number">2</span>)? <span class="hljs-number">0</span><br>(line <span class="hljs-number">3</span>)? <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>-- Not quite. Try again! --<br><br>(line <span class="hljs-number">1</span>)? positive<br>(line <span class="hljs-number">2</span>)? <span class="hljs-number">0</span><br>(line <span class="hljs-number">3</span>)? <span class="hljs-literal">None</span> <span class="hljs-literal">None</span><br>-- OK! --<br></code></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-number">13</span><br>? <span class="hljs-literal">True</span><br>-- Not quite. Try again! --<br><br>? <span class="hljs-number">1</span><br>-- Not quite. Try again! --<br><br>? <span class="hljs-number">13</span><br>-- OK! --<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br>? <span class="hljs-literal">False</span><br>-- Not quite. Try again! --<br><br>? <span class="hljs-number">0</span><br>-- OK! --<br></code></pre></td></tr></tbody></table></figure><p>Print with ‘DEBUG:’ at the front of the outputted line用来Debug，ok autograder也不会计入。<br>比如：<code>print('DEBUG:', res)</code></p><h1 id="2-Higher-Order-Functions"><a href="#2-Higher-Order-Functions" class="headerlink" title="2. Higher-Order Functions"></a>2. Higher-Order Functions</h1><h2 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1 Functions as Arguments"></a>1.6.1 Functions as Arguments</h2><p>函数做形参</p><h2 id="1-6-3-Nested-Definitions"><a href="#1-6-3-Nested-Definitions" class="headerlink" title="1.6.3 Nested Definitions"></a>1.6.3 Nested Definitions</h2><p>在函数中定义函数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_update</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> average(x, a/x)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_close</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> approx_eq(x * x, a)<br>    <span class="hljs-keyword">return</span> improve(sqrt_update, sqrt_close)<br></code></pre></td></tr></tbody></table></figure><p>子函数可以调用父函数的形参。</p><h2 id="1-6-4-Functions-as-Returned-Values"><a href="#1-6-4-Functions-as-Returned-Values" class="headerlink" title="1.6.4 Functions as Returned Values"></a>1.6.4 Functions as Returned Values</h2><p>函数做返回值</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">successor</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> f(g(x))<br>    <span class="hljs-keyword">return</span> h<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">"""Never called."""</span><br>    <span class="hljs-keyword">return</span> -x<br><br>square_successor = compose1(square, successor)<br>result = square_successor(<span class="hljs-number">12</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6 Currying"></a>1.6.6 Currying</h2><p>把有多个参数的函数转化为一系列只有一个参数的函数。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>        <span class="hljs-keyword">return</span> h<br><br>&gt;&gt;&gt;curried_pow(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br><span class="hljs-number">8</span><br></code></pre></td></tr></tbody></table></figure><h2 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7 Lambda Expressions"></a>1.6.7 Lambda Expressions</h2><p>匿名函数，只能有一句return语句。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: f(g(x))<br></code></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">     <span class="hljs-keyword">lambda</span>            x            :          f(g(x))<br><span class="hljs-string">"A function that    takes x    and returns     f(g(x))"</span><br></code></pre></td></tr></tbody></table></figure><h2 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9 Function Decorators"></a>1.6.9 Function Decorators</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'-&gt; '</span>, fn, <span class="hljs-string">'('</span>, x, <span class="hljs-string">')'</span>)<br>            <span class="hljs-keyword">return</span> fn(x)<br>        <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@trace</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>triple(<span class="hljs-number">12</span>)<br>-&gt;  &lt;function triple at <span class="hljs-number">0x102a39848</span>&gt; ( <span class="hljs-number">12</span> )<br><span class="hljs-number">36</span><br></code></pre></td></tr></tbody></table></figure><p>相当于</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><br>triple = trace(triple)<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Week1</title>
    <link href="/2024/01/22/Project/cs61a/Week1/"/>
    <url>/2024/01/22/Project/cs61a/Week1/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><p><code>python3 ok --help</code>: 查看ok提示。</p><p><code>python3 ok -q python-basics -u</code></p><p><code>python3 ok</code>: 运行全部测试。</p><p><code>python3 ok --score</code>:查看分数。</p><p><code>python3 ok ... --local</code>:本地运行测试。</p><p><code>python3 -m doctest lab00.py</code>: 运行doctest。</p><h2 id="Hw1-Functions-Control"><a href="#Hw1-Functions-Control" class="headerlink" title="Hw1 Functions, Control"></a>Hw1 Functions, Control</h2><p><code>python3 ok -q a_plus_abs_b</code></p><p><code>python3 ok -q two_of_three</code></p><p>返回三个数中最小的两个数。先取min(i, j)得到较小的一个数，在从min(max(i, j), k)中得到第二小的数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">two_of_three</span>(<span class="hljs-params">i, j, k</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(i, j)**<span class="hljs-number">2</span> + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(i, j), k)**<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p><code>python3 ok -q largest_factor</code></p><p>返回能被整除的最大数。从1到n遍历，如果n%i==0即能够整除，返回最大值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">largest_factor</span>(<span class="hljs-params">n</span>):<br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>            res = i<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></tbody></table></figure><p><code>python3 ok -q hailstone</code></p><p>按照题意，偶数除以2，奇数*3+1操作，返回操作的次数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hailstone</span>(<span class="hljs-params">n</span>):<br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(n)<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>):<br>            n = n // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            n = n * <span class="hljs-number">3</span> + <span class="hljs-number">1</span><br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_chapter3 Page tables</title>
    <link href="/2024/01/11/Project/xv6/xv6_chapter3/"/>
    <url>/2024/01/11/Project/xv6/xv6_chapter3/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h2><p>xv6 runs on Sv39 RISC-V, 使用低39位来表示虚拟内存, 高25位没有使用。</p><p>39位中27位用作index来寻找PTE(Page table entry), 低12位表示在某个页表中的偏移地址, 正好对应4KB。每个PTE包含44bits的PPN(physical page number)和一些控制位。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240118220902.png" alt="Page table"></p><p>实际的RISC-V CPU翻译虚拟地址到物理地址使用了三层。每层存储512个PTE，分别使用9个bit来索引。上一层的一个PTE对应下一层包含512个PTE的Page table。所以总共有512*512*512=2^27 PTE。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240118221141.png" alt=" RISC-V address translation details"></p><p>每个CPU需要把顶层的page directory物理地址加载到 <code>satp</code> 寄存器中, 第一个Page Directory的地址是已知的。</p><p>然后通过L2索引到第一个Page directory的PTE，读出PTE的PPN, 即第二个Page directory的起始物理地址。再根据L1索引到第二个Page directory的PTE, 以此类推。</p><h2 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240118224444.png" alt="Kernel address space"></p><p>QEMU模拟RAM从0x80000000物理地址开始，至多到0x86400000，xv6称这个地址为<code>PHYSTOP</code>。</p><p>Kernel使用RAM和device registers是直接映射的，虚拟地址和物理地址相等。</p><p>不过有一部分kernel虚拟地址不是直接映射的：</p><ul><li>Trampoline page. 在虚拟地址的最顶部。这边有意思的是物理内存中的trampoline code被映射到了两个地方，一个对应直接映射的虚拟内存中的kernel text，另一个是虚拟地址最顶部地址的一个page size。有关Trampoline page请参考第四章。</li><li>Kernel stack pages. 每个进程都有自己的kernel stack。如果访问超过了自己的kernel stack。会有guard page保护，guard page的PTE valid位置为0，导致访问异常。</li></ul><h2 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3 Code: creating an address space"></a>3.3 Code: creating an address space</h2><p>TLB. 每个进程有自己的页表，切换进程时需要flush TLB, 因为之前VA-PA对应已经不成立了。通过RISC-V指令<code>sfence.vma</code>可以flush TLB。</p><h2 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5 Code: Physical memory allocator"></a>3.5 Code: Physical memory allocator</h2><p>分析下<code>kalloc.c</code>中的<code>kfree</code>和<code>kalloc</code>函数：</p><p>main中初始化内存free memory的时候会调用<code>kinit</code>函数，该函数对free memory区域调用<code>kfree</code>函数。</p><p><code>kmem.freelist</code>是全局变量的未初始化的指针，为NULL。</p><p>调用kfree：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240125144343.png"></p><p>调用kalloc：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240125144830.png"></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_lab2 System calls</title>
    <link href="/2024/01/04/Project/xv6/xv6_lab2_syscall/"/>
    <url>/2024/01/04/Project/xv6/xv6_lab2_syscall/</url>
    
    <content type="html"><![CDATA[<h2 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h2><p>实现系统调用<code>int trace(int mask);</code>, 当调用mask中包含的系统调用号，打印出来。</p><p>在Makefile中增加trace用户程序的编译</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">UPROGS=\<br>  ...<br>  $U/_trace<br></code></pre></td></tr></tbody></table></figure><p>在<code>user/user.h</code>中增加函数声明</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></tbody></table></figure><p>在<code>usys.pl</code>中增加user space <code>trace</code>函数的入口。可以看到user space调用的系统调用, 是由这个脚本生成的函数。<br>以trace为例, 提供了trace函数的入口<code>.global trace</code>, 随后将定义在<code>syscall.h</code>中的<code>SYS_trace</code>编号存入寄存器<code>a7</code>, 通过<code>ecall</code>命令进入内核态。</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">entry</span> </span>{<br>    <span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">".global $name\n"</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">"<span class="hljs-subst">${name}</span>:\n"</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">" li a7, SYS_<span class="hljs-subst">${name}</span>\n"</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">" ecall\n"</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">" ret\n"</span>;<br>}<br>entry(<span class="hljs-string">"trace"</span>);<br></code></pre></td></tr></tbody></table></figure><p>在<code>syscall.c</code>的<code>syscall</code>函数中通过获取<code>a6</code>寄存器中的编号，找到我们添加的系统调用函数，<code>sys_trace</code>。</p><p>函数具体实现如下:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在proc结构体中增加mask成员</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span><br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-type">int</span> mask;<br>}<br><br><span class="hljs-comment">// 将user space传入的mask，传递给当前进程的mask变量</span><br>uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;myproc()-&gt;mask) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 随后执行的系统调用number如果 (1 &lt;&lt; num == mask), 则打印</span><br>syscall(<span class="hljs-type">void</span>)<br>{<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; num) &amp; p-&gt;mask)<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: syscall %s -&gt; %d\n"</span>, p-&gt;pid, syscalls_name[num - <span class="hljs-number">1</span>], p-&gt;trapframe-&gt;a0);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>实现系统调用<code>int sysinfo(struct sysinfo *);</code>，返回free memory bytes和状态不是<code>UNUSED</code>的进程。</p><p>其中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> {</span><br>  uint64 freemem;   <span class="hljs-comment">// amount of free memory (bytes)</span><br>  uint64 nproc;     <span class="hljs-comment">// number of process</span><br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_chapter2 Operating system organization</title>
    <link href="/2024/01/04/Project/xv6/xv6_chapter2/"/>
    <url>/2024/01/04/Project/xv6/xv6_chapter2/</url>
    
    <content type="html"><![CDATA[<h2 id="2-6-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-6-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.6 Code: starting xv6, the first process and system call"></a>2.6 Code: starting xv6, the first process and system call</h2><p>启动代码:<br><code>entry.S</code> 为每个CPU设置堆栈，然后跳进<code>start.c</code>的start函数。</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile">  <span class="hljs-comment"># qemu -kernel loads the kernel at 0x80000000</span><br>        <span class="hljs-comment"># and causes each CPU to jump there.</span><br>        <span class="hljs-comment"># kernel.ld causes the following code to</span><br>        <span class="hljs-comment"># be placed at 0x80000000.</span><br>.section .text<br>.global _entry<br><span class="hljs-section">_entry:</span><br>  <span class="hljs-comment"># set up a stack for C.</span><br>        <span class="hljs-comment"># stack0 is declared in start.c,</span><br>        <span class="hljs-comment"># with a 4096-byte stack per CPU.</span><br>        <span class="hljs-comment"># sp = stack0 + (hartid * 4096)</span><br>        la sp, stack0<br>        li a0, 1024*4<br>  csrr a1, mhartid <span class="hljs-comment"># CPUs 0~7 has hartid from 0~7</span><br>        addi a1, a1, 1<br>        mul a0, a0, a1<br>        add sp, sp, a0<br>  <span class="hljs-comment"># jump to start() in start.c</span><br>        call start<br><span class="hljs-section">spin:</span><br>        j spin<br></code></pre></td></tr></tbody></table></figure><br><p><code>start.c</code> 调用<code>mret</code>, 从machine mode进入supervisor mode。跳转至<code>mepc</code>中存入的main函数地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();<br>  x &amp;= ~MSTATUS_MPP_MASK;<br>  x |= MSTATUS_MPP_S;<br>  w_mstatus(x);<br><br>  w_mepc((uint64)main);<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">"mret"</span>)</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><br><p><code>main.c</code> userinit()中创建第一个进程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-comment">// ...</span><br>  userinit();<br>}<br></code></pre></td></tr></tbody></table></figure><br><p><code>userinit.c</code> <code>uvminit</code>把<code>uchar initcode[]</code> 即<code>user/initcode.S</code>编译出来的<code>initcode</code>可执行程序加载进进程的页表中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  p = allocproc();<br><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));<br>}<br><br></code></pre></td></tr></tbody></table></figure><br><p>接着<code>initcode</code>会执行系统调用<code>exec</code>执行<code>/init</code>用户程序。</p><p><code>initcode.S</code></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># exec(init, argv)</span><br>.globl start<br><span class="hljs-section">start:</span><br>        la a0, init<br>        la a1, argv<br>        li a7, SYS_exec<br>        ecall<br><br></code></pre></td></tr></tbody></table></figure><p>最终在<code>init.c</code>中调用<code>fork()</code>在子进程中执行shell进程<code>exec("sh", argv);</code>,父进程则进入死循环。</p><h2 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3 Code: Calling system calls"></a>4.3 Code: Calling system calls</h2><p><code>initcode.S</code> 把执行<code>exec</code>的参数存放在<code>a0</code>,<code>a1</code>寄存器中, 把system call编号存在<code>a7</code>寄存器中。随后<code>ecall</code>指令会trap into kernel, 导致进入<code>uservec</code>和<code>usertrap</code>函数, 最后调用到<code>sys_exec</code>函数。</p><h2 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4 Code: System call arguments"></a>4.4 Code: System call arguments</h2><p>User space通过系统调用进入kernel space, 参数保存在current process当前进程的trap frame中。<br>比如<code>exit(0)</code>, 0会被保存到<code>a0</code>寄存器，随后会被kernel保存到<code>p-&gt;trapframe-&gt;a0</code>。</p><p><code>argint</code>, <code>argaddr</code>, <code>argfd</code>函数从当前进程的trap frame中读取传入的参数。</p><br><p>如果user space传入指针，会有两个问题。</p><ol><li>user space可能传入invalid address或者是企图访问kernel memory的恶意指针。</li><li>xv6 kernel page table和user space的page table mapping不同，所以同一个虚拟地址对应的物理地址是不同的。</li></ol><p>这时候需要用<code>copyinstr</code>函数。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_lab1 Unix utilities</title>
    <link href="/2023/12/30/Project/xv6/xv6_lab1_util/"/>
    <url>/2023/12/30/Project/xv6/xv6_lab1_util/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6_chapter1 Operating system interfaces</title>
    <link href="/2023/12/30/Project/xv6/xv6_chapter1/"/>
    <url>/2023/12/30/Project/xv6/xv6_chapter1/</url>
    
    <content type="html"><![CDATA[<p>XV6 实现的所有系统调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> <span class="hljs-comment">//Create a process, return child’s PID.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> <span class="hljs-comment">//Terminate the current process; status reported to wait(). No return.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span> <span class="hljs-comment">//Wait for a child to exit; exit status in *status; returns child PID.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> <span class="hljs-comment">//Terminate process PID. Returns 0, or -1 for error.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">()</span> <span class="hljs-comment">//Return the current process’s PID.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//Pause for n clock ticks.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *argv[])</span> <span class="hljs-comment">//Load a file and execute it with arguments; only returns if error.</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//Grow process’s memory by n bytes. Returns start of new memory.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *file, <span class="hljs-type">int</span> flags)</span> <span class="hljs-comment">//Open a file; flags indicate read/write; returns an fd (file descriptor).</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//Write n bytes from buf to file descriptor fd; returns n.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//Read n bytes into buf; returns number read; or 0 if end of file.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> <span class="hljs-comment">//Release open file fd.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> <span class="hljs-comment">//Return a new file descriptor referring to the same file as fd.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span> <span class="hljs-comment">//Create a pipe, put read/write file descriptors in p[0] and p[1].</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir)</span> <span class="hljs-comment">//Change the current directory.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir)</span> <span class="hljs-comment">//Create a new directory.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">char</span> *file, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span> <span class="hljs-comment">//Create a device file.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *st)</span> <span class="hljs-comment">//Place info about an open file into *st.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">char</span> *file, <span class="hljs-keyword">struct</span> stat *st)</span> <span class="hljs-comment">//Place info about a named file into *st.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">char</span> *file1, <span class="hljs-type">char</span> *file2)</span> <span class="hljs-comment">//Create another name (file2) for the file file1.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">char</span> *file)</span> <span class="hljs-comment">//Remove a file.</span><br></code></pre></td></tr></tbody></table></figure><p><code>pid_t fork(void)</code><br>创建一个新进程，拥有相同的memory内容(包括instruction和data)。Parent进程返回child进程的PID, Child进程返回0。</p><p><code>void exit(int status)</code><br>停止当前进程，通常成功返回0，失败返回1。</p><p><code>pid_t wait(int *status)</code><br>Block等待子进程退出。返回退出的子进程PID, 并把子进程exit()的status写入int *status。<br>没有没有子进程立即返回-1。如果不关心退出的状态可以传入0的地址<code>wait((int *)0)</code>。</p><p><code>int exec(char *file, char *argv[])</code><br>file为传入的ELF可执行文件, argv为传入的参数，通常argv[0]为可执行文件名，argv[last]为0，表示字符串结束。</p><p><code>read()</code><br><code>write()</code></p><p><code>dup()</code><br><code>pipe()</code></p><h2 id="1-2-I-x2F-O-and-File-descriptors"><a href="#1-2-I-x2F-O-and-File-descriptors" class="headerlink" title="1.2 I/O and File descriptors"></a>1.2 I/O and File descriptors</h2><p>file descriptor:</p><ul><li>0: 标准输入</li><li>1: 标准输出</li><li>2: 标准错误</li></ul><p><code>read(fd, buf, n)</code>, <code>write(fd, buf, n)</code> 会维护一个偏移地址，下次R/W会从偏移地址开始。</p><p>read函数返回读取的bytes数，如果没有bytes可读了就返回0。<br>write函数返回写入的bytes数，如果写入的bytes小于n，只会是错误发生了。</p><p>A newly allocated file descriptor is always the lowestnumbered unused descriptor of the current process。<br>最新打开的文件描述符一定是最小的未被使用的文件描述符。</p><p>这段代码会把输入给cat的内容传入input.txt，此时input.txt的文件描述符对应标准输入0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">"cat"</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) {<br>  close(<span class="hljs-number">0</span>);<br>  open(<span class="hljs-string">"input.txt"</span>, O_RDONLY);<br>  exec(<span class="hljs-string">"cat"</span>, argv);<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>fork</code>后，read/write函数仍然共享文件偏移地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) {<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">"hello "</span>, <span class="hljs-number">6</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>} <span class="hljs-keyword">else</span> {<br>  wait(<span class="hljs-number">0</span>);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">"world\n"</span>, <span class="hljs-number">6</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>int dup(int fd)</code>函数会返回一个该文件新的描述符，通过两个文件描述符都能访问，也共享文件offset。</p><h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h2><p><code>int pipe(int filedes[2])</code></p><p>返回两个文件描述符保存在filedes数组中，filedes[0]为管道的读取端，filedes[1]为管道的写入端。</p><p>如果数据没有准备好，那么对管道执行的read会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。在后一种情况中，read 会返回 0。<br>这就是为什么我们在执行 wc 之前要关闭子进程的写端口。如果 wc 指向了一个管道的写端口，那么 wc 就永远看不到 eof 了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">"wc"</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p);<br><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) {<br>  close(<span class="hljs-number">0</span>);<br>  dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 副本文件描述符p[0]（管道的读端）到文件描述符0的位置（因为0已经被关闭了，dup默认会使用最低的未用文件描述符，即0）。</span><br>  close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读写管道，这两个管道不再需要了，下面wc会使用dup出来的fd0。</span><br>  close(p[<span class="hljs-number">1</span>]);<br>  exec(<span class="hljs-string">"/bin/wc"</span>, argv);<br>} <span class="hljs-keyword">else</span> {<br>  close(p[<span class="hljs-number">0</span>]);<br>  write(p[<span class="hljs-number">1</span>], <span class="hljs-string">"hello world\n"</span>, <span class="hljs-number">12</span>);<br>  close(p[<span class="hljs-number">1</span>]);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h2><p><code>chdir</code>函数可以改变当前目录。</p><p>将当前目录切换到 <code>/a/b</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">chdir(<span class="hljs-string">"/a"</span>);<br>chdir(<span class="hljs-string">"b"</span>);<br></code></pre></td></tr></tbody></table></figure><p><code>fstat(int fildes, struct stat *buf)</code>函数可以获取一个文件描述符指向的inode信息。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1 <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2 <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3 <span class="hljs-comment">// Device</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> {</span><br>  <span class="hljs-type">int</span> dev; <span class="hljs-comment">// File system’s disk device</span><br>  uint ino; <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">short</span> type; <span class="hljs-comment">// Type of file</span><br>  <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>  uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>一个文件可以有多个名字，但inode只有一个。可以调用<code>link</code>函数创建多个文件名指向同一个文件inode。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">"a"</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>);<br><br>unlink(<span class="hljs-string">"a"</span>); <span class="hljs-comment">// nlink -= 1, 等于0时</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6 OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Pinctrl Subsystem</title>
    <link href="/2023/12/25/Note/Zephyr/Driver/23-12-21_Pinctrl/"/>
    <url>/2023/12/25/Note/Zephyr/Driver/23-12-21_Pinctrl/</url>
    
    <content type="html"><![CDATA[<h2 id="Device-Tree"><a href="#Device-Tree" class="headerlink" title="Device Tree"></a>Device Tree</h2><p>Pinctrl controller节点：</p><p>所有可选的支持属性可以查阅<code>/dts/bindings/pinctrl/pincfg-node.yaml</code>，支持配置上下拉，驱动能力等等。具体支持属性要参考soc的yaml文件<code>/dts/bindings/pinctrl/xxx.yaml</code></p><p>当设备节点调用<code>perip0_default</code>的时候，<code>group1~N</code>都会被apply。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board-pinctrl.dtsi */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vnd-soc-pkgxx.h&gt;</span></span><br><br>&amp;pinctrl {<br>    <span class="hljs-comment">/* Node with pin configuration for default state */</span><br>    periph0_default: periph0_default {<br>        group1 {<br>            <span class="hljs-comment">/* Mappings: PERIPH0_SIGA -&gt; PX0, PERIPH0_SIGC -&gt; PZ1 */</span><br>            pinmux = &lt;PERIPH0_SIGA_PX0&gt;, &lt;PERIPH0_SIGC_PZ1&gt;;<br>            <span class="hljs-comment">/* Pins PX0 and PZ1 have pull-up enabled */</span><br>            bias-pull-up;<br>        };<br>        ...<br>        groupN {<br>            <span class="hljs-comment">/* Mappings: PERIPH0_SIGB -&gt; PY7 */</span><br>            pinmux = &lt;PERIPH0_SIGB_PY7&gt;;<br>        };<br>    };<br>};<br></code></pre></td></tr></tbody></table></figure><p>使用pinctrl的设备节点：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>&amp;periph0 {<br>    pinctrl<span class="hljs-number">-0</span> = &lt;&amp;periph0_default&gt;;<br>    pinctrl-names = <span class="hljs-string">"default"</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以在pinctrl controller下面的pinctrl配置节点前加上<code>/omit-if-no-ref/</code>，表示这个节点没被引用的话会被丢弃，不会被解析到C头文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;pinctrl {<br>    /omit-<span class="hljs-keyword">if</span>-no-ref/ periph0_siga_px0_default: periph0_siga_px0_default {<br>        pinmux = &lt;VNDSOC_PIN(X, <span class="hljs-number">0</span>, MUX0)&gt;;<br>    };<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>Device driver如何使用pinctrl配置引脚function:</p><p>以<code>i2c_dw.c</code>为例，<br>通过<code>PINCTRL_DT_INST_DEFINE(n)</code>, 创建该device对应的<code>pinctrl_dev_config</code>结构体。<br>通过<code>PINCTRL_DT_INST_DEV_CONFIG_GET(n)</code> 得到该<code>pinctrl_dev_config</code>结构体。</p><p>随后在init函数中调用<code>pinctrl_apply_state(rom-&gt;pcfg, PINCTRL_STATE_DEFAULT);</code>选择apply default的pinctrl配置。</p><p>如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_DRV_COMPAT mydev</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;zephyr/drivers/pinctrl.h&gt;</span></span><br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydev_config</span> {</span><br>    ...<br>    <span class="hljs-comment">/* Reference to mydev pinctrl configuration */</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_dev_config</span> *<span class="hljs-title">pcfg</span>;</span><br>    ...<br>};<br>...<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mydev_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev)</span><br>{<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydev_config</span> *<span class="hljs-title">config</span> =</span> dev-&gt;config;<br>    <span class="hljs-type">int</span> ret;<br>    ...<br>    <span class="hljs-comment">/* Select "default" state at initialization time */</span><br>    ret = pinctrl_apply_state(config-&gt;pcfg, PINCTRL_STATE_DEFAULT);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> ret;<br>    }<br>    ...<br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYDEV_DEFINE(i)                                                    \</span><br><span class="hljs-meta">    <span class="hljs-comment">/* Define all pinctrl configuration for instance "i" */</span>                \</span><br><span class="hljs-meta">    PINCTRL_DT_INST_DEFINE(i);                                             \</span><br><span class="hljs-meta">    ...                                                                    \</span><br><span class="hljs-meta">    static const struct mydev_config mydev_config_##i = {                  \</span><br><span class="hljs-meta">        ...                                                                \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Keep a ref. to the pinctrl configuration for instance "i" */</span>    \</span><br><span class="hljs-meta">        .pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                         \</span><br><span class="hljs-meta">        ...                                                                \</span><br><span class="hljs-meta">    };                                                                     \</span><br><span class="hljs-meta">    ...                                                                    \</span><br><span class="hljs-meta">                                                                           \</span><br><span class="hljs-meta">    DEVICE_DT_INST_DEFINE(i, mydev_init, NULL, &amp;mydev_data##i,             \</span><br><span class="hljs-meta">                          &amp;mydev_config##i, ...);</span><br><br>DT_INST_FOREACH_STATUS_OKAY(MYDEV_DEFINE)<br></code></pre></td></tr></tbody></table></figure><p>分析下<code>PINCTRL_DT_DEFINE</code>这个宏，</p><figure class="highlight c"><figcaption><span>{.line-numbers}</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PINCTRL_DT_DEFINE(node_id)                 \</span><br><span class="hljs-meta">  LISTIFY(DT_NUM_PINCTRL_STATES(node_id),       \</span><br><span class="hljs-meta">         Z_PINCTRL_STATE_PINS_DEFINE, (;), node_id);       \</span><br><span class="hljs-meta">  Z_PINCTRL_STATES_DEFINE(node_id)       \</span><br><span class="hljs-meta">  Z_PINCTRL_DEV_CONFIG_STATIC Z_PINCTRL_DEV_CONFIG_CONST       \</span><br><span class="hljs-meta">  struct pinctrl_dev_config Z_PINCTRL_DEV_CONFIG_NAME(node_id) =       \</span><br><span class="hljs-meta">  Z_PINCTRL_DEV_CONFIG_INIT(node_id)</span><br></code></pre></td></tr></tbody></table></figure><br><p>2~3行针对dts某个device节点，有N个<code>pinctrl-&lt;N&gt;</code>就调用<code>Z_PINCTRL_STATE_PINS_DEFINE</code>函数，创建包含N个<code>pinctrl_soc_pin_t</code>结构体的数组, 每个结构体包含该<code>pinctrl-&lt;N&gt;</code>对应pinctrl controller节点所需要的pins。该结构体数组的具体创建过程由<code>Z_PINCTRL_STATE_PINS_INIT</code>决定，该宏需要不同厂商在<code>pinctrl_soc.h</code>中定义。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_soc_pin_t</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-comment">// need to define in `pinctrl_soc.h`</span><br>}<br></code></pre></td></tr></tbody></table></figure><br><p>第4行，根据N个<code>pinctrl-&lt;N&gt;</code>创建<code>pinctrl_state</code>结构体数组，从<code>devicetree_generated.h</code>中获取结构体信息。</p><p>每个<code>pinctrl_state</code>结构体：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_state</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">pinctrl_soc_pin_t</span> *pins; <span class="hljs-comment">// 对应上面2~3行创建的`pinctrl_soc_pin_t`结构体数组。</span><br>  <span class="hljs-type">uint8_t</span> pin_cnt; <span class="hljs-comment">// 该state包含多少个pin。</span><br>  <span class="hljs-type">uint8_t</span> id = PINCTRL_STATE_XXX; <span class="hljs-comment">// XXX可以是DEFAULT,SLEEP或自定义属性。</span><br>};<br></code></pre></td></tr></tbody></table></figure><br><p>第5~7行，初始化一个<code>pinctrl_dev_config</code>结构体。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_dev_config</span> {</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_PINCTRL_STORE_REG) || defined(__DOXYGEN__)</span><br>  <span class="hljs-type">uintptr_t</span> reg; <span class="hljs-comment">// 该device的reg地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_state</span> *<span class="hljs-title">states</span>;</span> <span class="hljs-comment">// 即上面的`pinctrl_state`结构体数组。</span><br>  <span class="hljs-type">uint8_t</span> state_cnt; <span class="hljs-comment">// 包含的state数量。</span><br>};<br></code></pre></td></tr></tbody></table></figure><br><p>结构体关系如下, 其中<br><code>pinctrl_dev_config</code> 是每个device拥有一个。<br><code>pinctrl_state</code> 对应每个device的一个pinctrl state, 即dts中的<code>pinctrl-&lt;N&gt;</code>。<br><code>pinctrl_soc_pin_t</code> 对应一个pin，包含了pin number, config配置信息等。<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/pinctrl.png" alt="Pinctrl 结构体"></p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Pinctrl Driver实现:<br>主要需要实现回调函数<code>pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt, uintptr_t reg)</code>。<br><code>pinctrl_soc_pin_t *pins</code>：某个pinctrl state包含的pins链表。<br><code>pin_cnt</code>：该state包含的pins数量。<br><code>reg</code>: pinctrl controller的地址。</p><p>添加<code>pinctrl_soc.h</code>, 一般路径为<code>soc/&lt;arch&gt;/&lt;vendor&gt;/&lt;board&gt;/...</code><br>在其中定义<code>pinctrl_soc_pin_t</code> 结构体。<code>Z_PINCTRL_STATE_PINS_INIT</code>宏，该宏接收两个参数，设备树node identifier和property name(pinctrl-N)，用来解析设备树属性。</p><p>参考ti-cc32xx pinctrl的实现，参考文件有：<br><code>dts/bindings/pinctrl/ti,cc32xx-pinctrl.yaml</code>：描述设备树属性。<br><code>soc/arm/ti_simplelink/cc32xx/pinctrl_soc.h</code>: 具体实现。<br><code>include/zephyr/dt-bindings/pinctrl/ti-cc32xx-pinctrl.h</code>：头文件。<br><code>boards/arm/cc3220sf_launchxl/cc3220sf_launchxl-pinctrl.dtsi</code>: pinctrl设备树。<br><code>drivers/pinctrl/pinctrl_ti_cc32xx.cpinctrl_nrf.c</code>: pinctrl driver。</p><br><p><code>pinctrl.dtsi</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;pinctrl {<br>  uart0_default: uart0_default {<br>    group1 {<br>      pinmux = &lt;UART0_TX_P55&gt;, &lt;UART0_RX_P57&gt;;<br>    };<br>  };<br><br>  i2c0_default: i2c0_default {<br>    group1 {<br>      pinmux = &lt;I2C_SCL_P1&gt;, &lt;I2C_SDA_P2&gt;;<br>    };<br>  };<br>};<br><br>&amp;uart0 {<br>  pinctrl<span class="hljs-number">-0</span> = &lt;&amp;uart0_default&gt;;<br>  pinctrl-names = <span class="hljs-string">"default"</span>;<br>};<br><br>&amp;i2c0 {<br>  pinctrl<span class="hljs-number">-0</span> = &lt;&amp;i2c0_default&gt;;<br>  pinctrl-names = <span class="hljs-string">"default"</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><br><p><code>pinctrl_soc.h</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Z_PINCTRL_STATE_PINS_INIT(node_id, prop)                                                   \</span><br><span class="hljs-meta">  {                                                                                          \</span><br><span class="hljs-meta">    DT_FOREACH_CHILD_VARGS(DT_PHANDLE(node_id, prop), DT_FOREACH_PROP_ELEM, pinmux,    \</span><br><span class="hljs-meta">               Z_PINCTRL_STATE_PIN_INIT)                                   \</span><br><span class="hljs-meta">  }</span><br></code></pre></td></tr></tbody></table></figure><p>上层调用传入的<code>node_id</code>对应使用pinctrl的设备节点，<code>prop</code>对应<code>pinctrl-0,1...</code></p><p><code>DT_FOREACH_CHILD_VARGS</code>会遍历<code>pinctrl-X</code>引用的phandle下的<code>group1~n</code>，这里这个名称可以是任意值，因为会遍历所有子节点，对<code>pinmux</code>属性调用<code>Z_PINCTRL_STATE_PIN_INIT</code>函数，每个pin创建一个<code>pinctrl_soc_pin_t</code>结构体。</p><br><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">pinctrl_soc_pin_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Z_PINCTRL_STATE_PIN_INIT(node_id, prop, idx)                                               \</span><br><span class="hljs-meta">  (DT_PROP_BY_IDX(node_id, prop, idx) |                                                      \</span><br><span class="hljs-meta">   (TI_CC32XX_OPEN_DRAIN * DT_PROP(node_id, drive_open_drain)) |                             \</span><br><span class="hljs-meta">   (TI_CC32XX_PULL_UP * DT_PROP(node_id, bias_pull_down)) |                                  \</span><br><span class="hljs-meta">   (TI_CC32XX_PULL_DOWN * DT_PROP(node_id, bias_pull_up)) |                                  \</span><br><span class="hljs-meta">   ((DT_ENUM_IDX(node_id, drive_strength) &amp; TI_CC32XX_DRIVE_STRENGTH_MSK)                    \</span><br><span class="hljs-meta">    &lt;&lt; TI_CC32XX_DRIVE_STRENGTH_POS) |                                                       \</span><br><span class="hljs-meta">   TI_CC32XX_PAD_OUT_OVERRIDE | TI_CC32XX_PAD_OUT_BUF_OVERRIDE),</span><br></code></pre></td></tr></tbody></table></figure><p><code>DT_PROP_BY_IDX(node_id, prop, idx)</code>: 从设备树pinmux prop中获取值，比如<code>&lt;UART0_TX_P55&gt;</code>, <code>&lt;UART0_RX_P57&gt;</code>，这些宏定义在<code>ti-cc32xx-pinctrl.h</code>中，前面<code>UART0_TX</code>表示mux function，后面<code>P55</code>表示第55个pin。mux function保存在bit0<del>3, pin offset保存在bit16</del>21。</p><p><code>(TI_CC32XX_OPEN_DRAIN * DT_PROP(node_id, drive_open_drain))</code> 判断设备中某个group中是否有属性<code>drive_open_drain</code>, 保存在<code>TI_CC32XX_OPEN_DRAIN</code>, bit4中。</p><p>其他几个属性同理，一样保存进<code>pinctrl_soc_pin_t</code>的bitmap中。</p><p>排列顺序如下图，这里的位置应该对应的ti pinctrol寄存器。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240131145556.png"></p><br><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pinctrl_configure_pin</span><span class="hljs-params">(<span class="hljs-type">pinctrl_soc_pin_t</span> pincfg)</span><br>{<br>  <span class="hljs-type">uint8_t</span> pin;<br><br>  pin = (pincfg &gt;&gt; TI_CC32XX_PIN_POS) &amp; TI_CC32XX_PIN_MSK;<br>  <span class="hljs-keyword">if</span> ((pin &gt;= ARRAY_SIZE(pin2pad)) || (pin2pad[pin] == <span class="hljs-number">255U</span>)) {<br>    <span class="hljs-keyword">return</span> -EINVAL;<br>  }<br><br>  sys_write32(pincfg &amp; MEM_GPIO_PAD_CONFIG_MSK, DT_INST_REG_ADDR(<span class="hljs-number">0</span>) + (pin2pad[pin] &lt;&lt; <span class="hljs-number">2U</span>));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着在<code>pinctrl_ti_cs32xx.c</code>中，<code>pinctrl_configure_pin</code>函数，根据pin offset将其他配置写进对应的寄存器中。</p><p>对应的fingerprint项目的pad register，可以实现的<code>pinctrl_soc_pin_t</code>可以参考：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20240131150328.png"></p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- System  Call</title>
    <link href="/2023/12/18/Note/Zephyr/Kernel/23-12-18_UserMode/"/>
    <url>/2023/12/18/Note/Zephyr/Kernel/23-12-18_UserMode/</url>
    
    <content type="html"><![CDATA[<h2 id="C-Prototype"><a href="#C-Prototype" class="headerlink" title="C Prototype"></a>C Prototype</h2><p>系统调用函数必须以<code>__syscall</code>开头，在<code>include/</code>或<code>SYSCALL_INCLUDE_DIRS</code>目录下被声明。</p><p><code>scripts/build/parse_syscalls.py</code>会parse<code>__syscall</code>这个标记，并且函数有以下限制：</p><ul><li>参数不能传入数组，比如<code>int foo[]</code> or <code>int foo[12]</code>, 必须用<code>int *foo</code>代替。</li><li>函数指针不能正常解析，需要先对函数指针<code>typedef</code>，再传入。</li></ul><p>定义了系统调用的<code>xxx.h</code>头文件必须要文件末尾加上同名的<code>#include &lt;syscall/xxx.h&gt;</code>。</p><h3 id="Invocation-Context-调用上下文"><a href="#Invocation-Context-调用上下文" class="headerlink" title="Invocation Context 调用上下文"></a>Invocation Context 调用上下文</h3><ul><li>如果定义了<code>CONFIG_USERSPACE</code>，所有的system call APIs都会直接调用对应的implementation function。</li><li>如果定义了<code>__ZEPHYR_SUPERVISOR__</code>，表示所有code都在supervisor mode下运行，直接调用对应的implementation function。</li><li>如果定义了<code>__ZEPHYR_USER__</code></li></ul><h3 id="Implementation-Detail-实现细节"><a href="#Implementation-Detail-实现细节" class="headerlink" title="Implementation Detail 实现细节"></a>Implementation Detail 实现细节</h3><p><code>scripts/build/gencalls.py</code>会把parse到的system calls放进<code>/build/include/generated/syscall_list.h</code>中。以<code>K_SYSCALL_</code>前缀加上API。</p><p>所有可以调用的system calls被保存在<code>syscall_dispatch.c</code>中的<code>_k_syscall_table</code>中。</p><p>system calls的API实现被保存在了<code>/build/include/generated/syscalls/xxx.h</code> 这些文件被<code>/include/xxx.h</code>文件最后include进去，完成函数的定义。e.g</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/i2c.h</span><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint32_t</span> dev_config)</span>; <span class="hljs-comment">//声明</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">z_impl_i2c_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev,</span><br><span class="hljs-params">               <span class="hljs-type">uint32_t</span> dev_config)</span><br>{<br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver_api</span> *<span class="hljs-title">api</span> =</span><br>    (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_driver_api *)dev-&gt;api;<br><br>  <span class="hljs-keyword">return</span> api-&gt;configure(dev, dev_config);<br>}<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscalls/i2c.h&gt;</span></span><br><br><span class="hljs-comment">// build/include/generated/syscalls/i2c.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">z_impl_i2c_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device * dev, <span class="hljs-type">uint32_t</span> dev_config)</span>;<br><br>__pinned_func<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device * dev, <span class="hljs-type">uint32_t</span> dev_config)</span><br>{<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_USERSPACE</span><br>        <span class="hljs-keyword">if</span> (z_syscall_trap()) {<br>                <span class="hljs-class"><span class="hljs-keyword">union</span> {</span> <span class="hljs-type">uintptr_t</span> x; <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> * <span class="hljs-title">val</span>;</span> } parm0 = { .val = dev };<br>                <span class="hljs-class"><span class="hljs-keyword">union</span> {</span> <span class="hljs-type">uintptr_t</span> x; <span class="hljs-type">uint32_t</span> val; } parm1 = { .val = dev_config };<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_I2C_CONFIGURE);<br>        }<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        compiler_barrier();<br>        <span class="hljs-keyword">return</span> z_impl_i2c_configure(dev, dev_config);<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- SPI framework</title>
    <link href="/2023/12/15/Note/Zephyr/Driver/23-12-18_SPI/"/>
    <url>/2023/12/15/Note/Zephyr/Driver/23-12-18_SPI/</url>
    
    <content type="html"><![CDATA[<h2 id="DeviceTree"><a href="#DeviceTree" class="headerlink" title="DeviceTree"></a>DeviceTree</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">spi0: spi@f0020000 {<br>  compatible = <span class="hljs-string">"snps,designware-spi"</span>;<br>  <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>  <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>  reg = &lt;<span class="hljs-number">0xf0020000</span> <span class="hljs-number">0x100</span>&gt;;<br>  interrupts = &lt;<span class="hljs-number">40</span> <span class="hljs-number">1</span>&gt;;<br>        pinctrl<span class="hljs-number">-0</span> = &lt;&amp;spi2_default&gt;;<br>        pinctrl<span class="hljs-number">-1</span> = &lt;&amp;spi2_sleep&gt;;<br>        pinctrl-names = <span class="hljs-string">"default"</span>, <span class="hljs-string">"sleep"</span>;<br>  fifo-depth = &lt;<span class="hljs-number">32</span>&gt;; <span class="hljs-comment">// 必须参数</span><br>  clocks = &lt;&amp;sysclk&gt;; <span class="hljs-comment">// 和下面clock-frequency二选一，优先从&amp;sysclk中获取clock-frequency</span><br>  clock-frequency = &lt;<span class="hljs-number">200000000</span>&gt;;<br>        cs-gpios = &lt;&amp;gpio0 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">// 用gpio代替cs，可选参数</span><br>  status = <span class="hljs-string">"disabled"</span>;<br><br>  slow@<span class="hljs-number">0</span> { <span class="hljs-comment">// spi设备</span><br>    compatible = <span class="hljs-string">"test-spi-loopback-slow"</span>;<br>    reg = &lt;<span class="hljs-number">0</span>&gt;;<br>    spi-max-frequency = &lt;<span class="hljs-number">500000</span>&gt;;<br>  };<br>  fast@<span class="hljs-number">0</span> { <span class="hljs-comment">// @x 是指第几根片选</span><br>    compatible = <span class="hljs-string">"test-spi-loopback-fast"</span>;<br>    reg = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">// 0表示spi master controller，1表示spi slave controller</span><br>    spi-max-frequency = &lt;<span class="hljs-number">1000000</span>&gt;;<br>  };<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="Consumer-应用层和其他driver如何调用spi接口"><a href="#Consumer-应用层和其他driver如何调用spi接口" class="headerlink" title="Consumer(应用层和其他driver如何调用spi接口)"></a>Consumer(应用层和其他driver如何调用spi接口)</h2><p><strong>方法1：</strong></p><p>设备树API</p><p>参考<code>zephyr/tests/drivers/spi/spi_loopback/src/spi.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取spi device node id</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_DEV  DT_COMPAT_GET_ANY_STATUS_OKAY(test_spi_loopback) <span class="hljs-comment">//这里注意是spi device的compatible，不是bus</span></span><br><br><span class="hljs-comment">// 定义spi controller属性</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_OP(frame_size) SPI_OP_MODE_MASTER | SPI_MODE_CPOL | MODE_LOOP | \</span><br><span class="hljs-meta">         SPI_MODE_CPHA | SPI_WORD_SET(frame_size) | SPI_LINES_SINGLE</span><br><br><span class="hljs-comment">//传入spi device node id和config,通过SPI_DT_SPEC_GET宏从设备树获得spi_dt_spec结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_dt_spec</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">bus</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_config</span> <span class="hljs-title">config</span>;</span><br>};<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_DT_SPEC_GET(node_id, operation_, delay_)         \</span><br><span class="hljs-meta">  {     \</span><br><span class="hljs-meta">    .bus = DEVICE_DT_GET(DT_BUS(node_id)),     \</span><br><span class="hljs-meta">    .config = SPI_CONFIG_DT(node_id, operation_, delay_) \</span><br><span class="hljs-meta">  }</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_dt_spec</span> <span class="hljs-title">spi</span> =</span> SPI_DT_SPEC_GET(SPI_DEV, SPI_OP(FRAME_SIZE), <span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><p>接着需要初始化<code>spi_buf_set *tx_bufs</code>和<code>spi_buf_set *rx_bufs</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_buf</span> <span class="hljs-title">tx_bufs</span>[] =</span> {<br>  {<br>    .buf = buffer_tx,<br>    .len = BUF_SIZE,<br>  },<br>};<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_buf</span> <span class="hljs-title">rx_bufs</span>[] =</span> {<br>  {<br>    .buf = buffer_rx,<br>    .len = BUF_SIZE,<br>  },<br>};<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_buf_set</span> <span class="hljs-title">tx</span> =</span> {<br>  .buffers = tx_bufs,<br>  .count = ARRAY_SIZE(tx_bufs)<br>};<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spi_buf_set</span> <span class="hljs-title">rx</span> =</span> {<br>  .buffers = rx_bufs,<br>  .count = ARRAY_SIZE(rx_bufs)<br>};<br></code></pre></td></tr></tbody></table></figure><p>最后可以调用spi_transceive_dt进行spi传输了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_transceive_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_dt_spec *spec,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_buf_set *tx_bufs,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_buf_set *rx_bufs)</span><br></code></pre></td></tr></tbody></table></figure><p>结束spi传输后需要调用<code>spi_release_dt</code>来做收尾工作。</p><p><strong>方法2：</strong><br>直接调用<code>spi_transceive</code>，这时候<code>dev</code>, <code>config</code>参数需要我们自己准备了。</p><p class="note note-warning">不过这两个函数是`__syscall`,而上面devicetree的API不是，是否意味着user space只能调用下面这两个函数？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">spi_transceive</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev,</span><br><span class="hljs-params">           <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_config *config,</span><br><span class="hljs-params">           <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_buf_set *tx_bufs,</span><br><span class="hljs-params">           <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_buf_set *rx_bufs)</span>;<br><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">spi_release</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev,</span><br><span class="hljs-params">        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> spi_config *config)</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="Provider-SSI-driver"><a href="#Provider-SSI-driver" class="headerlink" title="Provider(SSI driver)"></a>Provider(SSI driver)</h2><p>SSI Master Flow:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// spi_dw_init</span><br>write_imr(info, DW_SPI_IMR_MASK); <span class="hljs-comment">// SSI_IMR(0x2C) write 0</span><br>clear_bit_ssienr(info); <span class="hljs-comment">// SSI_ENR(0x08) write 0</span><br><br><span class="hljs-comment">// spi_dw_configure</span><br>write_ctrlr0(info, ctrlr0); <span class="hljs-comment">// SSI_CTRLR0(0x00) 写入上层指定的config，包括bit0-3,6,7,11。</span><br>write_baudr(info, SPI_DW_CLK_DIVIDER(info-&gt;clock_frequency, config-&gt;frequency)) <span class="hljs-comment">// SSI_BAUDR(0x14) baud rate</span><br>write_ser(info, <span class="hljs-number">1</span> &lt;&lt; config-&gt;slave); <span class="hljs-comment">// SSI_SER(0x10) write 0</span><br><br><span class="hljs-comment">// transceive</span><br>write_ctrlr1(info, reg_data); or <span class="hljs-title function_">write_ctrlr1</span><span class="hljs-params">(info, <span class="hljs-number">0</span>)</span>; <span class="hljs-comment">// SSI_CTRLR1(0x04) rx mode write NDF</span><br>write_ctrlr0(info, reg_data); <span class="hljs-comment">// SSI_CTRLR0(0x00) update TMOD bit8~9</span><br>spi_dw_update_txftlr(info, spi); <span class="hljs-comment">// SSI_TXFTLR(0x18) Set Tx threshold is half of the fifo</span><br>write_rxftlr(info, reg_data); <span class="hljs-comment">// SSI_RXFTLR(0x1C) Ser Rx threshold, default is (info-&gt;fifo_depth * 5) / 8</span><br>write_imr(info, reg_data); <span class="hljs-comment">// SSI_IMR(0x2C) enable interrupt</span><br>spi_context_cs_control(&amp;spi-&gt;ctx, <span class="hljs-literal">true</span>); <span class="hljs-comment">// cs toggle low</span><br>set_bit_ssienr(info); <span class="hljs-comment">// SSI_ENR(0x08) enable controller</span><br><br><span class="hljs-comment">// spi_dw_isr</span><br><span class="hljs-comment">// rx interrupt -&gt; pull_data</span><br>read_rxflr(info); <span class="hljs-comment">// SSI_RXFLR(0x24) number of valid data</span><br>read_dr(info);    <span class="hljs-comment">// SSI_DR(0x60) read data out</span><br><span class="hljs-comment">// tx interrupt -&gt; push_data</span><br>read_txflr(info) <span class="hljs-comment">// SSI_RXFLR(0x20) number of valid data</span><br>write_dr(info, data); <span class="hljs-comment">// SSI_DR(0x60) write data in</span><br><br>clear_interrupts(info); <span class="hljs-comment">// SSI_ICR(0x48) clear interrupt</span><br>test_bit_sr_busy(info); <span class="hljs-comment">// SSI_SR(0x28) bit0 wait busy</span><br>write_imr(info, DW_SPI_IMR_MASK); <span class="hljs-comment">// SSI_IMR(0x2C) disable interrupt</span><br>clear_bit_ssienr(info); <span class="hljs-comment">// SSI_ENR(0x08) write 0</span><br>spi_context_cs_control(&amp;spi-&gt;ctx, <span class="hljs-literal">false</span>); <span class="hljs-comment">// cs toggle high</span><br></code></pre></td></tr></tbody></table></figure><h3 id="CONFIG-SPI-STATS开关"><a href="#CONFIG-SPI-STATS开关" class="headerlink" title="CONFIG_SPI_STATS开关"></a>CONFIG_SPI_STATS开关</h3><p>看看打开这个对debug有没有帮助</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- I2C framework</title>
    <link href="/2023/12/15/Note/Zephyr/Driver/23-12-15_I2C/"/>
    <url>/2023/12/15/Note/Zephyr/Driver/23-12-15_I2C/</url>
    
    <content type="html"><![CDATA[<h2 id="Device-Tree"><a href="#Device-Tree" class="headerlink" title="Device Tree"></a>Device Tree</h2><h2 id="Consumer-应用层和其他driver如何调用i2c接口"><a href="#Consumer-应用层和其他driver如何调用i2c接口" class="headerlink" title="Consumer(应用层和其他driver如何调用i2c接口)"></a>Consumer(应用层和其他driver如何调用i2c接口)</h2><p><strong>方法1：</strong></p><p>设备树API</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取i2c device node id</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_DEV  DT_COMPAT_GET_ANY_STATUS_OKAY(test_i2c) <span class="hljs-comment">// i2c deivce的compatible，不是i2c bus</span></span><br><br><span class="hljs-comment">// 通过I2C_DT_SPEC_GET宏从设备树获得i2c_dt_spec结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_dt_spec</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">bus</span>;</span><br>  <span class="hljs-type">uint16_t</span> addr;<br>};<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_DT_SPEC_GET_ON_I2C(node_id)          \</span><br><span class="hljs-meta">  .bus = DEVICE_DT_GET(DT_BUS(node_id)),\</span><br><span class="hljs-meta">  .addr = DT_REG_ADDR(node_id)</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_dt_spec</span> <span class="hljs-title">i2c</span> =</span> I2C_DT_SPEC_GET(I2C_DEV);<br></code></pre></td></tr></tbody></table></figure><p>可以调用i2c_xxx_dt进行i2c传输了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_write_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_dt_spec *spec,</span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">uint32_t</span> num_bytes)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_read_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_dt_spec *spec,</span><br><span class="hljs-params">            <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">uint32_t</span> num_bytes)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_write_read_dt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_dt_spec *spec,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-type">void</span> *write_buf, <span class="hljs-type">size_t</span> num_write,</span><br><span class="hljs-params">            <span class="hljs-type">void</span> *read_buf, <span class="hljs-type">size_t</span> num_read)</span><br></code></pre></td></tr></tbody></table></figure><p><strong>方法2：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/i2c.h</span><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint32_t</span> dev_config)</span>;<br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_get_config</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint32_t</span> *dev_config)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *buf,</span><br><span class="hljs-params">       <span class="hljs-type">uint32_t</span> num_bytes, <span class="hljs-type">uint16_t</span> addr)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint8_t</span> *buf,</span><br><span class="hljs-params">         <span class="hljs-type">uint32_t</span> num_bytes, <span class="hljs-type">uint16_t</span> addr)</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_write_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint16_t</span> addr,</span><br><span class="hljs-params">         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *write_buf, <span class="hljs-type">size_t</span> num_write,</span><br><span class="hljs-params">         <span class="hljs-type">void</span> *read_buf, <span class="hljs-type">size_t</span> num_read)</span><br>__syscall <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_transfer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev,</span><br><span class="hljs-params">         <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">uint8_t</span> num_msgs,</span><br><span class="hljs-params">         <span class="hljs-type">uint16_t</span> addr)</span>;<br></code></pre></td></tr></tbody></table></figure><p>等等还有一些读写函数。</p><p class="note note-warning">没有__syscall标识的函数，user space应该不能调用？</p><p>参考<code>zephyr/tests/drivers/i2c/i2c_api/src/test_i2c.c</code>中的流程:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">i2c_configure(i2c_dev, i2c_cfg); <span class="hljs-comment">// 首先调用i2c_configure, 配置i2c controller。</span><br>i2c_get_config(i2c_dev, &amp;i2c_cfg_tmp); <span class="hljs-comment">// 接着调用get_config, 判断配置是否下对。</span><br>i2c_write(i2c_dev, datas, <span class="hljs-number">2</span>, <span class="hljs-number">0x1E</span>); <span class="hljs-comment">// 可以发送i2c数据了。</span><br>i2c_read(i2c_dev, datas, <span class="hljs-number">6</span>, <span class="hljs-number">0x1E</span>); <span class="hljs-comment">// i2c read读回。</span><br></code></pre></td></tr></tbody></table></figure><h2 id="Provider-I2C-driver"><a href="#Provider-I2C-driver" class="headerlink" title="Provider(I2C driver)"></a>Provider(I2C driver)</h2><p><code>i2c_configure</code>会调用到driver的<code>api-&gt;configure</code>。以<code>i2c_dw.c</code> dwsignware i2c ip为例，会进入<code>i2c_dw_runtime_configure</code>配置函数。</p><p>主要做的事情有：</p><ol><li>保存好传入的配置到dw-&gt;app_config。</li><li>根据传入的i2c speed配置i2c的lcnt,hcnt。</li><li>清中断。</li></ol><p class="note note-warning">注意这边.configure函数并没有真正把配置写到寄存器中, 而是在.transfer函数中的set_up函数才会写入</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">i2c_dw_runtime_configure</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">uint32_t</span> config)</span><br>{<br>  <span class="hljs-comment">//...</span><br>  dw-&gt;lcnt = value;<br>  dw-&gt;hcnt = value;<br>  <span class="hljs-comment">//...</span><br>  read_clr_intr(reg_base);<br>  <span class="hljs-comment">//...</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><code>i2c_get_config</code>类似，调用<code>api-&gt;get_config()</code>，这里<code>i2c_dw.c</code>未实现该回调函数。</p><p>接下来看I2C的read，write函数。这两个函数传入设备<code>dev</code>, 数据<code>buffer</code>，<code>buffer length</code>, <code>slave address</code>即可传输i2c数据。<br><code>i2c_read/i2c_write</code>-&gt;<code>i2c_transfer</code>-&gt;<code>api-&gt;transfer</code>-&gt;<code>i2c_dw_transfer</code></p><p>看下底层的<code>i2c_dw_transfer</code>函数，调用了<code>i2c_dw_setup</code>做的事情有：</p><ol><li>先关闭i2c controller。</li><li>屏蔽+清中断。</li><li>将之前存入<code>dw-&gt;app_data</code>写入<code>IC_CON</code>寄存器。</li><li>配置<code>IC_TAR</code>寄存器。</li><li>配置<code>dw-&gt;lcnt</code>, <code>dw-&gt;hcnt</code> 等等参数，都写入寄存器。</li></ol><p>配置完成后enable controller。<code>set_bit_enable_en(reg_base)</code><br>接着就是一系列的发送i2c message配置流程。打开中断后因为<code>tx_empty</code>会进入ISR，发送/接收数据。</p><h3 id="寄存器flow"><a href="#寄存器flow" class="headerlink" title="寄存器flow"></a>寄存器flow</h3><h3 id="CONFIG-I2C-STATS开关"><a href="#CONFIG-I2C-STATS开关" class="headerlink" title="CONFIG_I2C_STATS开关"></a>CONFIG_I2C_STATS开关</h3><p>看看打开这个对debug有没有帮助</p><h2 id="Shell-I2C-命令"><a href="#Shell-I2C-命令" class="headerlink" title="Shell I2C 命令"></a>Shell I2C 命令</h2><p>打开<code>CONFIG_I2C_SHELL</code>，编译<code>i2c_shell.c</code>.</p><p><code>i2c -h</code> 帮助菜单.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">uart:~$ i2c -h<br>i2c - I2C commands<br>Subcommands:<br>  scan        :Scan I2C devices<br>  recover     :Recover I2C bus<br>  read        :Read bytes from an I2C device<br>  read_byte   :Read a byte from an I2C device<br>  write       :Write bytes to an I2C device<br>  write_byte  :Write a byte to an I2C device<br>  speed       :Configure I2C bus speed<br></code></pre></td></tr></tbody></table></figure><p><code>device list</code> 展示可用的设备.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">uart:~$ device list<br>devices:<br>- clock@5000 (READY)<br>- gpio@842500 (READY)<br>- CRYPTOCELL_SW (READY)<br>- uart@8000 (READY)<br>- nrf91_socket (READY)<br>- i2c@9000 (READY)<br>- flash-controller@39000 (READY)<br>- bme280@76 (READY)<br>  requires: i2c@9000<br>- lis2dh@18 (READY)<br>  requires: gpio@842500<br>  requires: i2c@9000<br></code></pre></td></tr></tbody></table></figure><p><code>i2c scan i2c@9000</code> 扫描i2c bus上的设备.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">uart:~$ i2c scan i2c@9000<br>     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f<br>00:             -- -- -- -- -- -- -- -- -- -- -- --<br>10: -- -- -- -- -- -- -- -- 18 -- -- -- -- -- -- --<br>20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br>30: -- -- -- -- -- -- -- -- -- 39 -- -- -- -- -- --<br>40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br>50: -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- --<br>60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --<br>70: -- -- -- -- -- -- 76 --<br>4 devices found on i2c@9000<br></code></pre></td></tr></tbody></table></figure><p>i2c 读写命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">uart:~$ i2c read_byte i2c@9000 0x58 0x12<br>Output: 0xff<br>uart:~$ i2c write_byte i2c@9000 0x58 0x12 0x00<br>uart:~$ i2c read_byte i2c@9000 0x58 0x12<br>Output: 0x0<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim, Tmux, and Vim plugins</title>
    <link href="/2023/12/13/Note/23-12-13_Vim/"/>
    <url>/2023/12/13/Note/23-12-13_Vim/</url>
    
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="Command-line"><a href="#Command-line" class="headerlink" title="Command-line"></a>Command-line</h3><ul><li><code>:e {name of file}</code> open file for editing</li><li><code>:ls</code> show open buffers</li><li><code>:help {topic}</code> open help<ul><li><code>:help :w</code> opens help for the <code>:w</code> command</li><li><code>:help w</code> opens help for the <code>w</code> movement</li></ul></li></ul><h3 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a>Movement</h3><p><strong>Movements in Vim are also called “nouns”.</strong></p><ul><li>Basic movement: <code>hjkl</code> (left, down, up, right)</li><li>Words: <code>w</code> (next word), <code>b</code> (beginning of word), <code>e</code> (end of word)</li><li>Lines: <code>0</code> (beginning of line), <code>^</code> (first non-blank character), <code>$</code> (end of line)</li><li>Screen: <code>H</code> (top of screen), <code>M</code> (middle of screen), <code>L</code> (bottom of screen)</li><li>Scroll: <code>Ctrl-u</code> (up), <code>Ctrl-d</code> (down)</li><li>File: <code>gg</code> (beginning of file), <code>G</code> (end of file)</li><li>Line numbers: <code>:{number}&lt;CR&gt;</code> or <code>{number}G</code> (line {number})</li><li>Misc: <code>%</code> (corresponding item)</li><li>Find: <code>f{character}</code>, <code>t{character}</code>, <code>F{character}</code>, <code>T{character}</code><ul><li>find/to forward/backward {character} on the current line</li><li><code>,</code> / <code>;</code> for navigating matches</li></ul></li><li>Search: <code>/{regex}</code>, <code>n</code> / <code>N</code> for navigating matches</li></ul><h3 id="Edits"><a href="#Edits" class="headerlink" title="Edits"></a>Edits</h3><p><strong>Vim’s editing commands are also called “verbs”</strong></p><ul><li><code>i</code> enter Insert mode</li><li><code>o</code> / <code>O</code> insert line below / above</li><li><code>d{motion}</code> delete {motion}<ul><li>e.g. <code>dw</code> is delete word, <code>d$</code> is delete to end of line, <code>d0</code> is delete to beginning of line</li></ul></li><li><code>c{motion}</code> change {motion}<ul><li>e.g. <code>cw</code> is change word. like <code>d{motion}</code> followed by <code>i</code></li></ul></li><li><code>x</code> delete character (equal do <code>dl</code>)</li><li><code>s</code> substitute character (equal to <code>cl</code>)</li><li>Visual mode + manipulation<ul><li>select text, <code>d</code> to delete it or <code>c</code> to change it</li></ul></li><li><code>u</code> to undo, <code>&lt;Ctrl+r&gt;</code> to redo</li><li><code>y</code> to copy / “yank” (some other commands like <code>d</code> also copy)</li><li><code>p</code> to paste</li><li>Lots more to learn: e.g. <code>~</code> flips the case of a character</li></ul><h3 id="Counts"><a href="#Counts" class="headerlink" title="Counts"></a>Counts</h3><p>You can combine <strong>nouns</strong> and <strong>verbs</strong> with a <strong>count</strong>, which will perform a given action a number of times.</p><ul><li><code>3w</code> move 3 words forward</li><li><code>5j</code> move 5 lines down</li><li><code>7dw</code> delete 7 words</li></ul><h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>You can use modifiers to change the meaning of a noun. Some modifiers are <code>i</code>, which means “inner” or “inside”, and <code>a</code>, which means “around”.</p><blockquote><p>光标在括号中，<code>ci(</code>可以把括号内的内容替换并进入insert，类似<code>di(</code>也一样，相当于删除。<code>da(</code>连带括号一起删除。</p><p>这里的<code>i</code>和<code>a</code>不是edit中的含义，而是<strong>inner</strong>和<strong>around</strong>的意思。</p></blockquote><ul><li><code>ci(</code> change the contents inside the current pair of parentheses</li><li><code>ci[</code> change the contents inside the current pair of square brackets</li><li><code>da'</code> delete a single-quoted string, including the surrounding single quotes</li></ul><h3 id="Tabs标签页"><a href="#Tabs标签页" class="headerlink" title="Tabs标签页"></a>Tabs标签页</h3><p><code>gt</code>, <code>gT</code> 切换标签页。<br><code>Ctrl-w c</code> 关闭当前标签页。</p><h3 id="Windows窗口"><a href="#Windows窗口" class="headerlink" title="Windows窗口"></a>Windows窗口</h3><p><code>Ctrl-w h/j/k/l</code> 移动到左/下/上/右窗口<br><code>Ctrl-w c</code><br><code>Ctrl w w</code>: 循环窗口切换。</p><h2 id="Customizing-Vim"><a href="#Customizing-Vim" class="headerlink" title="Customizing Vim"></a>Customizing Vim</h2><p><a href="https://github.com/YC-Xiang/dotfiles/blob/main/.vimrc">my vim config</a></p><h2 id="Extending-Vim"><a href="#Extending-Vim" class="headerlink" title="Extending Vim"></a>Extending Vim</h2><p>Vim 8.0 之后自带插件管理工具，只要create the directory <code>~/.vim/pack/vendor/start/</code>, and put plugins in there (e.g. via <code>git clone</code>). <code>vendor</code>目录名好像可以替换。</p><h2 id="Advanced-Vim"><a href="#Advanced-Vim" class="headerlink" title="Advanced Vim"></a>Advanced Vim</h2><h3 id="Search-and-replace"><a href="#Search-and-replace" class="headerlink" title="Search and replace"></a>Search and replace</h3><p><code>:s</code> (substitute) command</p><ul><li><code>%s/foo/bar/g</code><ul><li>replace foo with bar globally in file</li></ul></li></ul><h3 id="Multiple-windows"><a href="#Multiple-windows" class="headerlink" title="Multiple windows"></a>Multiple windows</h3><ul><li><code>:sp</code> / <code>:vsp</code> to split windows</li><li>Can have multiple views of the same buffer.</li></ul><h3 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h3><p>to do</p><h2 id="Vscode-Vim"><a href="#Vscode-Vim" class="headerlink" title="Vscode Vim"></a>Vscode Vim</h2><p><code>gd</code>: 函数定义跳转。<br><code>C-o</code>: 返回。<br><code>gh</code>: 原地查看函数信息。</p><p><code>setting.json</code>: 配置vim快捷键。</p><p><code>C-q</code>: visual block.<br>visual模式选中后, <code>I</code>进入muti-cursor进行多行编辑。</p><p><code>C-shift-e</code>: 跳转资源管理器。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/***vscode vim***/</span><br><span class="hljs-attr">"vim.useSystemClipboard"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.incsearch"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.hlsearch"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.easymotion"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.leader"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;space&gt;"</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.insertModeKeyBindings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"before"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"j"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"j"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"after"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"&lt;Esc&gt;"</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"vim.normalModeKeyBindings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"before"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"&lt;Enter&gt;"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"after"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"o"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"&lt;Esc&gt;"</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"before"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"&lt;C-v&gt;"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"after"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"i"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"&lt;C-v&gt;"</span><span class="hljs-punctuation">,</span><span class="hljs-string">"&lt;Esc&gt;"</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br><span class="hljs-attr">"vim.handleKeys"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>  <span class="hljs-attr">"&lt;C-a&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-x&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-f&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-h&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-n&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-p&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-y&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;C-g&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">"&lt;Shift+Tab&gt;"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></tbody></table></figure><h3 id="easymotion"><a href="#easymotion" class="headerlink" title="easymotion"></a>easymotion</h3><p><code>&lt;leader&gt;+&lt;leader&gt;+w</code> <code>&lt;leader&gt;+&lt;leader&gt;+b</code>: 快速跳转<br><code>&lt;leader&gt;+&lt;leader&gt;+f+&lt;char&gt;</code>: 查找跳转</p><h2 id="Vimtutor"><a href="#Vimtutor" class="headerlink" title="Vimtutor"></a>Vimtutor</h2><h3 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h3><p><code>hjkl</code> 移动<br><code>x</code> 删除一个字符<br><code>i</code> 输入<br><code>a</code> append输入</p><h3 id="Lesson-2"><a href="#Lesson-2" class="headerlink" title="Lesson 2"></a>Lesson 2</h3><p><code>dw</code> 删除单词<br><code>de</code> 删除单词，光标留在单词末尾。<br><code>d$</code> 输出到行尾<br><code>2w</code> <code>3b</code> <code>2e</code> 移动单词<br><code>d2w</code> 删除两个单词<br><code>dd</code> <code>2dd</code> 删除两行<br><code>u</code> 撤销 <code>U</code> 返回一行的原始状态 <code>Ctrl r</code> 复原</p><h3 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title="Lesson 3"></a>Lesson 3</h3><p><code>dd</code> 之后的一行可以 <code>p</code> 粘贴<br><code>rx</code> 替换某个字符为<code>x</code><br><code>ce</code> 删除光标后单词部分，并进入insert mode。<br><code>cc</code> 删除整行，进入insert mode。<br><code>c$</code> 输出光标到行尾，并进入insert mode。</p><h3 id="Lesson-4"><a href="#Lesson-4" class="headerlink" title="Lesson 4"></a>Lesson 4</h3><p><code>Ctrl g</code> 显示当前行状态 <code>G</code> 文件末尾 <code>gg</code> 文件开头<br><code>/</code> 向后搜索 <code>?</code>向前搜索 <code>ctrl o</code> 返回 <code>ctrl i</code> 前进<br><code>%</code> 跳转到对应匹配的<code>) ] }</code><br><code>s/thee/the</code> 替换一个<code>thee</code>成<code>the</code><br><code>s/thee/the/g</code> 一行中<code>thee</code>替换成<code>the</code><br><code>:%s/thee/the/g</code> 整个文件的<code>thee</code>替换成<code>the</code><br><code>:%s/thee/the/gc</code> 整个文件的<code>thee</code>替换成<code>the</code>，每个替换会有命令提示<br><code>:#,#s/thee/the/g</code> <code>#</code> 是替换的行范围</p><h3 id="Lesson-5"><a href="#Lesson-5" class="headerlink" title="Lesson 5"></a>Lesson 5</h3><p><code>! + command</code> 执行外部命令<br><code>:w FILENAME</code> 文件另存为<br><code>v</code> 进入visual模式选中再 <code>:w FILENAME</code> 保存部分内容<br><code>:r FILENAME</code> 将文件内容追加到光标下<br><code>:r !ls</code> 将ls内容加到光标下</p><h3 id="Lesson-6"><a href="#Lesson-6" class="headerlink" title="Lesson 6"></a>Lesson 6</h3><p><code>o</code> 光标下插入新行 <code>O</code>光标上插入新行<br><code>R</code> replace mode<br><code>2y</code> 复制两行<br><code>:set ic</code> 接下来搜索大小写都会包括</p><h3 id="Lesson-7"><a href="#Lesson-7" class="headerlink" title="Lesson 7"></a>Lesson 7</h3><p><code>:</code>接<code>ctrl d</code>可以自动显示命令</p><h2 id="NERDTree"><a href="#NERDTree" class="headerlink" title="NERDTree"></a>NERDTree</h2><p><code>Ctrl p</code>: 模糊搜索。</p><p><strong>文件操作</strong><br><code>o</code>: 打开文件并跳转。<br><code>go</code>: 打开文件不跳转，仍然保留在nerdtree。<br><code>t</code>: 新建标签页打开该文件。<br><code>T</code>: 新建标签页打开该文件, 不跳转。<br><code>i</code>: 上下分屏。<br><code>gi</code>: 上下分屏，不跳转。<br><code>s</code>: 左右分屏。<br><code>gs</code>: 左右分屏，不跳转。<br><strong>目录操作</strong><br><code>o</code>: 打开目录。<br><code>O</code>: 递归打开目录。<br><code>t</code>: 在新标签页中打开目录。<br><code>T</code>: 在新标签页中打开目录，不跳转。<br><code>x</code>: 关闭父目录。<br><code>X</code>：关闭子目录。</p><h2 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h2><p><a href="https://kulkarniamit.github.io/whatwhyhow/howto/use-vim-ctags.html">Ctags使用方法</a></p><p>Ubuntu:<br><code>$ sudo apt-get update &amp;&amp; sudo apt-get install -y exuberant-ctags</code></p><p>创建~/.ctags，描述要忽略的文件/文件夹。<br>进入source code根目录，运行<code>ctags</code>, 生成文件<code>tags</code>。</p><p><code>vim -t &lt;tags&gt;</code> 从shell命令行跳转到tag的定义位置。<br><code>Ctrl ]</code> 跳转。<br><code>Ctrl T</code> 返回。<br><code>:tn</code> 跳转到下一个定义(如果有多个定义的话)。<br><code>:tp</code> 跳转到上一个定义(如果有多个定义的话)。<br><code>:tags</code> 列出tag stack。<br><code>:tags main</code> 跳转到指定tag，main。<br><code>:tags /^get</code> jumps to the tag that starts with “get”<br><code>:tag /Final$</code> jumps to the tag that ends with “Final”<br><code>:tag /norm</code> lists all the tags that contain “norm”, including “id_norm”</p><h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>~/.tmux.conf可修改tmux配置。</p><p><code>tmux</code>: open a new session.<br><code>C-b</code> -&gt; <code>C-a</code><br><code>C-b %</code>: 左右分屏。改为-&gt; <code>C-a |</code><br><code>C-b "</code>: 上下分屏。-&gt; <code>C-a -</code><br><code>C-b &lt;arrow key&gt;</code>:在panes间移动。-&gt; <code>alt + arrow</code><br><code>exit</code> or hit <code>Ctrl-d</code>：退出当前pane。<br><code>C-b c</code>: new window.<br><code>C-b p</code>: previous window.<br><code>C-b n</code>: next window.<br><code>C-b &lt;number&gt;</code> : move to window n.<br><code>tmux ls</code>: list sessions.<br><code>tmux attach -t 0</code>: attach to 0 session.<br><code>C-b ?</code>: help message.<br><code>C-b z</code>: make a pane go full screen. Hit <code>C-b z</code> again to shrink it back to its previous size<br><code>C-b C-&lt;arrow key&gt;</code>: 调整当前window的大小。<br><code>C-b ,</code>: 重命令当前window。<br><code>&lt;C-b&gt; [</code> Start scrollback. You can then press <code>&lt;space&gt;</code> to start a selection and <code>&lt;enter&gt;</code> to copy that selection.</p><h3 id="my-configs"><a href="#my-configs" class="headerlink" title="my configs"></a>my configs</h3><p><code>C-b</code> -&gt; <code>C-a</code><br><code>C-b %</code> -&gt; <code>C-a |</code><br><code>C-b "</code> -&gt; <code>C-a -</code><br><code>C-b &lt;arrow key&gt;</code> -&gt; <code>alt &lt;arrow key&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Device Tree</title>
    <link href="/2023/12/08/Note/Zephyr/EnvBuild/23-12-08_DeviceTree/"/>
    <url>/2023/12/08/Note/Zephyr/EnvBuild/23-12-08_DeviceTree/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-devicetree"><a href="#Introduction-to-devicetree" class="headerlink" title="Introduction to devicetree"></a>Introduction to devicetree</h2><p>All Zephyr and application source code files can include and use <code>devicetree.h</code>. This includes device drivers, applications, tests, the kernel, etc.</p><p>i2c从设备的reg地址是i2c slave address.<br>spi从设备的reg地址是chip select.</p><h3 id="Writing-property-values"><a href="#Writing-property-values" class="headerlink" title="Writing property values"></a>Writing property values</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20231208110415.png" alt="property values"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20231208153333.png" alt="补充的两个"></p><p><code>devicetree_unfixed.h</code>, <code>devicetree_fixups.h</code>: deivcetree编译出来的一些宏供C使用。<br>zephyr3.5只有<code>devicetree_generated.h</code></p><h2 id="Devicetree-bindings"><a href="#Devicetree-bindings" class="headerlink" title="Devicetree bindings"></a>Devicetree bindings</h2><p>Binding文件用来规范设备树每个节点的表达。</p><p>The build system uses bindings to generate C macros for devicetree properties that appear in DTS files. 如果binding文件中没有列出来，不会生成C宏。</p><p><a href="https://docs.zephyrproject.org/latest/build/dts/bindings-syntax.html">语法参考</a></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># A high level description of the device the binding applies to:</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">|</span><br><span class="hljs-string">   This is the Vendomatic company's foo-device.</span><br><span class="hljs-string"></span><br>   <span class="hljs-string">Descriptions</span> <span class="hljs-string">which</span> <span class="hljs-string">span</span> <span class="hljs-string">multiple</span> <span class="hljs-string">lines</span> <span class="hljs-string">(like</span> <span class="hljs-string">this)</span> <span class="hljs-string">are</span> <span class="hljs-string">OK,</span><br>   <span class="hljs-string">and</span> <span class="hljs-string">are</span> <span class="hljs-string">encouraged</span> <span class="hljs-string">for</span> <span class="hljs-string">complex</span> <span class="hljs-string">bindings.</span><br><br>   <span class="hljs-string">See</span> <span class="hljs-string">https://yaml-multiline.info/</span> <span class="hljs-string">for</span> <span class="hljs-string">formatting</span> <span class="hljs-string">help.</span><br><br><span class="hljs-comment"># You can include definitions from other bindings using this syntax:</span><br><span class="hljs-attr">include:</span> <span class="hljs-string">other.yaml</span><br><br><span class="hljs-comment"># Used to match nodes to this binding:</span><br><span class="hljs-attr">compatible:</span> <span class="hljs-string">"manufacturer,foo-device"</span><br><br><span class="hljs-attr">properties:</span><br>  <span class="hljs-comment"># Requirements for and descriptions of the properties that this</span><br>  <span class="hljs-comment"># binding's nodes need to satisfy go here.</span><br><br><span class="hljs-attr">child-binding:</span><br>  <span class="hljs-comment"># You can constrain the children of the nodes matching this binding</span><br>  <span class="hljs-comment"># using this key.</span><br><br><span class="hljs-comment"># If the node describes bus hardware, like an SPI bus controller</span><br><span class="hljs-comment"># on an SoC, use 'bus:' to say which one, like this:</span><br><span class="hljs-attr">bus:</span> <span class="hljs-string">spi</span><br><br><span class="hljs-comment"># If the node instead appears as a device on a bus, like an external</span><br><span class="hljs-comment"># SPI memory chip, use 'on-bus:' to say what type of bus, like this.</span><br><span class="hljs-comment"># Like 'compatible', this key also influences the way nodes match</span><br><span class="hljs-comment"># bindings.</span><br><span class="hljs-attr">on-bus:</span> <span class="hljs-string">spi</span><br><br><span class="hljs-attr">foo-cells:</span><br>  <span class="hljs-comment"># "Specifier" cell names for the 'foo' domain go here; example 'foo'</span><br>  <span class="hljs-comment"># values are 'gpio', 'pwm', and 'dma'. See below for more information.</span><br><br><br><span class="hljs-string">&lt;property</span> <span class="hljs-string">name&gt;:</span><br>  <span class="hljs-attr">required:</span> <span class="hljs-string">&lt;true</span> <span class="hljs-string">|</span> <span class="hljs-literal">false</span><span class="hljs-string">&gt;</span><br><span class="hljs-string">  type: &lt;string | int | boolean | array | uint8-array | string-array |</span><br><span class="hljs-string">         phandle | phandles | phandle-array | path | compound&gt;</span><br><span class="hljs-string">  deprecated: &lt;true | false&gt;</span><br><span class="hljs-string">  default: &lt;default&gt;</span><br><span class="hljs-string">  description: &lt;description of the property&gt;</span><br><span class="hljs-string">  enum:</span><br><span class="hljs-string">    - &lt;item1&gt;</span><br><span class="hljs-string">    - &lt;item2&gt;</span><br><span class="hljs-string">    ...</span><br><span class="hljs-string">    - &lt;itemN&gt;</span><br><span class="hljs-string">  const: &lt;string | int | array | uint8-array | string-array&gt;</span><br><span class="hljs-string">  specifier-space: &lt;space-name&gt;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>required: true表示必须要这个属性。</li><li>deprecated: true表示如果有这个属性，编译会出现warning。</li><li>default: 如果dts没有某个属性，会提供一个默认值给该属性。与required:true不能同时出现。</li><li>enum: 提供value的可选范围。</li><li>const: 提供value必须选择的值。</li></ul><h2 id="Devicetree-access-from-C-x2F-C"><a href="#Devicetree-access-from-C-x2F-C" class="headerlink" title="Devicetree access from C/C++"></a>Devicetree access from C/C++</h2><h3 id="Node-identifiers"><a href="#Node-identifiers" class="headerlink" title="Node identifiers"></a>Node identifiers</h3><p>get a node identifier:</p><blockquote><p>数字字母全部小写，非数字和字母的全部转化为下划线。</p></blockquote><p>By path:<br><code>DT_PATH(...)</code>: 输入根节点后的node路径，返回node identifier。如：<code>DT_PATH(soc, serial_40001000, ...)</code>。</p><p>By node label:<br><code>DT_NODELABEL(label)</code>: 输入label名称。如：<code>DT_NODELABEL(serial1)</code></p><p>By alias:<br><code>DT_ALIAS(alias)</code>: 输入/aliases下的node。</p><p>By instance number:<br><code>DT_INST(inst, compat)</code>: 根据指定的inst number和compat来找node。注意：compat相同的nodes中，status为disabled的inst number接在其他number后面。其他的inst number顺序不确定。</p><p>By chosen node:<br><code>DT_CHOSEN(prop)</code>: 输入/chosen下的node。</p><p>By parent/child:<br><code>DT_PARENT()</code>, <code>DT_CHILD()</code></p><p><code>DT_COMPAT_GET_ANY_STATUS_OKAY(compat)</code> 根据compatible找到任意status为ok的对应节点。</p><p>e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">/dts-v1/;<br><br>/ {<br>  aliases {<br>    sensor-controller = &amp;i2c1;<br>  };<br><br>  soc {<br>    i2c1: i2c@<span class="hljs-number">40002000</span> {<br>      compatible = <span class="hljs-string">"vnd,soc-i2c"</span>;<br>      label = <span class="hljs-string">"I2C_1"</span>;<br>      reg = &lt;<span class="hljs-number">0x40002000</span> <span class="hljs-number">0x1000</span>&gt;;<br>      status = <span class="hljs-string">"okay"</span>;<br>      clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br>    };<br>  };<br>};<br></code></pre></td></tr></tbody></table></figure><p>以下几种方法都可以找到<code>i2c@40002000</code>node。</p><ul><li><code>DT_PATH(soc, i2c_40002000)</code></li><li><code>DT_NODELABEL(i2c1)</code></li><li><code>DT_ALIAS(sensor_controller)</code></li><li><code>DT_INST(x, vnd_soc_i2c)</code> for some unknown number x.</li></ul><h3 id="Property-access"><a href="#Property-access" class="headerlink" title="Property access"></a>Property access</h3><h4 id="Simple-properties"><a href="#Simple-properties" class="headerlink" title="Simple properties"></a>Simple properties</h4><p><code>DT_NODE_HAS_PROP(node_id, prop)</code>: 检查node_id是否有prop属性。</p><p><code>DT_PROP(node_id, prop)</code>: 返回node_id的prop属性。本质是拼接node_id和prop,再到<code>devicetree_generated.h</code>中找宏。</p><p><code>DT_PROP_LEN(node_id, prop)</code>: 获取prop的长度。</p><p><code>DT_PROP_XXX</code>不能用于reg和interrupts prop。</p><h4 id="reg-properties"><a href="#reg-properties" class="headerlink" title="reg properties"></a>reg properties</h4><p>reg prop需要使用:<br><code>DT_REG_ADDR(node_id)</code>: return address。<br><code>DT_REG_SIZE(node_id)</code>: return size。<br>如果有多个reg blocks: 注意idx只能传入数字或宏，不能在循环中传入i。<br><code>DT_REG_ADDR_BY_IDX(node_id, idx)</code><br><code>DT_REG_SIZE_BY_IDX(node_id, idx)</code></p><h4 id="interrupt-properties"><a href="#interrupt-properties" class="headerlink" title="interrupt properties"></a>interrupt properties</h4><p>interrupts prop需要使用：<br><code>DT_NUM_IRQS(node_id)</code>: 返回interrupts prop中有多少个value。比如interrupts = &lt;33, 1&gt;。会return 2。第一个表示中断号，第二个是中断优先级。</p><p><code>DT_IRQ_BY_IDX()</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;2&gt;</span></span><br>...<br>my-serial: serial@abcd1234 {<br>        interrupts = &lt; <span class="hljs-number">33</span> <span class="hljs-number">0</span> &gt;, &lt; <span class="hljs-number">34</span> <span class="hljs-number">1</span> &gt;;<br>};<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERIAL DT_NODELABEL(my_serial)</span><br><br>Example usage                       Value<br>-------------                       -----<br>DT_IRQ_BY_IDX(SERIAL, <span class="hljs-number">0</span>, irq)          <span class="hljs-number">33</span><br>DT_IRQ_BY_IDX(SERIAL, <span class="hljs-number">0</span>, priority)      <span class="hljs-number">0</span><br>DT_IRQ_BY_IDX(SERIAL, <span class="hljs-number">1</span>, irq,          <span class="hljs-number">34</span><br>DT_IRQ_BY_IDX(SERIAL, <span class="hljs-number">1</span>, priority)      <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="phandle-properties"><a href="#phandle-properties" class="headerlink" title="phandle properties"></a>phandle properties</h4><p><strong>convert a phandle to a node identifier：</strong><br><code>DT_PHANDLE()</code><br><code>DT_PHANDLE_IDX()</code><br><code>DT_PHANDLE_BY_NAME()</code></p><p><strong>convert the devicetree-level phandle to a Zephyr driver-level struct device:</strong></p><p>方法1：<code>DEVICE_DT_GET()</code>必须要跟<code>device_is_ready</code>来检查。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_SERIAL DT_NODELABEL(serial0)</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">const</span> <span class="hljs-title">uart_dev</span> =</span> DEVICE_DT_GET(MY_SERIAL);<br><br><span class="hljs-keyword">if</span> (!device_is_ready(uart_dev)) {<br>        <span class="hljs-comment">/* Not ready, do not use */</span><br>        <span class="hljs-keyword">return</span> -ENODEV;<br>}<br></code></pre></td></tr></tbody></table></figure><p>方法2：<code>device_get_binding()</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name = <span class="hljs-string">"UART_0"</span>;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">uart_dev</span> =</span> device_get_binding(dev_name);<br></code></pre></td></tr></tbody></table></figure><p><strong>access specifier values in a phandle array:</strong><br><code>DT_PHA_BY_IDX()</code><br><code>DT_PHA()</code></p><h3 id="Other-APIs"><a href="#Other-APIs" class="headerlink" title="Other APIs"></a>Other APIs</h3><h3 id="Device-driver-conveniences"><a href="#Device-driver-conveniences" class="headerlink" title="Device driver conveniences"></a>Device driver conveniences</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;zephyr/devicetree.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_DRV_COMPAT my_driver_compat</span><br><br><span class="hljs-comment">/* This is same thing as DT_INST(0, my_driver_compat): */</span><br>DT_DRV_INST(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the same thing as</span><br><span class="hljs-comment"> * DT_PROP(DT_INST(0, my_driver_compat), clock_frequency)</span><br><span class="hljs-comment"> */</span><br>DT_INST_PROP(<span class="hljs-number">0</span>, clock_frequency)<br></code></pre></td></tr></tbody></table></figure><h2 id="The-x2F-zephyr-user-mode"><a href="#The-x2F-zephyr-user-mode" class="headerlink" title="The /zephyr, user mode"></a>The /zephyr, user mode</h2><p><code>/zephyr, user</code> 节点可以不用写binding文件，直接提供给user space使用。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- West</title>
    <link href="/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_West/"/>
    <url>/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_West/</url>
    
    <content type="html"><![CDATA[<h2 id="West"><a href="#West" class="headerlink" title="West"></a>West</h2><h3 id="Workspace-concepts"><a href="#Workspace-concepts" class="headerlink" title="Workspace concepts"></a>Workspace concepts</h3><h4 id="configuration-file"><a href="#configuration-file" class="headerlink" title="configuration file"></a>configuration file</h4><p><code>.west/config</code> 配置文件，定义了manifest repository等。</p><h4 id="manifest-file"><a href="#manifest-file" class="headerlink" title="manifest file"></a>manifest file</h4><p><code>west.yml</code> 描述了管理的其他git仓库。可以用<code>manifest.file</code>覆盖。执行<code>west update</code>可以更新所有git仓库。</p><h3 id="Built-in-commands"><a href="#Built-in-commands" class="headerlink" title="Built-in commands"></a>Built-in commands</h3><p><code>west help</code>: 查看支持的命令。<br><code>west &lt;command&gt; -h</code>: for detailed help.<br><code>west update -r</code>: sync的时候会rebase local commits.<br><code>west compare</code>: compare the state of the workspace against the manifest.<br><code>west diff</code><br><code>west status</code><br><code>west forall -c &lt;command&gt;</code>: 对所有仓库执行某个shell命令。<br><code>west grep</code><br><code>west list</code>: 所有project信息。<br><code>west manifest</code>: 管理manifest文件。</p><h3 id="Workspaces"><a href="#Workspaces" class="headerlink" title="Workspaces"></a>Workspaces</h3><h4 id="Topologies-supported"><a href="#Topologies-supported" class="headerlink" title="Topologies supported"></a>Topologies supported</h4><ul><li>star topology, zephyr is the manifest repository</li><li>star topology, a Zephyr application is the manifest repository</li><li>forest topology, freestanding manifest repository</li></ul><h3 id="West-Manifests"><a href="#West-Manifests" class="headerlink" title="West Manifests"></a>West Manifests</h3><p><a href="https://docs.zephyrproject.org/latest/develop/west/manifest.html#">West Manifests yaml文件</a></p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p><a href="https://docs.zephyrproject.org/latest/develop/west/config.html">west config 提供的一些选项</a></p><ul><li>System: <code>/etc/westconfig</code></li><li>Global: <code>~/.westconfig</code></li><li>local: <code>&lt;REPO_DIR&gt;/.west/config</code></li></ul><p>通过<code>west config --system/global/local</code>可以设置。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- ZTest</title>
    <link href="/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_ZTest/"/>
    <url>/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_ZTest/</url>
    
    <content type="html"><![CDATA[<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h3 id="Creating-a-test-suite"><a href="#Creating-a-test-suite" class="headerlink" title="Creating a test suite"></a>Creating a test suite</h3><p><code>ZTEST_SUITE</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create and register a ztest suite. Using this macro creates a new test suite (using</span><br><span class="hljs-comment"> * ztest_test_suite). It then creates a struct ztest_suite_node in a specific linker section.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Tests can then be run by calling ztest_run_test_suites(const void *state) by passing</span><br><span class="hljs-comment"> * in the current state. See the documentation for ztest_run_test_suites for more info.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param SUITE_NAME The name of the suite (see ztest_test_suite for more info)</span><br><span class="hljs-comment"> * @param PREDICATE A function to test against the state and determine if the test should run.</span><br><span class="hljs-comment"> * @param setup_fn The setup function to call before running this test suite</span><br><span class="hljs-comment"> * @param before_fn The function to call before each unit test in this suite</span><br><span class="hljs-comment"> * @param after_fn The function to call after each unit test in this suite</span><br><span class="hljs-comment"> * @param teardown_fn The function to call after running all the tests in this suite</span><br><span class="hljs-comment">**/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZTEST_SUITE(SUITE_NAME, PREDICATE, setup_fn, before_fn, after_fn, teardown_fn)             \</span><br><span class="hljs-meta">  struct ztest_suite_stats UTIL_CAT(z_ztest_suite_node_stats_, SUITE_NAME);                  \</span><br><span class="hljs-meta">  static const STRUCT_SECTION_ITERABLE(ztest_suite_node,                                     \</span><br><span class="hljs-meta">               UTIL_CAT(z_ztest_test_node_, SUITE_NAME)) = {         \</span><br><span class="hljs-meta">    .name = STRINGIFY(SUITE_NAME),                                                     \</span><br><span class="hljs-meta">    .setup = (setup_fn),                                                               \</span><br><span class="hljs-meta">    .before = (before_fn),                                                             \</span><br><span class="hljs-meta">    .after = (after_fn),                                                               \</span><br><span class="hljs-meta">    .teardown = (teardown_fn),                                                         \</span><br><span class="hljs-meta">    .predicate = PREDICATE,                                                            \</span><br><span class="hljs-meta">    .stats = &amp;UTIL_CAT(z_ztest_suite_node_stats_, SUITE_NAME),             \</span><br><span class="hljs-meta">  }</span><br></code></pre></td></tr></tbody></table></figure><p><code>.setup</code>: 每个test suite run都会调用一次。<br><code>.before</code>: 每个single test in the test suite run前都会调用一次。<br><code>.after</code>: 每个single test in the test suite run后都会调用一次。<br><code>.teardown</code>: 所有tests跑完后会调用一次。<br><code>.predicate</code>: return bool，判断是否要进行test。</p><h3 id="Adding-tests-to-a-suite"><a href="#Adding-tests-to-a-suite" class="headerlink" title="Adding tests to a suite"></a>Adding tests to a suite</h3><p><code>ZTEST(suite_name, test_name)</code>: suite_name为上面通过ZTEST_SUITE创建的SUITE_NAME, test_name为测试名称。<br><code>ZTEST_USER(suite_name, test_name)</code>: 和ZTEST类似，不过在<code>CONFIG_USERSPACE</code>打开后，测试会跑在userspace线程。<br><code>ZTEST_F(suite_name, test_name)</code>: 和ZTEST类似，不过会自带一个名为<code>&lt;suite_name&gt;_fixture</code>的变量。<br><code>ZTEST_USER_F</code>：结合2,3两条。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Develop with Zephyr</title>
    <link href="/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_DevelopWithZephyr/"/>
    <url>/2023/11/30/Note/Zephyr/EnvBuild/23-11-30_DevelopWithZephyr/</url>
    
    <content type="html"><![CDATA[<h2 id="Getting-Started-Guide"><a href="#Getting-Started-Guide" class="headerlink" title="Getting Started Guide"></a>Getting Started Guide</h2><p>设置Python虚拟环境</p><p><code>python3 -m venv ~/zephyrproject/.venv</code></p><p><code>source ~/zephyrproject/.venv/bin/activate</code></p><p><code>deactive</code> 退出虚拟环境。</p><p class="note note-info">Remember to activate the virtual environment every time you start working.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/zephyrproject/zephyr<br>west build -p always -b &lt;your_board_name&gt; sample/basic/blinky<br></code></pre></td></tr></tbody></table></figure><p><code>-p always</code>表示a pristine build，也可以使用<code>-p auto</code>来自动判断是否需要pristine build.</p><h2 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h2><p>创建zephyr专属的环境变量，<code>touch ~/.zephyrrc</code>, <code>export MY_VARIABLE=foo</code>。<br>进入zephyr repository，执行<code>source zephyr-env.sh</code></p><p><code>source zephyr-env.sh</code>:</p><ul><li>set <code>ZEPHYR_BASE</code> 为zephyr repository(内核目录).</li><li>增加一些环境变量到系统<code>PATH</code>.</li><li>load <code>.zephyrrc</code> 中的配置.</li></ul><h2 id="Application-Development"><a href="#Application-Development" class="headerlink" title="Application Development"></a>Application Development</h2><p>app目录的结构通常为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;app&gt;<br>├── CMakeLists.txt<br>├── app.overlay<br>├── prj.conf<br>├── VERSION<br>└── src<br>    └── main.c<br></code></pre></td></tr></tbody></table></figure><p><code>CMakeLists.txt</code>: 编译APP的入口。<br><code>app.overlay</code>: 设备树overlay。<br><code>prj.conf</code>: Kconfig overlay。<br><code>VERSION</code>: Version信息。<br><code>src</code>: 源码目录。</p><h3 id="Application-types"><a href="#Application-types" class="headerlink" title="Application types"></a>Application types</h3><p>根据app位置，分为三种类型：<br><strong>Zephyr repository application</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">zephyrproject/<br>├─── .west/<br>│    └─── config<br>└─── zephyr/<br>     ├── arch/<br>     ├── boards/<br>     ├── cmake/<br>     ├── samples/<br>     │    ├── hello_world/<br>     │    └── ...<br>     ├── tests/<br>     └── ...<br></code></pre></td></tr></tbody></table></figure><p><strong>Zephyr workspace application</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">zephyrproject/<br>├─── .west/<br>│    └─── config<br>├─── zephyr/<br>├─── bootloader/<br>├─── modules/<br>├─── tools/<br>├─── &lt;vendor/private-repositories&gt;/<br>└─── applications/<br>     └── app/<br></code></pre></td></tr></tbody></table></figure><p><strong>Zephyr freestanding application</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;home&gt;/<br>├─── zephyrproject/<br>│     ├─── .west/<br>│     │    └─── config<br>│     ├── zephyr/<br>│     ├── bootloader/<br>│     ├── modules/<br>│     └── ...<br>│<br>└─── app/<br>     ├── CMakeLists.txt<br>     ├── prj.conf<br>     └── src/<br>         └── main.c<br></code></pre></td></tr></tbody></table></figure><p>参考：<a href="https://github.com/zephyrproject-rtos/example-application">example-application</a></p><h3 id="Important-Build-System-Variables"><a href="#Important-Build-System-Variables" class="headerlink" title="Important Build System Variables"></a>Important Build System Variables</h3><p>变量<code>BOARD</code> <code>CONF_FILE</code> <code>DTC_OVERLAY_FILE</code>，有三种传入方法：</p><ul><li><code>west build</code> 或 <code>cmake</code> 传入 <code>-D</code>，有多个overlay文件可以用分号隔开<code>file1.overlay;file2_overlay</code>。</li><li>环境变量<code>.zephyrrc</code> <code>.bashrc</code></li><li><code>set (&lt;VARIABLE&gt; &lt;VALUE&gt;)</code> in <code>CMakeLists.txt</code></li></ul><p><code>ZEPHYR_BASE</code>: <code>find_package(Zephyr)</code> 会自动设置为一个Cmake variable。或者通过环境变量设置。<br><code>BOARD</code>: 选择开发板。<br><code>CONF_FILE</code>: Kconfig配置文件。没配置的话默认使用<code>prj.conf</code>。<br><code>EXTRA_CONF_FILE</code>: 覆盖的Kconfig配置文件。<br><code>DTC_OVERLAY_FILE</code>:dts设备树文件，没配置的话默认使用<code>app.overlay</code>。<br><code>EXTRA_DTC_OVERLAY_FILE</code><br><code>SHIELD</code>:<br><code>ZEPHYR_MODULES</code>:<br><code>EXTRA_ZEPHYR_MODULES</code>:</p><h3 id="Building-an-Application"><a href="#Building-an-Application" class="headerlink" title="Building an Application"></a>Building an Application</h3><p><code>west build -b &lt;board&gt; samples/hello_world</code>: 编译。<br><code>west build -b &lt;board&gt;@&lt;revision&gt;</code>: 指定版本。<br><code>west build -t clean</code>：build clean, <code>.config</code>不会删除。<br><code>west build -t pristine</code>: build目录下全部清空。<br><code>west flash</code>: 将可执行文件烧进主板。每次执行west flash，app都会rebuild and flash again。<br><code>west build -t run</code>: 当选择的board是qemu_x86/qemu_cortex_m3，可以直接在qemu中run。每次执行west run，app都会rebuild and run again。</p><p class="note note-info">Linux下run target will use the SDK’s QEMU binary by default.通过修改`QEMU_BIN_PATH`可以替换为自己下载的QEMU版本</p><h3 id="Custom-Board-Devicetree-and-SOC-Definitions"><a href="#Custom-Board-Devicetree-and-SOC-Definitions" class="headerlink" title="Custom Board, Devicetree and SOC Definitions"></a>Custom Board, Devicetree and SOC Definitions</h3><p>有几种方法可以将<code>board/</code>, <code>soc/</code> <code>dts/</code>放在application目录下：</p><p>1.Build的时候指定：<br><code>west build -b &lt;board name&gt; -- -DSOC_ROOT=&lt;path to soc&gt; -DBOARD_ROOT=&lt;path to boards&gt; -DDTS_ROOT=&lt;path to dts&gt;</code></p><p>2.在app下的<code>module.yml</code>中指定:</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">build:</span><br>  <span class="hljs-attr">settings:</span><br>    <span class="hljs-attr">board_root:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">dts_root:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">soc_root:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">arch_root:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">module_ext_root:</span> <span class="hljs-string">.</span><br></code></pre></td></tr></tbody></table></figure><p>3.在app下<code>CMakeList.txt</code>中指定：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(APPEND SOC_ROOT <span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span>/&lt;extra-soc-root&gt;)<br></code></pre></td></tr></tbody></table></figure><p>注意需要在<code>find_package(Zephyr ...)</code>前。</p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>检查ram，rom使用空间：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">west build -b reel_board samples/hello_world<br>west build -t ram_report<br>west build -t rom_report<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zephyr -- Device Drvier Model</title>
    <link href="/2023/11/30/Note/Zephyr/EnvBuild/23-12-01_DeviceDriverModel/"/>
    <url>/2023/11/30/Note/Zephyr/EnvBuild/23-12-01_DeviceDriverModel/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> {</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *config;<br>      <span class="hljs-type">const</span> <span class="hljs-type">void</span> *api;<br>      <span class="hljs-type">void</span> * <span class="hljs-type">const</span> data;<br>};<br></code></pre></td></tr></tbody></table></figure><p><code>config</code>: 放地址映射，中断号等一些物理信息。<br><code>api</code>: 回调函数。<br><code>data</code>: 放reference counts, semaphores, scratch buffers等。</p><h2 id="Device-Specific-API-Extensions"><a href="#Device-Specific-API-Extensions" class="headerlink" title="Device-Specific API Extensions"></a>Device-Specific API Extensions</h2><p>标准driver api没法实现的功能。</p><h2 id="Single-Driver-Multiple-Instances"><a href="#Single-Driver-Multiple-Instances" class="headerlink" title="Single Driver, Multiple Instances"></a>Single Driver, Multiple Instances</h2><p>某个driver对应多个instances的情况，比如uart driver匹配uart0, uart1, 并且中断线不是同一个。</p>]]></content>
    
    
    <categories>
      
      <category>Zephyr OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zephyr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS2022 PA0</title>
    <link href="/2023/10/17/Project/ICS/PA0/"/>
    <url>/2023/10/17/Project/ICS/PA0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><h3 id="1-1-虚拟机安装"><a href="#1-1-虚拟机安装" class="headerlink" title="1.1 虚拟机安装"></a>1.1 虚拟机安装</h3><p>网络选择桥接网络，复制物理状态</p><h3 id="1-2-软件安装"><a href="#1-2-软件安装" class="headerlink" title="1.2 软件安装"></a>1.2 软件安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install vim # vim<br>apt-get install openssh-server # ssh<br><br>apt-get install build-essential    # build-essential packages, include binary utilities, gcc, make, and so on<br>apt-get install man                # on-line reference manual<br>apt-get install gcc-doc            # on-line reference manual for gcc<br>apt-get install gdb                # GNU debugger<br>apt-get install git                # revision control system<br>apt-get install libreadline-dev    # a library used later<br>apt-get install libsdl2-dev        # a library used later<br>apt-get install llvm llvm-dev      # llvm project, which contains libraries used later<br></code></pre></td></tr></tbody></table></figure><p>安装<code>build essential</code>会出现<code>g++-11 : Depends: gcc-11-base (= 11.2.0-19ubuntu1) but 11.4.0-1ubuntu1~22.04 is to be installed</code>错误。可能是ubuntu版本问题。</p><p>解决方法:使用aptitude来处理版本依赖问题。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install aptitude<br>aptitude install build-essential<br>...<br></code></pre></td></tr></tbody></table></figure><p>安装完成后，进入<code>nemu</code>目录，执行<code>make menuconfig</code> -&gt; <code>make</code>又报错:<br><code>make[1]: bison: No such file or directory</code><br>直接安装<code>sudo apt-get install bison</code> -&gt; <code>make clean</code> -&gt; <code>make</code> 又又报错：<br><code>make[1]: flex: No such file or directory</code><br>继续安装<code>sudo apt-get install flex</code>，终于成功运行。</p><h2 id="1-3-配置git"><a href="#1-3-配置git" class="headerlink" title="1.3 配置git"></a>1.3 配置git</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name "221220000-Zhang San" # your student ID and name<br>git config --global user.email "zhangsan@foo.com"   # your email<br>git config --global core.editor vim                 # your favorite editor<br>git config --global color.ui true<br></code></pre></td></tr></tbody></table></figure><h2 id="1-4-配置ssh"><a href="#1-4-配置ssh" class="headerlink" title="1.4 配置ssh"></a>1.4 配置ssh</h2><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">生成ssh密钥</a>，并上传公钥至github setting:</p><h2 id="More-Exploration"><a href="#More-Exploration" class="headerlink" title="More Exploration"></a>More Exploration</h2><p>熟悉一些常用的命令行工具, 并强迫自己在日常操作中使用它们<br>文件检索 - <code>cat</code>, <code>more</code>, <code>less</code>, <code>head</code>, <code>tail</code>, <code>file</code>, <code>find</code><br>输入输出控制 - 重定向, 管道, <code>tee</code>, <code>xargs</code><br>文本处理 - <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>sort</code>, <code>wc</code>, <code>uniq</code>, <code>cut</code>, <code>tr</code><br>正则表达式<br>系统监控 - <code>jobs</code>, <code>ps</code>, <code>top</code>, <code>kill</code>, <code>free</code>, <code>dmesg</code>, <code>lsof</code><br>上述工具覆盖了程序员绝大部分的需求<br>可以先从简单的尝试开始, 用得多就记住了, 记不住就man</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C spec</title>
    <link href="/2023/09/12/Book/23-09-12_I2C_spec/"/>
    <url>/2023/09/12/Book/23-09-12_I2C_spec/</url>
    
    <content type="html"><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>I2C 为什么要用开漏输出，而不能用推挽输出。</p><ol><li>防止短路。两个push pull输出相连，如果一个输出高，一个输出低，会短路。</li><li>线与。开漏输出有一个输出端输出低，则整条线都为低，所有输出高才为高。<br><a href="https://www.zhihu.com/question/534999506">https://www.zhihu.com/question/534999506</a><br><a href="https://www.eet-china.com/mp/a87499.html">https://www.eet-china.com/mp/a87499.html</a></li></ol><p>以上都是针对multiple masters多个输出端的，如果是single master config的话，推挽输出是否可以？</p><h2 id="2-I2C-bus-features"><a href="#2-I2C-bus-features" class="headerlink" title="2 I2C-bus features"></a>2 I2C-bus features</h2><ul><li>Only two bus lines are required; a serial data line (SDA) and a serial clock line (SCL).</li><li>It is a true multi-controller bus including collision detection and arbitration to prevent<br>data corruption if two or more controllers simultaneously initiate data transfer.</li><li>Serial, 8-bit oriented, bidirectional data transfers can be made at up to 100 kbit/s in the<br>Standard-mode, up to 400 kbit/s in the Fast-mode, up to 1 Mbit/s in Fast-mode Plus, or<br>up to 3.4 Mbit/s in the High-speed mode.</li><li>Serial, 8-bit oriented, unidirectional data transfers up to 5 Mbit/s in Ultra Fast-mode</li></ul><h2 id="3-The-I2C-bus-protocol"><a href="#3-The-I2C-bus-protocol" class="headerlink" title="3 The I2C-bus protocol"></a>3 The I2C-bus protocol</h2><h3 id="3-1-Standard-mode-Fast-mode-and-Fast-mode-Plus-I2C-bus-protocols"><a href="#3-1-Standard-mode-Fast-mode-and-Fast-mode-Plus-I2C-bus-protocols" class="headerlink" title="3.1 Standard-mode, Fast-mode and Fast-mode Plus I2C-bus protocols"></a>3.1 Standard-mode, Fast-mode and Fast-mode Plus I2C-bus protocols</h3><p>Each device is recognized by a unique address and can operate as either a transmitter or receiver, depending on the function of the device.</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230912171459.png" alt="I2C-bus"></p><h4 id="3-1-1-SDA-and-SCL-signals"><a href="#3-1-1-SDA-and-SCL-signals" class="headerlink" title="3.1.1 SDA and SCL signals"></a>3.1.1 SDA and SCL signals</h4><p>开漏或者开集输出来实现线与的功能, 即一个controller把bus拉低, bus就呈现低电平状态。</p><h4 id="3-1-2-SDA-and-SCL-logic-levels"><a href="#3-1-2-SDA-and-SCL-logic-levels" class="headerlink" title="3.1.2 SDA and SCL logic levels"></a>3.1.2 SDA and SCL logic levels</h4><p>$V_{IL}=0.3V_{DD}$<br>$V_{IH}=0.7V_{DD}$</p><h4 id="3-1-3-Data-validity"><a href="#3-1-3-Data-validity" class="headerlink" title="3.1.3 Data validity"></a>3.1.3 Data validity</h4><p>SCL HIGH，SDA stable<br>SCL LOW，SDA change</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230912173014.png" alt="Bit Transfer"></p><h4 id="3-1-4-START-and-STOP-conditions"><a href="#3-1-4-START-and-STOP-conditions" class="headerlink" title="3.1.4 START and STOP conditions"></a>3.1.4 START and STOP conditions</h4><p>START和STOP都是由controller产生的。</p><ul><li>A HIGH to LOW transition on the SDA line while SCL is HIGH defines a <strong>START</strong> condition.</li><li>A LOW to HIGH transition on the SDA line while SCL is HIGH defines a <strong>STOP</strong> condition.</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230912173741.png" alt="START and STOP conditions"></p><h4 id="3-1-5-Byte-format"><a href="#3-1-5-Byte-format" class="headerlink" title="3.1.5 Byte format"></a>3.1.5 Byte format</h4><p>8bits接一个Ack。<br>MSB传输。<br>如果target需要处理其他事情比如中断，target可以把SCL拉低，让controller进入wait state。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230912174117.png" alt="Data transfer"></p><h3 id="3-1-6-Acknowledge-ACK-and-Not-Acknowledge-NACK"><a href="#3-1-6-Acknowledge-ACK-and-Not-Acknowledge-NACK" class="headerlink" title="3.1.6 Acknowledge (ACK) and Not Acknowledge (NACK)"></a>3.1.6 Acknowledge (ACK) and Not Acknowledge (NACK)</h3><p>第九个bit低电平表示ACK，高电平表示NACK。</p><p>产生NACK的原因有：</p><ul><li>controller发送的目标address没有receiver应答。</li><li>receiver在处理real-time function，比如中断等，没来得及应答。</li><li>receiver收到了不能理解的data or command。</li><li>receiver不能再收data了。</li></ul><h3 id="3-1-7-Clock-synchronization"><a href="#3-1-7-Clock-synchronization" class="headerlink" title="3.1.7 Clock synchronization"></a>3.1.7 Clock synchronization</h3><p>Single controller system不用考虑。</p><h3 id="3-1-10-Target-address-and-R-x2F-W-bit"><a href="#3-1-10-Target-address-and-R-x2F-W-bit" class="headerlink" title="3.1.10 Target address and R/W bit"></a>3.1.10 Target address and R/W bit</h3><p>START 信号后会跟7bits地址, 第8 bit为R/W, 0-&gt;write, 1-&gt;read。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230925094846.png" alt="Figure 11"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230925094904.png" alt="Figure 12"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230925094914.png" alt="Figure 13"></p><p>0x3938700 1s</p><p>0x3f000000  17.894s</p><p>0xffffff</p><p>进suspend前清掉flag，suspend时拉低sensor_cs，suspend起来读flag</p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何避免.bss变量转化成.data段变量</title>
    <link href="/2023/09/06/Misc/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D.bss%E5%8F%98%E9%87%8F%E8%BD%AC%E5%8C%96%E6%88%90.data%E6%AE%B5%E5%8F%98%E9%87%8F/"/>
    <url>/2023/09/06/Misc/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D.bss%E5%8F%98%E9%87%8F%E8%BD%AC%E5%8C%96%E6%88%90.data%E6%AE%B5%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>发现在一个.c文件中有一个初始化为非0的全局变量或静态变量，会使这整个文件中定义的全局变量或静态变量都由.bss段转化为.data段。</p><p><strong>.data段</strong>的变量会在mcu boot阶段的clib会对这些变量做初始化，**.bss段**可以透过keilc的config如下图控制是否要跳过clib的初始化为0（目前我们的配置是把IRAM配置为不要初始化）<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906141358.png" alt="skip bss init"><br>这样的话，我们的芯片在suspend或sleep之后，由于MCU做了power gating，resume起来后MCU重新上电，会重新从MCU boot那边开始跑，.data段的变量就无法保持suspend或sleep之前的值了，又被初始化成定义时候的值了，而.bss段就不会被初始化，可以保持之前的值。</p><p>在我们目前usb产品的应用中，一般变量都是要保持suspend/sleep之前的值，所以不能产生有.data段的变量<br>为了不产生.data段变量，我们要注意：</p><p><strong>- 全局变量在定义的时候不能做初始化。</strong><br><strong>- 不要使用静态的局部变量。</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误示例：</span><br>U8 g_byGlobalVar = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//正确示例：</span><br>U8 g_byGlobalVar;<br><span class="hljs-type">void</span> <span class="hljs-title function_">InitGlobalVars</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">if</span>(reset_status==RESET_FROM_POWER_ON)<br>        g_byGlobalVar=<span class="hljs-number">5</span>; <span class="hljs-comment">//InitGlobalVars()函数中做初始化</span><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3权威指南</title>
    <link href="/2023/09/06/Book/23-09-06_Cortex-M3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2023/09/06/Book/23-09-06_Cortex-M3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《Cortex-M3权威指南》</li><li>《ARMv7-M Architecture Reference Manual》</li><li>《Cortex-M3 Technical Reference Manual》</li></ul><h2 id="Chapter1-介绍"><a href="#Chapter1-介绍" class="headerlink" title="Chapter1 介绍"></a>Chapter1 介绍</h2><p>Cortex－M3处理器（CM3）采用ARMv7-M架构，它包括<strong>所有的</strong>16位Thumb指令集和<strong>基本的</strong>32位Thumb-2指令集架构，Cortex-M3处理器<strong>不能</strong>执行ARM指令集。</p><p>CM3的出现，还在ARM处理器中破天荒地支持了“非对齐数据访问支持”。</p><h2 id="Chapter2-CM3概览"><a href="#Chapter2-CM3概览" class="headerlink" title="Chapter2 CM3概览"></a>Chapter2 CM3概览</h2><h3 id="2-2-Registers"><a href="#2-2-Registers" class="headerlink" title="2.2 Registers"></a>2.2 Registers</h3><p>CM3有R0-R15，16个registers。R13作为堆栈指针SP。SP有两个，但在同一时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906101830.png" alt="CM3 Registers"></p><p>绝大多数16位Thumb指令只能访问R0-R7，而32位Thumb-2指令可以访问所有寄存器。</p><p>Cortex-M3拥有两个堆栈指针，然而它们是banked，因此任一时刻只能使用其中的一个。</p><ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包括中断服务例程）</li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul><p>R14 LR：当调用一个子程序时，由R14存储返回地址。</p><p>R15 PC: 指向当前的程序地址。如果修改它的值，就能改变程序的执行流。</p><h3 id="2-3-操作模式和特权级别"><a href="#2-3-操作模式和特权级别" class="headerlink" title="2.3 操作模式和特权级别"></a>2.3 操作模式和特权级别</h3><p>两种操作模式：handler mode（异常服务程序代码），thread mode（应用程序代码）。</p><p>两种特权级别：特权级，用户级。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906104733.png" alt="操作模式和特权级别"><br>在CM3运行主应用程序时（线程模式），既可以使用特权级，也可以使用用户级；但是异常服务例程必须在特权级下执行。复位后，处理器默认进入线程模式，特权极访问。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906104934.png" alt="操作模式转换图"><br>用户级的程序不能简简单单地试图改写CONTROL寄存器就回到特权级，它必须先“申诉”：执行一条系统调用指令(SVC)。这会触发SVC异常，然后由异常服务例程（通常是操作系统的一部分）接管，如果批准了进入，则异常服务例程修改CONTROL寄存器，才能在用户级的线程模式下重新进入特权级。</p><h3 id="2-5-存储器映射"><a href="#2-5-存储器映射" class="headerlink" title="2.5 存储器映射"></a>2.5 存储器映射</h3><p>总体来说，Cortex-M3支持4GB存储空间，如图2.6所示地被划分成若干区域。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906110236.png" alt="CM3存储器映射"><br>从图中可见，不像其它的ARM架构，它们的存储器映射由半导体厂家说了算，Cortex-M3预先定义好了“粗线条的”存储器映射。</p><h3 id="2-6-总线接口"><a href="#2-6-总线接口" class="headerlink" title="2.6 总线接口"></a>2.6 总线接口</h3><h3 id="2-9-中断和异常"><a href="#2-9-中断和异常" class="headerlink" title="2.9 中断和异常"></a>2.9 中断和异常</h3><p>11种系统异常+5个保留档位+240个外部中断。</p><table><thead><tr><th>编号</th><th>类型</th><th>优先级</th><th>简介</th></tr></thead><tbody><tr><td>0</td><td>N/A</td><td>N/A</td><td>没有异常在运行</td></tr><tr><td>1</td><td>复位</td><td>-3（最高）</td><td>复位</td></tr><tr><td>2</td><td>NMI</td><td>-2</td><td>不可屏蔽中断（来自外部NMI输入脚）</td></tr><tr><td>3</td><td>硬(hard) fault</td><td>-1</td><td>所有被disable的fault，都将“上访”成硬fault</td></tr><tr><td>4</td><td>MemManage fault</td><td>可编程</td><td>存储器管理fault，MPU访问犯规以及访问非法位置</td></tr><tr><td>5</td><td>总线fault</td><td>可编程</td><td>总线错误（预取流产（Abort）或数据流产）</td></tr><tr><td>6</td><td>用法(usage)Fault</td><td>可编程</td><td>由于程序错误导致的异常</td></tr><tr><td>7-10</td><td>保留</td><td>N/A</td><td>N/A</td></tr><tr><td>11</td><td>SVCall</td><td>可编程</td><td>系统服务调用</td></tr><tr><td>12</td><td>调试监视器</td><td>可编程</td><td>调试监视器（断点，数据观察点，或者是外部调试请求</td></tr><tr><td>13</td><td>保留</td><td>N/A</td><td>N/A</td></tr><tr><td>14</td><td>PendSV</td><td>可编程</td><td>为系统设备而设的“可悬挂请求”（pendable request）</td></tr><tr><td>15</td><td>SysTick</td><td>可编程</td><td>系统滴答定时器</td></tr><tr><td>16-255</td><td>IRQ #0~239</td><td>可编程</td><td>外中断#0~#239</td></tr></tbody></table><h3 id="2-10-调试支持"><a href="#2-10-调试支持" class="headerlink" title="2.10 调试支持"></a>2.10 调试支持</h3><p>Cortex-M3的调试系统基于ARM最新的CoreSight架构。不同于以往的ARM处理器，内核本身不再含有JTAG接口。取而代之的，是CPU提供称为“调试访问接口(DAP)”的总线接口。</p><p>目前可用的DPs包括<strong>SWJ-DP</strong>(既支持传统的JTAG调试，也支持新的串行线调试协议SWD)，另一个<strong>SW-DP</strong>则去掉了对JTAG的支持。另外，也可以使用ARM CoreSignt产品家族的<strong>JTAG-DP</strong>模块。这下就有3个DPs可以选了，芯片制造商可以从中选择一个，以提供具体的调试接口（通常都是选SWJ-DP）。</p><h2 id="Chpater3-CM3基础"><a href="#Chpater3-CM3基础" class="headerlink" title="Chpater3 CM3基础"></a>Chpater3 CM3基础</h2><p>PC: 读PC时返回的值是当前指令的地址+4。在分支时，无论是直接写PC的值还是使用分支指令，都必须保证加载到PC的数值是奇数（即LSB=1），用以表明这是在Thumb状态下执行。</p><blockquote><p>可以在map文件中看到thumb code的地址lsb都是奇数。data地址不受影响。</p></blockquote><h3 id="3-2-特殊功能寄存器"><a href="#3-2-特殊功能寄存器" class="headerlink" title="3.2 特殊功能寄存器"></a>3.2 特殊功能寄存器</h3><p>Cortex-M3还在内核水平上搭载了若干特殊功能寄存器，包括<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906104300.png" alt="Special function registers"></p><p>它们只能被专用的MSR/MRS指令访问</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MRS &lt;gp_reg&gt;, &lt;special_reg&gt;; 读特殊功能寄存器的值到通用寄存器<br>MSR &lt;special_reg&gt;, &lt;gp_reg&gt; ;写通用寄存器的值到特殊功能寄存器<br></code></pre></td></tr></tbody></table></figure><h4 id="3-2-1-程序状态寄存器"><a href="#3-2-1-程序状态寄存器" class="headerlink" title="3.2.1 程序状态寄存器"></a>3.2.1 程序状态寄存器</h4><ul><li>应用程序PSR（APSR）</li><li>中断号PSR（IPSR）</li><li>执行PSR（EPSR）</li></ul><p>通过MRS/MSR指令，这3个PSRs即可以单独访问，也可以组合访问（2个组合，3个组合都可以）。当使用三合一的方式访问时，应使用名字“xPSR”或者“PSR”。<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906154110.png" alt="PSR"></p><p>APSR:</p><ul><li>N: 负数标志</li><li>Z: 0结果标志</li><li>C: 进位/错位标志</li><li>V: 溢出标志</li></ul><h4 id="3-2-2-中断屏蔽寄存器"><a href="#3-2-2-中断屏蔽寄存器" class="headerlink" title="3.2.2 中断屏蔽寄存器"></a>3.2.2 中断屏蔽寄存器</h4><ul><li>PRIMASK - 这是个只有1 bit的寄存器。在它被置1后，就关掉所有可屏蔽的异常，只剩下NMI和Hardfault可以响应。</li><li>FAULTMASK - 这是个只有1 bit的寄存器。当它置1时，只有NMI才能响应，所有其它的异常，甚至是Hardfault，也不能响应。</li><li>BASEPRI - 这个寄存器最多有9位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。</li></ul><p>要访问PRIMASK, FAULTMASK以及BASEPRI，同样要使用MRS/MSR指令。</p><h4 id="3-2-3-控制寄存器"><a href="#3-2-3-控制寄存器" class="headerlink" title="3.2.3 控制寄存器"></a>3.2.3 控制寄存器</h4><p>控制寄存器有两个用途，其一用于定义特权级别，其二用于选择当前使用哪个堆栈指针。<br>CONTROL[1]：0=选择主堆栈指针MSP（复位后的缺省值），1=选择进程堆栈指针PSP。<br>CONTROL[0]：0=特权级的线程模式，1=用户级的线程模式。</p><h2 id="Chapter4-指令集"><a href="#Chapter4-指令集" class="headerlink" title="Chapter4 指令集"></a>Chapter4 指令集</h2><p><strong>EQU</strong>：定义常数，常数定义必须顶格写。<br><code>Stack_Size      EQU     0x00006000</code><br>DCB：定义一串字节常数。<br>DCD：定义一串23位整数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">MY_NUMBER<br>    DCD 0x12345678<br>HELLO_TEXT<br>    DCB ”Hello\n”,0<br></code></pre></td></tr></tbody></table></figure><h3 id="4-1-后缀的使用"><a href="#4-1-后缀的使用" class="headerlink" title="4.1 后缀的使用"></a>4.1 后缀的使用</h3><p><img src="/image.png" alt="指令后缀"></p><h3 id="4-2-指令集"><a href="#4-2-指令集" class="headerlink" title="4.2 指令集"></a>4.2 指令集</h3><p>详细指令见附录。</p><h2 id="Chapter5-存储器系统"><a href="#Chapter5-存储器系统" class="headerlink" title="Chapter5 存储器系统"></a>Chapter5 存储器系统</h2><h3 id="5-2-存储器映射"><a href="#5-2-存储器映射" class="headerlink" title="5.2 存储器映射"></a>5.2 存储器映射</h3><h3 id="5-3-存储器的各种访问属性"><a href="#5-3-存储器的各种访问属性" class="headerlink" title="5.3 存储器的各种访问属性"></a>5.3 存储器的各种访问属性</h3><ol><li>代码区（0x0000_0000- 0x1FFF_FFFF）。该区是可以执行指令的，缓存属性为Write Through。在此区上的数据操作是通过D-Code?(<strong>此处存疑</strong>)，且在此区上的写操作是缓冲的。</li><li>SRAM区（0x2000_0000 – 0x3FFF_FFFF）。此区用于片内SRAM，写操作是缓冲的write back/write allocated，此区亦可以执行指令。</li><li>片上外设区(0x4000_0000 – 0x5FFF_FFFF)。该区用于片上外设，因此是不可缓存的，也不可以在此区执行指令。</li></ol><h3 id="5-4-存储器的缺省访问许可"><a href="#5-4-存储器的缺省访问许可" class="headerlink" title="5.4 存储器的缺省访问许可"></a>5.4 存储器的缺省访问许可</h3><h3 id="5-5-位带操作"><a href="#5-5-位带操作" class="headerlink" title="5.5 位带操作"></a>5.5 位带操作</h3><h3 id="5-6-非对齐数据传送"><a href="#5-6-非对齐数据传送" class="headerlink" title="5.6 非对齐数据传送"></a>5.6 非对齐数据传送</h3><h3 id="5-7-互斥访问"><a href="#5-7-互斥访问" class="headerlink" title="5.7 互斥访问"></a>5.7 互斥访问</h3><h3 id="5-8-端模式"><a href="#5-8-端模式" class="headerlink" title="5.8 端模式"></a>5.8 端模式</h3><h2 id="Chapter-6-Cortex-M3-全貌"><a href="#Chapter-6-Cortex-M3-全貌" class="headerlink" title="Chapter 6 Cortex-M3 全貌"></a>Chapter 6 Cortex-M3 全貌</h2><h3 id="6-3-CM3的总线接口"><a href="#6-3-CM3的总线接口" class="headerlink" title="6.3 CM3的总线接口"></a>6.3 CM3的总线接口</h3><p>CM3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问并行不悖。<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230906162526.png" alt="CM3 架构"></p><h4 id="6-3-1-I-Code-总线"><a href="#6-3-1-I-Code-总线" class="headerlink" title="6.3.1 I-Code 总线"></a>6.3.1 I-Code 总线</h4><p>I-Code的作用是取指令&amp;执行指令，只和指令有关，I-Code 总线是一条基于 AHB-Lite 总线协议的 32 位总线，负责在 0x0000_0000 – 0x1FFF_FFFF 之间的取指操作。</p><blockquote><p>从flash取指令</p></blockquote><h4 id="6-3-2-D-Code-总线"><a href="#6-3-2-D-Code-总线" class="headerlink" title="6.3.2 D-Code 总线"></a>6.3.2 D-Code 总线</h4><p>D-Code 的作用是对数据读写访问，只和数据有关，D-Code 总线也是一条基于 AHB-Lite 总线协议的 32 位总线，负责在 0x0000_0000 – 0x1FFF_FFFF（与I-Code相同）之间的数据访问操作。尽管 CM3 支持非对齐访问，但你绝不会在该总线上看到任何非对齐的地址，这是因为处理器的总线接口会把非对齐的数据传送都转换成对齐的数据传送。</p><blockquote><p>从flash存取数据</p></blockquote><h4 id="6-3-3-系统总线"><a href="#6-3-3-系统总线" class="headerlink" title="6.3.3 系统总线"></a>6.3.3 系统总线</h4><p>系统总线也是一条基于 AHB-Lite 总线协议的 32 位总线，负责在0x2000_0000 – 0xDFFF_FFFF和0xE010_0000 – 0xFFFF_FFFF之间的所有数据传送，取指和数据访问都算上。和D-Code总线一样，所有的数据传送都是对齐的。</p><blockquote><p>片上的SRAM一般都是由系统总线访问</p></blockquote><h4 id="6-3-4-外部私有外设总线"><a href="#6-3-4-外部私有外设总线" class="headerlink" title="6.3.4 外部私有外设总线"></a>6.3.4 外部私有外设总线</h4><h4 id="6-3-5-调试访问端口总线"><a href="#6-3-5-调试访问端口总线" class="headerlink" title="6.3.5 调试访问端口总线"></a>6.3.5 调试访问端口总线</h4><p>调试访问端口总线接口是一条基于“增强型 APB 规格”的 32 位总线，它专用于挂接调试接口，例如 SWJ-DP 和 SW-DP。</p><h3 id="6-7-复位信号"><a href="#6-7-复位信号" class="headerlink" title="6.7 复位信号"></a>6.7 复位信号</h3><p>nPORESET上电复位：复位处理器核心和调试系统。<br>nSYSRESET系统复位：只复位处理器核心。<br>nTRST测试复位：只复位调试系统。</p><h2 id="Chapter7-异常"><a href="#Chapter7-异常" class="headerlink" title="Chapter7 异常"></a>Chapter7 异常</h2><h3 id="7-5-Fault类异常"><a href="#7-5-Fault类异常" class="headerlink" title="7.5 Fault类异常"></a>7.5 Fault类异常</h3><h4 id="7-5-1-总线faults"><a href="#7-5-1-总线faults" class="headerlink" title="7.5.1 总线faults"></a>7.5.1 总线faults</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230907101314.png" alt="Bus faults"></p><h4 id="7-5-2-存储器管理faults"><a href="#7-5-2-存储器管理faults" class="headerlink" title="7.5.2 存储器管理faults"></a>7.5.2 存储器管理faults</h4><ul><li>访问了所有MPU regions覆盖范围之外的地址。</li><li>访问了没有存储器与之对应的空地址。</li><li>往只读region写数据。</li><li>用户级下访问了只允许在特权级下访问的地址。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230907101400.png" alt="MemManage faults"></p><h4 id="7-5-3-用法faults"><a href="#7-5-3-用法faults" class="headerlink" title="7.5.3 用法faults"></a>7.5.3 用法faults</h4><ul><li>执行了协处理器指令。</li><li>执行了未定义的指令。</li><li>尝试进入ARM状态。</li><li>无效的中断返回（LR中包含了无效/错误的值）。</li><li>使用多重加载/存储指令时，地址没有对齐。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230907101427.png" alt="Usage faults"></p><h4 id="7-5-4-Hardfaults"><a href="#7-5-4-Hardfaults" class="headerlink" title="7.5.4 Hardfaults"></a>7.5.4 Hardfaults</h4><p>Hardfault是上文讨论的Bus fault、MemManage fault以及Usage fault上访的结果。如果这些fault的服务例程无法执行，它们就会成为“硬伤”——上访（escalation）成Hardfault。如果不是由于取向量造成的，则Hardfault服务例程必须检查其它的fault状态寄存器，以最终决定是谁上访的。</p><p>Hardfault状态寄存器（地址：0xE000_ED2C）<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230907101638.png" alt="Hard Fault"></p><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p><a href="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/armv7.pdf">ARMv7-M Instruction set and System registers</a></p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFU(Device Firmware Upgrade)</title>
    <link href="/2023/08/15/Note/USB/DFU/"/>
    <url>/2023/08/15/Note/USB/DFU/</url>
    
    <content type="html"><![CDATA[<h1 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h1><p>四个阶段：</p><ul><li>Enumeration<ul><li>device告知host具备的能力。通过Run-Time Descriptor中增加的DFU class-interface descriptor和functional descriptor实现。</li></ul></li><li>Reconfiguration<ul><li>host和device同意初始固件升级。host会发送一次USB reset，设备会exports DFU descriptors出来。</li></ul></li><li>Transfer</li><li>Manifestation<ul><li>device告知设备完成升级，host会再次发送USB reset, 重新枚举设备，运行新固件。</li></ul></li></ul><p>总体流程：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802161808.png"></p><h1 id="3-Requests"><a href="#3-Requests" class="headerlink" title="3. Requests"></a>3. Requests</h1><p>bRequest分别从DFU_DETACH: 0 ~ DFU_ABORT: 6</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802161942.png"></p><h1 id="4-Enumeration-Phase"><a href="#4-Enumeration-Phase" class="headerlink" title="4. Enumeration Phase"></a>4. Enumeration Phase</h1><h2 id="4-1-Run-Time-Descriptor-Set"><a href="#4-1-Run-Time-Descriptor-Set" class="headerlink" title="4.1 Run-Time Descriptor Set"></a>4.1 Run-Time Descriptor Set</h2><p>支持DFU的设备，在<strong>run-time</strong>时需要额外增加两个描述符：</p><ul><li><strong>A single DFU class interface descriptor</strong></li><li><strong>A single functional descriptor</strong></li></ul><p>因此Configuration descriptor的<em>bNumInterfaces</em>域需要加1。</p><h3 id="Run-time-DFU-Interface-Descriptor"><a href="#Run-time-DFU-Interface-Descriptor" class="headerlink" title="Run-time DFU Interface Descriptor"></a><strong>Run-time DFU Interface Descriptor</strong></h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802163107.png"></p><h3 id="DFU-Functional-Descriptor"><a href="#DFU-Functional-Descriptor" class="headerlink" title="DFU Functional Descriptor"></a><strong>DFU Functional Descriptor</strong></h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802163409.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802163417.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">PrepareDFUFunDesc</span><span class="hljs-params">(DFUFunDesc_t *pDFUFunDesc)</span><br>{<br>  pDFUFunDesc-&gt;bLength         = <span class="hljs-keyword">sizeof</span>(DFUFunDesc_t);<br>  pDFUFunDesc-&gt;bDescriptorType = <span class="hljs-number">0x21</span>;<br>  pDFUFunDesc-&gt;bmAttributes    = g_DFUVar.bmAttributes; <span class="hljs-comment">/// BIT0 | BIT1 | BIT2 | BIT3</span><br>  pDFUFunDesc-&gt;wDetachTimeOut  = <span class="hljs-number">200</span>;<br>  pDFUFunDesc-&gt;wTransferSize   = g_DFUVar.wTransferSize; <span class="hljs-comment">// 4096</span><br>  pDFUFunDesc-&gt;bcdDFUVersion   = <span class="hljs-number">0x0110</span>;<br><br>  <span class="hljs-keyword">if</span>(IsDFUMode())<br>  {<br>    pDFUFunDesc-&gt;wDetachTimeOut = <span class="hljs-number">2000</span>;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="4-2-DFU-Mode-Descriptor-Set"><a href="#4-2-DFU-Mode-Descriptor-Set" class="headerlink" title="4.2 DFU Mode Descriptor Set"></a>4.2 DFU Mode Descriptor Set</h2><p>host和device一致同意执行DFU操作后，host会重新枚举设备。这时候设备会export出DFU descriptor set包括：</p><ul><li>A DFU device descriptor</li><li>A single configuration descriptor</li><li>A single interface descriptor (including descriptors for alternate settings, if present)</li><li>A single functional descriptor</li></ul><h3 id="DFU-Device-Descriptor"><a href="#DFU-Device-Descriptor" class="headerlink" title="DFU Device Descriptor"></a><strong>DFU Device Descriptor</strong></h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802164728.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// rom code UsbDescCore_Rom.c</span><br>USBDevDesc_t USBDevDesc =<br>  {<br>    <span class="hljs-keyword">sizeof</span>(USBDevDesc),<span class="hljs-comment">// bLength:</span><br>    <span class="hljs-number">0x01</span>,<span class="hljs-comment">// USB_DEVICE_DESCRIPTOR_TYPE,bDescriptorType:</span><br>    <span class="hljs-number">0x0201</span>,<span class="hljs-comment">// bcdUSB version:NORM:0200H</span><br>    DEV_CLS_MULTI,<span class="hljs-comment">// bDeviceClass:-&gt; This is a Multi-interface Function Code Device</span><br>    DEV_SUBCLS_COMMON,<span class="hljs-comment">// bDeviceSubClass: -&gt; This is the Common Class Sub Class</span><br>    DEV_PROTOCOL_IAD,<span class="hljs-comment">// bDeviceProtocol: -&gt; This is the Interface Association Descriptor protocol</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-comment">// bMaxPacketSize0: = (64) Bytes</span><br>    ROM_RT_VID,<span class="hljs-comment">// idVendor:    = Realtek Corp.</span><br>    ROM_RT_FP_PID,<span class="hljs-comment">// idProduct:</span><br>    <span class="hljs-number">0x0001</span>,<span class="hljs-comment">// FW_TRUNK_VERSION, //bcdDevice:1.00</span><br>    I_MANUFACTURER,<span class="hljs-comment">// iManufacturer:</span><br>    I_PRODUCT,<span class="hljs-comment">// iProduct:</span><br>    I_SERIALNUMBER,<span class="hljs-comment">// iSerialNumber:</span><br>    <span class="hljs-number">0x01</span><span class="hljs-comment">// bNumConfigurations:</span><br>  };<br><br>  <span class="hljs-keyword">if</span>(IsDFUMode())<br>  {<br>    <span class="hljs-comment">// USBDevDesc.bcdUSB = 0x0200;</span><br>    USBDevDesc.bDeviceClass    = <span class="hljs-number">0x00</span>;<br>    USBDevDesc.bDeviceSubClass = <span class="hljs-number">0x00</span>;<br>    USBDevDesc.bDeviceProtocol = <span class="hljs-number">0x00</span>;<br>    USBDevDesc.idProduct = <span class="hljs-number">0x5800</span>;<br>    <span class="hljs-keyword">if</span>(DevIdcfg.cfgDevId_en==<span class="hljs-number">1</span>)<br>    {<br>      USBDevDesc.idVendor = DevIdcfg.dfu_idVendor;<br>      USBDevDesc.idProduct = DevIdcfg.dfu_idProduct;<br>      USBDevDesc.bcdDevice = DevIdcfg.dfu_bcdDevice;<br>    }<br>  }<br></code></pre></td></tr></tbody></table></figure><h3 id="DFU-Mode-Configuration-Descriptor"><a href="#DFU-Mode-Configuration-Descriptor" class="headerlink" title="DFU Mode Configuration Descriptor"></a>DFU Mode Configuration Descriptor</h3><p>与USB1.0 spec中标准配置描述符相同，除了<em>bNumInterfaces</em>域为01h</p><h3 id="DFU-Mode-Interface-Descriptor"><a href="#DFU-Mode-Interface-Descriptor" class="headerlink" title="DFU Mode Interface Descriptor"></a>DFU Mode Interface Descriptor</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802165234.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802165243.png"></p><h3 id="DFU-Functional-Descriptor-1"><a href="#DFU-Functional-Descriptor-1" class="headerlink" title="DFU Functional Descriptor"></a>DFU Functional Descriptor</h3><p>与4.1中的相同。</p><h1 id="5-Reconfiguration-Phase"><a href="#5-Reconfiguration-Phase" class="headerlink" title="5. Reconfiguration Phase"></a>5. Reconfiguration Phase</h1><ul><li>host发送DFU_DETACH request on EP0</li><li>host发送USB reset</li><li>device枚举DFU descriptor</li></ul><h2 id="5-1-DFU-DETACH"><a href="#5-1-DFU-DETACH" class="headerlink" title="5.1 DFU_DETACH"></a>5.1 DFU_DETACH</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230802170347.png"></p><h1 id="6-Transfer-Phase"><a href="#6-Transfer-Phase" class="headerlink" title="6. Transfer Phase"></a>6. Transfer Phase</h1><h2 id="6-1-Downloading"><a href="#6-1-Downloading" class="headerlink" title="6.1 Downloading"></a>6.1 Downloading</h2><p>把固件文件分为N pieces。</p><p>$N = ((F - S) / O) + 1$</p><p>F: 传输固件大小，S: 固件文件suffix大小，O:每次传输的size</p><p>如果传输过程中发生error，device会返回STALL给host，随后host会发送DFU_GETSTATUS来判断错误的原因。</p><p>device有三种方式从host接收firmware image：</p><ol><li><p>把image数据全读进一个buffer, 在下一阶段Manifestation phase中执行真正的programming</p></li><li><p>erase一块memory，把image写进去</p></li><li><p>方法2的变种，erase一大块memory，然后分次把image block传进去，这是用于要写的内存大于buffer size的情况。</p></li></ol><h3 id="6-1-1-DFU-DNLOAD"><a href="#6-1-1-DFU-DNLOAD" class="headerlink" title="6.1.1 DFU_DNLOAD"></a>6.1.1 DFU_DNLOAD</h3><p>每次最大的传输长度为functional descriptor的<strong>wTransferSize</strong>域。</p><p>host一次control-write transfer传输长度位于<strong>bMaxPacketSize0</strong> and <strong>wTransferSize</strong> bytes。</p><p>当最后一个block传输完成，host还会发送一次DFU_DNLOAD，其中<em>wLength</em>为0。</p><h3 id="6-1-2-DFU-GETSTATUS"><a href="#6-1-2-DFU-GETSTATUS" class="headerlink" title="6.1.2 DFU_GETSTATUS"></a>6.1.2 DFU_GETSTATUS</h3><p>host发送DFU_GETSTATUS，device返回</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803095303.png"></p><p>其中，</p><p>bStatus：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803095636.png"></p><p>bState：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803095751.png"></p><h3 id="6-1-3-DFU-CLRSTATUS"><a href="#6-1-3-DFU-CLRSTATUS" class="headerlink" title="6.1.3 DFU_CLRSTATUS"></a>6.1.3 DFU_CLRSTATUS</h3><p>清除dfuERROR状态，进入dfuIDLE</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803095539.png"></p><h3 id="6-1-4-DFU-ABORT"><a href="#6-1-4-DFU-ABORT" class="headerlink" title="6.1.4 DFU_ABORT"></a>6.1.4 DFU_ABORT</h3><p>强行进入dfuIDLE状态</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803095811.png"></p><h3 id="6-1-5-DFU-GETSTATE"><a href="#6-1-5-DFU-GETSTATE" class="headerlink" title="6.1.5 DFU_GETSTATE"></a>6.1.5 DFU_GETSTATE</h3><p>相当于只返回DFU_GETSTATUS中的bState域</p><h2 id="6-2-Uploading"><a href="#6-2-Uploading" class="headerlink" title="6.2 Uploading"></a>6.2 Uploading</h2><h3 id="6-2-1-DFU-UPLOAD"><a href="#6-2-1-DFU-UPLOAD" class="headerlink" title="6.2.1 DFU_UPLOAD"></a>6.2.1 DFU_UPLOAD</h3><h1 id="7-Manifestation-Phase"><a href="#7-Manifestation-Phase" class="headerlink" title="7. Manifestation Phase"></a>7. Manifestation Phase</h1><h1 id="A-Interface-State-Summary"><a href="#A-Interface-State-Summary" class="headerlink" title="A. Interface State Summary"></a>A. Interface State Summary</h1><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803101116.png"></p><h2 id="B-DFU-File-Suffix"><a href="#B-DFU-File-Suffix" class="headerlink" title="B. DFU File Suffix"></a>B. DFU File Suffix</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230803101542.png"></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux usb driver</title>
    <link href="/2023/06/15/Note/USB/usb%20driver/"/>
    <url>/2023/06/15/Note/USB/usb%20driver/</url>
    
    <content type="html"><![CDATA[<h1 id="USB-function-driver"><a href="#USB-function-driver" class="headerlink" title="USB function driver"></a>USB function driver</h1><p>f_loopback.c</p><h1 id="USB-composite-driver"><a href="#USB-composite-driver" class="headerlink" title="USB composite driver"></a>USB composite driver</h1><p>zero.c usb_composite_driver</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_composite_driver</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name; <span class="hljs-comment">// "zero"</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_device_descriptor</span>*<span class="hljs-title">dev</span>;</span> <span class="hljs-comment">// device_desc</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget_strings</span>**<span class="hljs-title">strings</span>;</span> <span class="hljs-comment">// dev_strings</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">max_speed</span>;</span> <span class="hljs-comment">// USB_SPEED_SUPER</span><br>  <span class="hljs-type">unsigned</span>needs_serial:<span class="hljs-number">1</span>;<br><br>  <span class="hljs-type">int</span>(*bind)(<span class="hljs-keyword">struct</span> usb_composite_dev *cdev); <span class="hljs-comment">// zero_bind</span><br>  <span class="hljs-type">int</span>(*unbind)(<span class="hljs-keyword">struct</span> usb_composite_dev *); <span class="hljs-comment">// zero_unbind</span><br><br>  <span class="hljs-type">void</span>(*disconnect)(<span class="hljs-keyword">struct</span> usb_composite_dev *);<br><br>  <span class="hljs-comment">/* global suspend hooks */</span><br>  <span class="hljs-type">void</span>(*suspend)(<span class="hljs-keyword">struct</span> usb_composite_dev *); <span class="hljs-comment">// zero_suspend</span><br>  <span class="hljs-type">void</span>(*resume)(<span class="hljs-keyword">struct</span> usb_composite_dev *); <span class="hljs-comment">// zero_resume</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget_driver</span><span class="hljs-title">gadget_driver</span>;</span> <span class="hljs-comment">// composite_driver_template</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>提供usb_configuration usb_device_descriptor</p><p>创建usb_composite_dev</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">usb_add_gadget_udc();<br><br><br><span class="hljs-comment">// 上层usb device driver, 模拟各种usb设备</span><br>module_usb_composite_driver();<br>    usb_composite_probe(); <span class="hljs-comment">// composite.c</span><br>        usb_gadget_probe_driver(); <span class="hljs-comment">//gadget/udc/core.c</span><br>            udc_bind_to_driver();<br>        driver-&gt;bind(); <span class="hljs-comment">// 调用到composite.c 的.bind = composite_bind</span><br>          composite_bind();<br>            composite-&gt;bind(); <span class="hljs-comment">//调用到zero.c 的.bind = zero_bind</span><br>                usb_gadget_udc_start();<br>                    udc-&gt;gadget-&gt;ops-&gt;udc_start();<br>                        rts_gadget_udc_start();<br><br></code></pre></td></tr></tbody></table></figure><h1 id="USB-gadget-driver"><a href="#USB-gadget-driver" class="headerlink" title="USB gadget driver"></a>USB gadget driver</h1><p>composite.c</p><p>struct usb_gadget_driver</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget_driver</span> {</span><br>  <span class="hljs-type">char</span>*function; <span class="hljs-comment">// "zero"</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">max_speed</span>;</span> <span class="hljs-comment">// USB_SPEED_SUPER</span><br>  <span class="hljs-type">int</span>(*bind)(<span class="hljs-keyword">struct</span> usb_gadget *gadget, <span class="hljs-comment">// composite_driver_template</span><br>          <span class="hljs-keyword">struct</span> usb_gadget_driver *driver);<br>  <span class="hljs-type">void</span>(*unbind)(<span class="hljs-keyword">struct</span> usb_gadget *);<br>  <span class="hljs-type">int</span>(*setup)(<span class="hljs-keyword">struct</span> usb_gadget *,<br>          <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> usb_ctrlrequest *);<br>  <span class="hljs-type">void</span>(*disconnect)(<span class="hljs-keyword">struct</span> usb_gadget *);<br>  <span class="hljs-type">void</span>(*suspend)(<span class="hljs-keyword">struct</span> usb_gadget *);<br>  <span class="hljs-type">void</span>(*resume)(<span class="hljs-keyword">struct</span> usb_gadget *);<br>  <span class="hljs-type">void</span>(*reset)(<span class="hljs-keyword">struct</span> usb_gadget *);<br>  <span class="hljs-type">int</span>(*filteroutdata)(<span class="hljs-keyword">struct</span> usb_gadget *,<br>          <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> usb_ctrlrequest *,<br>          u8 *, <span class="hljs-type">int</span>);<br><br>  <span class="hljs-comment">/* FIXME support safe rmmod */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span><span class="hljs-title">driver</span>;</span> <span class="hljs-comment">// driver-&gt;name = "zero"</span><br><br>  <span class="hljs-type">char</span>*udc_name;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">pending</span>;</span><br>  <span class="hljs-type">unsigned</span>                match_existing_only:<span class="hljs-number">1</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="UDC-driver"><a href="#UDC-driver" class="headerlink" title="UDC driver"></a>UDC driver</h1><p>设置struct usb_gadget</p><p>usb_add_gadget_udc 会创建一个usb_udc结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_udc</span> {</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget_driver</span>*<span class="hljs-title">driver</span>;</span> <span class="hljs-comment">// composite_driver_template</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget</span>*<span class="hljs-title">gadget</span>;</span> <span class="hljs-comment">// rtsusb-&gt;gadget</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span><span class="hljs-title">dev</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">list</span>;</span><br>  <span class="hljs-type">bool</span>vbus; <span class="hljs-comment">// true</span><br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget</span> {</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span><span class="hljs-title">work</span>;</span> <span class="hljs-comment">// usb_gadget_state_work</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_udc</span>*<span class="hljs-title">udc</span>;</span> <span class="hljs-comment">// udc</span><br>  <span class="hljs-comment">/* readonly to gadget driver */</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_gadget_ops</span>*<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">// rts_gadget_ops</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_ep</span>*<span class="hljs-title">ep0</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">ep_list</span>;</span> <span class="hljs-comment">// eps链表</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">speed</span>;</span> <span class="hljs-comment">// USB_SPEED_UNKNOWN</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_speed</span><span class="hljs-title">max_speed</span>;</span> <span class="hljs-comment">// USB_SPEED_HIGH</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">usb_device_state</span><span class="hljs-title">state</span>;</span> <span class="hljs-comment">// USB_STATE_NOTATTACHED</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name; <span class="hljs-comment">// "rts_gadget"</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span><span class="hljs-title">dev</span>;</span> <span class="hljs-comment">// dev.driver = &amp;gadget_driver-&gt;driver;</span><br>                  <span class="hljs-comment">// dev.parent = dev;</span><br>  <span class="hljs-type">unsigned</span>isoch_delay;<br>  <span class="hljs-type">unsigned</span>out_epnum;<br>  <span class="hljs-type">unsigned</span>in_epnum;<br>  <span class="hljs-type">unsigned</span>mA;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usb_otg_caps</span>*<span class="hljs-title">otg_caps</span>;</span><br><br>  <span class="hljs-type">unsigned</span>sg_supported:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>is_otg:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>is_a_peripheral:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>b_hnp_enable:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>a_hnp_support:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>a_alt_hnp_support:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>hnp_polling_support:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>host_request_flag:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>quirk_ep_out_aligned_size:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>quirk_altset_not_supp:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>quirk_stall_not_supp:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>quirk_zlp_not_supp:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>quirk_avoids_skb_reserve:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>is_selfpowered:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>deactivated:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>connected:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span>lpm_capable:<span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span>irq;<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// rts_usb_driver_probe</span><br>rtsusb-&gt;gadget.ops = &amp;rts_gadget_ops;<br>rtsusb-&gt;gadget.name = <span class="hljs-string">"rts_gadget"</span>;<br>rtsusb-&gt;gadget.max_speed = USB_SPEED_HIGH;<br>rtsusb-&gt;gadget.dev.parent = dev;<br>rtsusb-&gt;gadget.speed = USB_SPEED_UNKNOWN;<br><br>rts_gadget_init_endpoints(); <span class="hljs-comment">// 初始化endpoints</span><br>rts_usb_init(rtsusb); <span class="hljs-comment">// 写一些寄存器</span><br>usb_add_gadget_udc(dev, &amp;rtsusb-&gt;gadget); <span class="hljs-comment">// 注册udc</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">rts_usb_common_irq();<br>  rts_usb_ep_irq();<br>    rts_usb_se0_irq(); <span class="hljs-comment">/// root port reset irq</span><br>      usb_gadget_udc_reset();<br>        driver-&gt;reset(); <span class="hljs-comment">/// 进入composite.c中composite_driver_template .reset</span><br>    rts_usb_ep0_irq();<br>    rts_usb_intrep_irq();<br>    rts_usb_bulkinep_irq();<br>    rts_usb_bulkoutep_irq();<br>    rts_usb_uacinep_irq();<br>    rts_usb_uacoutep_irq();<br>    rts_usb_uvcinep_irq();<br>    <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// setup irq</span><br>rts_usb_ep0_irq();<br>  usb_read_reg(USB_EP0_SETUP_DATA0) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-comment">//... 读setup事务的data</span><br>  rts_usb_setup_process();<br>    rts_usb_ep0_standard_request();<br>      rts_usb_req_ep0_get_status();<br>        rts_ep_queue();<br>          rts_ep0_queue();<br>            rts_start_ep0_transfer();<br>      rts_usb_req_ep0_clear_feature();<br>      rts_usb_req_ep0_set_feature();<br>      rts_usb_req_ep0_set_address();<br>      rts_usb_req_ep0_set_configuration();<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">rts_usb_intrep_irq();<br>  rts_usb_intr_in_process();<br>    rts_intr_transfer_process();<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>usb spec</title>
    <link href="/2023/06/15/Note/USB/usb%20spec/"/>
    <url>/2023/06/15/Note/USB/usb%20spec/</url>
    
    <content type="html"><![CDATA[<h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><p>USB-IF</p><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>USB标准名称变更：</p><p>USB 1.0 -&gt; USB 2.0 Low-Speed</p><p>USB 1.1 -&gt; USB 2.0 Full-Speed</p><p>USB 2.0 -&gt; USB 2.0 High-Speed</p><p>USB 3.0 -&gt; USB 3.1 Gen1 -&gt; USB 3.2 Gen1</p><p>USB 3.1 -&gt; USB 3.1 Gen2 -&gt; USB 3.2 Gen2 × 1</p><p>USB 3.2 -&gt; USB 3.2 Gen2 × 2</p><p>USB OTG中增加了一种MINI USB接头，使用5条线，比标准USB多一条身份识别线。</p><p>USB协议规定，设备在未配置前，可以从Vbus最多获取100mA电流，配置之后，最多可以获得500mA电流。Vbus是5V的电压。</p><p>枚举就是从设备读取各种描述符信息。</p><p>Control transfer：低速8字节，高速64字节，全速8/16/32/64字节。</p><p>Isochronous Transfer：全速1023字节，高速1024字节，低速不支持。</p><p>Interrupt Transfer：低速上限8字节，全速上限64字节，高速上限1024字节。</p><p>Bulk transfer：高速512字节，全速8/16/32/64字节，低速不支持。</p><h1 id="Chapter3-Background"><a href="#Chapter3-Background" class="headerlink" title="Chapter3 Background"></a>Chapter3 Background</h1><p>USB 接口可用于连接多达 127 种外设。</p><h1 id="Chapter4-Architectural-Overview"><a href="#Chapter4-Architectural-Overview" class="headerlink" title="Chapter4 Architectural Overview"></a>Chapter4 Architectural Overview</h1><h3 id="4-1-1-Bus-Topology-总线拓扑"><a href="#4-1-1-Bus-Topology-总线拓扑" class="headerlink" title="4.1.1 Bus Topology 总线拓扑"></a>4.1.1 Bus Topology 总线拓扑</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230606134650.png"></p><ul><li>USB Host</li><li>USB Device<ul><li>Hub：用来扩展USB接口，最多接5层hub，如上图。</li><li>Function：USB设备。</li></ul></li></ul><h3 id="4-2-1-Electrical"><a href="#4-2-1-Electrical" class="headerlink" title="4.2.1 Electrical"></a>4.2.1 Electrical</h3><p>USB 2.0协议支持3种速率：</p><ul><li>低速(Low Speed，1.5Mbps)，兼容USB1.0</li><li>全速(Full Speed, 12Mbps)，兼容USB1.1</li><li>高速(High Speed, 480Mbps)</li></ul><p>USB 2.0 host controllers和hubs提供能力使<strong>full speed和low speed的数据</strong>能</p><p>以<strong>high speed</strong>的速率在<strong>host controller和hub</strong>之间传递，</p><p>以<strong>full speed和low speed</strong>的速率在<strong>hub和device</strong>之间传递。</p><h1 id="Chapter5-USB-Data-Flow-Model"><a href="#Chapter5-USB-Data-Flow-Model" class="headerlink" title="Chapter5 USB Data Flow Model"></a>Chapter5 USB Data Flow Model</h1><h3 id="5-3-1-Device-Endpoints"><a href="#5-3-1-Device-Endpoints" class="headerlink" title="5.3.1 Device Endpoints"></a>5.3.1 Device Endpoints</h3><p>Endpoint 只支持一种方向的数据流通，input or output。除endpoint0，input+output。</p><p>endpoint 描述的内容有：</p><ul><li>总线访问频率/延迟要求</li><li>带宽要求</li><li>endpoint number</li><li>Error handling</li><li>最大的packet size</li><li>数据传输方向</li></ul><h3 id="5-3-2-Pipes"><a href="#5-3-2-Pipes" class="headerlink" title="5.3.2 Pipes"></a>5.3.2 Pipes</h3><ul><li><p>Stream</p><p>传输的data没有USB-defined structure</p></li><li><p>Message</p><p>传输的data有USB-defined structure</p></li></ul><h1 id="Chapter7-Electrical"><a href="#Chapter7-Electrical" class="headerlink" title="Chapter7 Electrical"></a>Chapter7 Electrical</h1><h2 id="7-1-Signaling"><a href="#7-1-Signaling" class="headerlink" title="7.1 Signaling"></a>7.1 Signaling</h2><p>High Speed电路图。</p><p>Hub D+, D-信号线上有右下两个15k Rpd下拉电阻，所以默认电平为0。</p><p>device D+信号线上有1.5k Rpu上拉电阻，接上后D+被拉高。运行后会被Rpu_enable移除。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607093420.png"></p><p>Spec Table 7.1对各元器件功能有详细解释。</p><p>高速设备D+, D-各有Rs 45Ω的下拉电阻，用来消除反射信号：</p><p>当断开高速设备后，Hub发出信号，得到的反射信号无法衰减，Hub监测到这些信号后就知道高速设备已经断开。对应上图的Rs和Disconnection Envelope Detector。当差分信号线的幅值超过<strong>625mV</strong>，意味着断开。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607094320.png"></p><h4 id="7-1-5-1-Low-x2F-Full-speed-Device-Speed-Identification"><a href="#7-1-5-1-Low-x2F-Full-speed-Device-Speed-Identification" class="headerlink" title="7.1.5.1 Low-/Full-speed Device Speed Identification"></a>7.1.5.1 Low-/Full-speed Device Speed Identification</h4><p>Full/High-speed device D+ 上有1.5k Rpu上拉。</p><p>Low-speed device D- 上有1.5k Rpu上拉。</p><p>用于attach时区分不同速率的设备。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607101850.png"></p><h3 id="7-1-7-Signaling-levels"><a href="#7-1-7-Signaling-levels" class="headerlink" title="7.1.7 Signaling levels"></a>7.1.7 Signaling levels</h3><h4 id="7-1-7-1-Low-x2F-Full-speed-Signaling-Levels"><a href="#7-1-7-1-Low-x2F-Full-speed-Signaling-Levels" class="headerlink" title="7.1.7.1 Low-/Full-speed Signaling Levels"></a>7.1.7.1 Low-/Full-speed Signaling Levels</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607103019.png"></p><h4 id="7-1-7-2-High-speed-Signaling-Levels"><a href="#7-1-7-2-High-speed-Signaling-Levels" class="headerlink" title="7.1.7.2 High-speed Signaling Levels"></a>7.1.7.2 High-speed Signaling Levels</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607104959.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607105059.png"></p><h4 id="7-1-7-4-Data-Signaling"><a href="#7-1-7-4-Data-Signaling" class="headerlink" title="7.1.7.4 Data Signaling"></a>7.1.7.4 Data Signaling</h4><h5 id="7-1-7-4-1-Low-x2F-Full-Speed-Signaling"><a href="#7-1-7-4-1-Low-x2F-Full-Speed-Signaling" class="headerlink" title="7.1.7.4.1 Low-/Full-Speed Signaling"></a>7.1.7.4.1 Low-/Full-Speed Signaling</h5><p>SOP：Start Of Packet，Hub驱动D+、D-这两条线路从Idle状态变为K状态。SOP中的K状态就是SYNC信号的第1位数据，SYNC格式为3对KJ外加2个K。</p><p>EOP：End Of Packet，由数据的发送方发出EOP，数据发送方驱动D+、D-这两条线路，先设为SE0状态并维持2位时间，再设置为J状态并维持1位时间，最后D+、D-变为高阻状态，这时由线路的上下拉电阻使得总线进入Idle状态。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607112911.png"></p><h5 id="7-1-7-4-2-High-speed-Signaling"><a href="#7-1-7-4-2-High-speed-Signaling" class="headerlink" title="7.1.7.4.2 High-speed Signaling"></a>7.1.7.4.2 High-speed Signaling</h5><h4 id="7-1-7-5-Reset"><a href="#7-1-7-5-Reset" class="headerlink" title="7.1.7.5 Reset"></a>7.1.7.5 Reset</h4><h4 id="7-1-7-6-Suspend"><a href="#7-1-7-6-Suspend" class="headerlink" title="7.1.7.6 Suspend"></a>7.1.7.6 Suspend</h4><h4 id="7-1-7-7-Resume"><a href="#7-1-7-7-Resume" class="headerlink" title="7.1.7.7 Resume"></a>7.1.7.7 Resume</h4><h3 id="7-1-8-Data-encoding-数据编码"><a href="#7-1-8-Data-encoding-数据编码" class="headerlink" title="7.1.8 Data encoding 数据编码"></a>7.1.8 Data encoding 数据编码</h3><p>NRZI编码，电平信号不变表示1，跳变表示0。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607112056.png"></p><h3 id="7-1-9-Bit-Stuffing-位填充"><a href="#7-1-9-Bit-Stuffing-位填充" class="headerlink" title="7.1.9 Bit Stuffing 位填充"></a>7.1.9 Bit Stuffing 位填充</h3><p>连续传送6个1后，会填充一个0强制翻转信号。</p><h1 id="Chapter8-Protocol-Layer"><a href="#Chapter8-Protocol-Layer" class="headerlink" title="Chapter8 Protocol Layer"></a>Chapter8 Protocol Layer</h1><h2 id="8-2-SYNC-field"><a href="#8-2-SYNC-field" class="headerlink" title="8.2 SYNC field"></a>8.2 SYNC field</h2><p>对于低速/全速设备，SYNC信号是8位数据(从做到右是00000001)；对于高速设备，SYNC信号是32位数据(从左到右是00000000000000000000000000000001)。使用NRZI编码时，前面每个”0”都对应一个跳变。</p><p>同步域这样可以用来同步主机端和设备端的数据时钟。</p><h2 id="8-3-Packet-Field-Formats"><a href="#8-3-Packet-Field-Formats" class="headerlink" title="8.3 Packet Field Formats"></a>8.3 Packet Field Formats</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607150914.png"></p><h3 id="8-3-1-PID"><a href="#8-3-1-PID" class="headerlink" title="8.3.1 PID"></a>8.3.1 PID</h3><p>PID表示了包的类型。</p><p>PID后四位为前四位的取反。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607150746.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607151058.png"></p><h3 id="8-3-2-Address-fields"><a href="#8-3-2-Address-fields" class="headerlink" title="8.3.2 Address fields"></a>8.3.2 Address fields</h3><h4 id="8-3-2-1-Address-Field"><a href="#8-3-2-1-Address-Field" class="headerlink" title="8.3.2.1 Address Field"></a>8.3.2.1 Address Field</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607153555.png"></p><h4 id="8-3-2-2-Endpoint-Field"><a href="#8-3-2-2-Endpoint-Field" class="headerlink" title="8.3.2.2 Endpoint Field"></a>8.3.2.2 Endpoint Field</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607153606.png"></p><h3 id="8-3-3-Frame-Number-Field"><a href="#8-3-3-Frame-Number-Field" class="headerlink" title="8.3.3 Frame Number Field"></a>8.3.3 Frame Number Field</h3><p>11 bits。</p><h3 id="8-3-4-Data-Field"><a href="#8-3-4-Data-Field" class="headerlink" title="8.3.4 Data Field"></a>8.3.4 Data Field</h3><p>0-1024 bytes。</p><h2 id="8-4-Packet-Formats"><a href="#8-4-Packet-Formats" class="headerlink" title="8.4 Packet Formats"></a>8.4 Packet Formats</h2><h3 id="8-4-1-Token-Packets"><a href="#8-4-1-Token-Packets" class="headerlink" title="8.4.1 Token Packets"></a>8.4.1 Token Packets</h3><ul><li>OUT<ul><li>通知设备将要输出一个数据包。</li></ul></li><li>IN<ul><li>通知设备返回一个数据包。</li></ul></li><li>SETUP<ul><li>只用于控制传输，跟OUT令牌包作用一样，通知设备将要输出一个数据包。区别在于SETUP后只使用DATA0数据包，且只能发送到设备的endpoint，并且设备必须接收。</li></ul></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230607163045.png"></p><h3 id="8-4-3-SOF-packets"><a href="#8-4-3-SOF-packets" class="headerlink" title="8.4.3 SOF packets"></a>8.4.3 SOF packets</h3><ul><li>SOF<ul><li>以广播的形式发送，所有USB全速设备和高速设备都可以收到SOF包。host在full-speed bus每ms产生一个帧，在high-speed bus每125us产生一个微帧。USB主机会对当前帧号进行计数，在每次帧开始时（或者微帧开始时，每毫秒有8个微帧，这8个微帧的帧号是相同的，即相同的SOF）。</li></ul></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608111151.png"></p><h3 id="8-4-4-Data-Packets"><a href="#8-4-4-Data-Packets" class="headerlink" title="8.4.4 Data Packets"></a>8.4.4 Data Packets</h3><p>low-speed 最大8bytes。</p><p>full-speed 最大1023bytes。</p><p>high-speed 最大1024bytes。</p><h3 id="8-4-5-Handshake-Packets"><a href="#8-4-5-Handshake-Packets" class="headerlink" title="8.4.5 Handshake Packets"></a>8.4.5 Handshake Packets</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608112219.png"></p><ul><li><p>ACK</p><p>表示正确接受数据，并且有足够空间来容纳数据。主机和设备都可以用ACK来确认。而NAK, STALL, NYET只有设备能够返回。</p></li><li><p>NAK</p><p>表示设备无法从主机端接收数据，或者设备没有数据返回给主机。</p></li><li><p>STALL</p><p>表示设备无法执行这个请求，或者端点已经被挂起了，表示一种错误的状态。如果端点的Halt feature被设置了，会返回STALL。</p></li><li><p>NYET</p><p>只在high-speed输出事务中使用，表示设备本次数据成功接收，但是没有足够空间来接收下一次数据。主机在下一次输出数据时，将先使用PING令牌包来试探设备是否有足够空间接收数据。</p></li></ul><h3 id="8-4-6-Handshake-Response"><a href="#8-4-6-Handshake-Response" class="headerlink" title="8.4.6 Handshake Response"></a>8.4.6 Handshake Response</h3><h4 id="8-4-6-1-Function-Response-to-IN-Transactions"><a href="#8-4-6-1-Function-Response-to-IN-Transactions" class="headerlink" title="8.4.6.1 Function Response to IN Transactions"></a>8.4.6.1 Function Response to IN Transactions</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608113546.png"></p><h4 id="8-4-6-2-Host-Response-to-IN-Transactions"><a href="#8-4-6-2-Host-Response-to-IN-Transactions" class="headerlink" title="8.4.6.2 Host Response to IN Transactions"></a>8.4.6.2 Host Response to IN Transactions</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608114127.png"></p><h4 id="8-4-6-3-Function-Response-to-an-OUT-Transaction"><a href="#8-4-6-3-Function-Response-to-an-OUT-Transaction" class="headerlink" title="8.4.6.3 Function Response to an OUT Transaction"></a>8.4.6.3 Function Response to an OUT Transaction</h4><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608114206.png"></p><p>第三行对应If the transaction is maintaining sequence bit synchronization and a mismatch is detected (refer to Section 8.6 for details), then the function returns ACK and discards the data。</p><h3 id="8-5-2-Bulk-Transactions"><a href="#8-5-2-Bulk-Transactions" class="headerlink" title="8.5.2 Bulk Transactions"></a>8.5.2 Bulk Transactions</h3><p><strong>BULK IN:</strong></p><p>host端发送IN令牌包，device回应data或者NAK, STALL。NAK表示目前无法返回data，STALL表示endpoint已经被挂起了。</p><p>如果host端成功收到data，会回一个ACK握手包。如果有错误，不会返回握手包。 </p><p><strong>BULK OUT:</strong></p><p>host端发送OUT令牌包，紧接着data包或者PING包。</p><p>如果device端正确收到data，可能会回四种握手包：</p><ul><li><p>ACK: 数据正确，通知host可以发送下一个包。</p></li><li><p>NAK: 数据正确，但通知host需要重新发送数据，因为device端没能接收成功(比如 buffer full)。</p></li><li><p>STALL: endpoint挂起。</p></li><li><p>NYET: 只在high speed中存在。</p></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608135656.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608142617.png"></p><p>数据包类型在DATA0和DATA1之间切换。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608141406.png"></p><h3 id="8-5-3-Control-Transfer"><a href="#8-5-3-Control-Transfer" class="headerlink" title="8.5.3 Control Transfer"></a>8.5.3 Control Transfer</h3><p>Control 是transfer而不是transaction的原因是，control transfer由多个事务(transaction)组成。包括SETUP stage（SETUP事务），data stage（1个或者多个IN/OUT事务），status stage（1个IN事务）。Data Stage是可选的。</p><p>而Bulk/interrupt/isochronous transfer都是由对应的单独一个Bulk/interrupt/isochronous transaction组成。</p><p>下图为SETUP事务流程，Setup Stage必须是DATA0。如果device端正确收到SETUP data, 回复ACK握手包。如果数据错误丢弃数据并且不发送握手包。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608142906.png"></p><p>对应下图的<strong>Setup Stage</strong>。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608145713.png"></p><p><strong>Data stage</strong>：由一个或多个IN or OUT事务组成，和bulk transfer相同。</p><p><strong>Status stage</strong>：始终使用DATA1包，方向与前一个stage相反(如果没有data stage，则为IN)。见上图。</p><h4 id="8-5-3-1-Reporting-Status-Results"><a href="#8-5-3-1-Reporting-Status-Results" class="headerlink" title="8.5.3.1 Reporting Status Results"></a>8.5.3.1 Reporting Status Results</h4><p>status stage返回host Setup和Data stage的结果。</p><p>Control write在status stage的data phase返回status信息。</p><p>Control read在status stage的handshake phase返回status信息。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230613155449.png"></p><h3 id="8-5-4-Interrupt-Transactions"><a href="#8-5-4-Interrupt-Transactions" class="headerlink" title="8.5.4 Interrupt Transactions"></a>8.5.4 Interrupt Transactions</h3><p>和bulk transaction区别是没有PING和NYET两个包，interrupt 是周期性地发起传输。而不是传统的设备发出中断请求，cpu处理中断。所以USB的中断实际意义是实时查询操作。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608145003.png"></p><h3 id="8-5-5-Isochronous-Transactions"><a href="#8-5-5-Isochronous-Transactions" class="headerlink" title="8.5.5 Isochronous Transactions"></a>8.5.5 Isochronous Transactions</h3><p>没有handshake阶段。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608145252.png"></p><h1 id="Chapter9-Device-Framework"><a href="#Chapter9-Device-Framework" class="headerlink" title="Chapter9 Device Framework"></a>Chapter9 Device Framework</h1><p>USB的状态切换图：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609174140.png"></p><h2 id="9-3-USB-Device-Requests"><a href="#9-3-USB-Device-Requests" class="headerlink" title="9.3 USB Device Requests"></a>9.3 USB Device Requests</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612145851.png"></p><ul><li><p>bmRequestType：区分方向，type，device/interface/endpoint。</p></li><li><p>bRequest: 具体的事件，只定义了bmRequestType D[6:5]为Standard的情况。</p></li><li><p>wValue: 传递一些需要的值。</p></li><li><p>wIndex: 分为endpoint和interface，两种的wIndex不同。</p></li></ul><p><strong>endpoint:</strong></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612152356.png"></p><p>D7: 0:OUT 1:IN 在control pipe中direction应该被设为0，即OUT事件。但device可以接收0或1。</p><p><strong>interface:</strong></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612152452.png"></p><ul><li><p>wLength: control transfer第二段传递data0的字节数。如果wLength为0, 不需要传递数据，没有数据传输的阶段（注意这里的数据传输阶段是control transfer 中data0那段，是SETUP stage中那段）。</p><p>INPUT request wLength不能超过wLength字节数，可以比wLength少。</p><p>OUTPUT request wLength正确表示host传递给device的字节数。</p></li></ul><h2 id="9-4-Standard-Device-Requests"><a href="#9-4-Standard-Device-Requests" class="headerlink" title="9.4 Standard Device Requests"></a>9.4 Standard Device Requests</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230608170120.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612110946.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612111010.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612155242.png"></p><h3 id="9-4-1-Clear-Feature"><a href="#9-4-1-Clear-Feature" class="headerlink" title="9.4.1 Clear Feature"></a>9.4.1 Clear Feature</h3><p>在Address state下合法。Recipient为device or ep0合法，看Table9-6。</p><p>Test_Mode feature 不能被ClearFeature()清除。</p><h3 id="9-4-2-Get-configuration"><a href="#9-4-2-Get-configuration" class="headerlink" title="9.4.2 Get configuration"></a>9.4.2 Get configuration</h3><h3 id="9-4-3-Get-Descriptor"><a href="#9-4-3-Get-Descriptor" class="headerlink" title="9.4.3 Get Descriptor"></a>9.4.3 Get Descriptor</h3><p>wValue high byte是描述符的类型，具体参考Table9-5. </p><p>low byte是index</p><h3 id="9-4-5-Get-Status"><a href="#9-4-5-Get-Status" class="headerlink" title="9.4.5 Get Status"></a>9.4.5 Get Status</h3><p>bmRequestType为Device，device返回的信息。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612160419.png"></p><p>bmRequestType为Interface，status为0。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612160437.png"></p><p>bmRequestType为endpoint，返回是否halt。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230612160446.png"></p><p>所有interrupt和bulk endpoints都要实现Halt feature。</p><p>Default control pipe，即ep0 in and ep0 out，不需要也不推荐实现Halt feature。</p><h3 id="9-4-6-Set-Address"><a href="#9-4-6-Set-Address" class="headerlink" title="9.4.6 Set Address"></a>9.4.6 Set Address</h3><p>Default stage: 传递的地址不为0则进入Address stage， 为0则保持在Default stage。</p><p>Address stage: 传递的地址为0则进入Default stage，不为0则保持在Address stage，并更换新的地址。</p><p>地址不能超过127。</p><h3 id="9-4-7-Set-Configuration"><a href="#9-4-7-Set-Configuration" class="headerlink" title="9.4.7 Set Configuration"></a>9.4.7 Set Configuration</h3><h2 id="9-6-Standard-USB-Descriptor-Definitions"><a href="#9-6-Standard-USB-Descriptor-Definitions" class="headerlink" title="9.6 Standard USB Descriptor Definitions"></a>9.6 Standard USB Descriptor Definitions</h2><h3 id="9-6-1-Device-设备描述符"><a href="#9-6-1-Device-设备描述符" class="headerlink" title="9.6.1 Device 设备描述符"></a>9.6.1 Device 设备描述符</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609173233.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609173252.png"></p><h3 id="9-6-2-Device-qualifer"><a href="#9-6-2-Device-qualifer" class="headerlink" title="9.6.2 Device_qualifer"></a>9.6.2 Device_qualifer</h3><h3 id="9-6-3-Configuration-配置描述符"><a href="#9-6-3-Configuration-配置描述符" class="headerlink" title="9.6.3 Configuration 配置描述符"></a>9.6.3 Configuration 配置描述符</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609173911.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609173929.png"></p><h3 id="9-6-5-Interface-接口描述符"><a href="#9-6-5-Interface-接口描述符" class="headerlink" title="9.6.5 Interface 接口描述符"></a>9.6.5 Interface 接口描述符</h3><p>接口对应一种function。</p><p><img src="C:\Users\yucheng_xiang\AppData\Roaming\Typora\typora-user-images\image-20230609174005424.png" alt="image-20230609174005424"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609174012.png"></p><h3 id="9-6-6-Endpoint-端点描述符"><a href="#9-6-6-Endpoint-端点描述符" class="headerlink" title="9.6.6 Endpoint 端点描述符"></a>9.6.6 Endpoint 端点描述符</h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609174035.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609174043.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609174055.png"></p><h3 id="9-6-7-String-字符串描述符"><a href="#9-6-7-String-字符串描述符" class="headerlink" title="9.6.7 String 字符串描述符"></a>9.6.7 String 字符串描述符</h3>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>risc-v Lookup</title>
    <link href="/2023/05/26/Project/rCore_uCore/Lookup/"/>
    <url>/2023/05/26/Project/rCore_uCore/Lookup/</url>
    
    <content type="html"><![CDATA[<h1 id="CSRs"><a href="#CSRs" class="headerlink" title="CSRs"></a>CSRs</h1><p>参考riscv-privileged-20211203.pdf</p><h3 id="sstatus"><a href="#sstatus" class="headerlink" title="sstatus"></a><strong>sstatus</strong></h3><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230526094557.png"></p><p><strong>SPP</strong>: 在进入S mode之前hart处于什么mode。<br>用户态trap进入S mode，SPP被设置为0，其他情况为1。<br>如果SPP为0，执行SRET后，返回U mode。如果SPP为1，执行SRET后，返回S mode。随后SPP置0。</p><p><strong>SIE</strong>: 1开启/0关闭 S mode的所有中断 in S mode。<br>在U mode时，SIE被忽略，S mode 的中断都是打开的。</p><p><strong>SPIE</strong>: 当trap进入S mode，SIE会置0禁止S mode所有中断，SIE的旧值会保存到SPIE中。<br>执行SRET后，SIE被设置为SPIE中之前保存的旧值，SPIE置1。</p><h3 id="stvec"><a href="#stvec" class="headerlink" title="stvec"></a><strong>stvec</strong></h3><p>Supervisor Trap Vector Base Address Register, <strong>保存S mode异常/中断的跳转地址。</strong></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230526104414.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230526104502.png"></p><p>MODE为0，直接跳转到BASE；MODE为1，跳转到BASE + cause * 4。</p><p>在linux entry.S中的做法为直接设置stvec为handle_exception地址，地址的后两位肯定是4bytes对齐的，所以为00。跳转到handle_exception后，分开处理中断、系统调用、异常。根据异常cause再跳转到不同的异常处理函数。</p><h3 id="SIP-SIE"><a href="#SIP-SIE" class="headerlink" title="SIP SIE"></a><strong>SIP SIE</strong></h3><p>Supervisor Interrupt pending/enable Registers</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230526111246.png"></p><ol><li>SIP中断挂起（待处理的中断）和SIE中断使能。每一位代表的中断与scause中的为每个中断分配的异常码一致。</li><li>当sstatus.SIE=1, SIP[x]=1, SIE[x]=1，表示系统能够处理某个中断。</li><li>SIP中有的位是只读的，不能通过直接写0来清除：<ol><li>SEIP is read-only in sip, and is set and cleared by the <strong>execution environment</strong>, typically through a <strong>platform-specific interrupt controller</strong>.</li><li>STIP is read-only in sip, and is set and cleared by the <strong>execution environment</strong>.</li><li>SSIP is writable in sip and may also be set to 1 by a <strong>platform-specific interrupt controller</strong>.</li></ol></li><li>看系统中实现了哪些interrupts，可以直接通过写SIE某位为1来enable，再读回SIE看是否为1，来判断是否实现了。</li><li>sip，sie的bit 3，7，11分别代表了M mode的software，timer，external interrupts，因为大多数平台不会将M mode的中断委托到S mode，所以图4.6和4.7中相应的位直接为0了。</li><li>优先级：SEI&gt;SSI&gt;STI。</li></ol><h3 id="scounteren"><a href="#scounteren" class="headerlink" title="scounteren"></a>scounteren</h3><h3 id="sscratch"><a href="#sscratch" class="headerlink" title="sscratch"></a>sscratch</h3><h3 id="sepc"><a href="#sepc" class="headerlink" title="sepc"></a>sepc</h3><p>Supervisor Exception Program Counter.</p><p>当trap发生时，sepc<strong>保存发生中断/异常指令的虚拟地址</strong>。</p><p>如果需要返回到sepc后一条指令，就需要在sret之前修改sepc的值。</p><p>对于同步异常，sepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。</p><h3 id="scause"><a href="#scause" class="headerlink" title="scause"></a>scause</h3><p><strong>保存发生中断/异常指令的事件</strong>。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230601170420.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230601170540.png"></p><h3 id="stval"><a href="#stval" class="headerlink" title="stval"></a>stval</h3><p>kernel中<code>/ptrace.h pt_regs中的badaddr</code>就是stval。发生kernel panic会打印出badaddr(stval)。</p><ul><li><p>当instruction fetch/load/store时发生breakpoint(3), address-misaligned, access-fault, page-fault，stval会保存导致错误的虚拟地址。</p></li><li><p>当发生不对齐load/store导致的access-fault/page-fault, stval包含导致故障访问的虚拟地址。</p></li><li><p>当发生instruction access-fault(1) or page-fault(12)，stval保存导致故障的指令的虚拟地址，此时sepc也会指向指令的开始地址。</p></li><li><p>illegal instruction(2), spec71页。</p></li><li><p>其他trap，还没实现，stval的值都为0。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spi Subsystem</title>
    <link href="/2023/05/22/Note/Linux_Driver/SPI/"/>
    <url>/2023/05/22/Note/Linux_Driver/SPI/</url>
    
    <content type="html"><![CDATA[<h1 id="1-SPI协议介绍"><a href="#1-SPI协议介绍" class="headerlink" title="1. SPI协议介绍"></a>1. SPI协议介绍</h1><p>CPOL:表示SPICLK的初始电平，0为低电平，1为高电平</p><p>CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p><table><thead><tr><th>CPOL</th><th>CPHA</th><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>SPICLK初始电平为低电平，在第一个时钟沿采样数据</td></tr><tr><td>0</td><td>1</td><td>1</td><td>SPICLK初始电平为低电平，在第二个时钟沿采样数据</td></tr><tr><td>1</td><td>0</td><td>2</td><td>SPICLK初始电平为高电平，在第一个时钟沿采样数据</td></tr><tr><td>1</td><td>1</td><td>3</td><td>SPICLK初始电平为高电平，在第二个时钟沿采样数据</td></tr></tbody></table><p>我们常用的是模式0和模式3，因为它们都是在上升沿采样数据，不用去在乎时钟的初始电平是什么，只要在上升沿采集数据就行。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230522180216.png"></p><h1 id="2-SPI-driver"><a href="#2-SPI-driver" class="headerlink" title="2. SPI driver"></a>2. SPI driver</h1><h2 id="2-2-spi-controller"><a href="#2-2-spi-controller" class="headerlink" title="2.2 spi_controller"></a>2.2 spi_controller</h2><p>include/linux/spi.h</p><h2 id="2-3-spi-device"><a href="#2-3-spi-device" class="headerlink" title="2.3 spi_device"></a>2.3 spi_device</h2><p>include/linux/spi.h</p><h2 id="2-4-spi-transfer、spi-message"><a href="#2-4-spi-transfer、spi-message" class="headerlink" title="2.4 spi_transfer、spi_message"></a>2.4 spi_transfer、spi_message</h2><p>在SPI子系统中，用spi_transfer结构体描述一个传输，用spi_message管理整个传输。可以构造多个spi_transfer结构体，把它们放入一个spi_message里面。</p><p>SPI传输时，发出N个字节，就可以同时得到N个字节。</p><ul><li>即使只想读N个字节，也必须发出N个字节：可以发出0xff</li><li>即使只想发出N个字节，也会读到N个字节：可以忽略读到的数据。</li></ul><h1 id="3-SPI-设备树处理"><a href="#3-SPI-设备树处理" class="headerlink" title="3. SPI 设备树处理"></a>3. SPI 设备树处理</h1><p><strong>SPI Master</strong></p><p>必须的属性如下：</p><ul><li>address-cells：这个SPI Master下的SPI设备，需要多少个cell来表述它的片选引脚</li><li>size-cells：必须设置为0</li><li>compatible：根据它找到SPI Master驱动</li></ul><p>可选的属性如下：</p><ul><li>cs-gpios：SPI Master可以使用多个GPIO当做片选，可以在这个属性列出那些GPIO</li><li>num-cs：片选引脚总数</li></ul><p><strong>SPI Device</strong></p><p>必须的属性如下：</p><ul><li>compatible：根据它找到SPI Device驱动</li><li>reg：用来表示它使用哪个片选引脚</li><li>spi-max-frequency：必选，该SPI设备支持的最大SPI时钟</li></ul><p>可选的属性如下：</p><ul><li>spi-cpol：这是一个空属性(没有值)，表示CPOL为1，即平时SPI时钟为低电平</li><li>spi-cpha：这是一个空属性(没有值)，表示CPHA为1)，即在时钟的第2个边沿采样数据</li><li>spi-cs-high：这是一个空属性(没有值)，表示片选引脚高电平有效</li><li>spi-3wire：这是一个空属性(没有值)，表示使用SPI 三线模式</li><li>spi-lsb-first：这是一个空属性(没有值)，表示使用SPI传输数据时先传输最低位(LSB)</li><li>spi-tx-bus-width：表示有几条MOSI引脚；没有这个属性时默认只有1条MOSI引脚</li><li>spi-rx-bus-width：表示有几条MISO引脚；没有这个属性时默认只有1条MISO引脚</li><li>spi-rx-delay-us：单位是毫秒，表示每次读传输后要延时多久</li><li>spi-tx-delay-us：单位是毫秒，表示每次写传输后要延时多久</li></ul><p>示例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">spi@f00 {<br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>    compatible = <span class="hljs-string">"fsl,mpc5200b-spi"</span>,<span class="hljs-string">"fsl,mpc5200-spi"</span>;<br>    reg = &lt;<span class="hljs-number">0xf00</span> <span class="hljs-number">0x20</span>&gt;;<br>    interrupts = &lt;<span class="hljs-number">2</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">14</span> <span class="hljs-number">0</span>&gt;;<br>    interrupt-parent = &lt;&amp;mpc5200_pic&gt;;<br><br>    ethernet-<span class="hljs-keyword">switch</span>@<span class="hljs-number">0</span> {<br>      compatible = <span class="hljs-string">"micrel,ks8995m"</span>;<br>      spi-max-frequency = &lt;<span class="hljs-number">1000000</span>&gt;;<br>      reg = &lt;<span class="hljs-number">0</span>&gt;;<br>    };<br><br>    codec@<span class="hljs-number">1</span> {<br>      compatible = <span class="hljs-string">"ti,tlv320aic26"</span>;<br>      spi-max-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br>      reg = &lt;<span class="hljs-number">1</span>&gt;;<br>    };<br>  };<br></code></pre></td></tr></tbody></table></figure><h1 id="4-spidev的使用-SPI用户态API"><a href="#4-spidev的使用-SPI用户态API" class="headerlink" title="4. spidev的使用(SPI用户态API)"></a>4. spidev的使用(SPI用户态API)</h1><ul><li>内核驱动：<code>drivers\spi\spidev.c</code></li><li>内核提供的测试程序：<code>tools\spi\spidev_fdx.c</code></li><li>内核文档：<code>Documentation\spi\spidev</code></li></ul><h2 id="4-1-spidev驱动程序分析"><a href="#4-1-spidev驱动程序分析" class="headerlink" title="4.1 spidev驱动程序分析"></a>4.1 spidev驱动程序分析</h2><p>内核驱动：<code>drivers\spi\spidev.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">spidev_write();<br>  spidev_sync_write();<br>    spidev_sync();<br><br>spidev_read();<br>  spidev_sync_read();<br>    spidev_sync();<br><br>spidev_ioctl();<br><span class="hljs-comment">// 在应用层通过ioctl(fd, SPI_IOC_MESSAGE(x), xfer) 来调用，进行spi传输. 参考spidev_fdx.c</span><br></code></pre></td></tr></tbody></table></figure><h2 id="4-2-spidev应用程序分析"><a href="#4-2-spidev应用程序分析" class="headerlink" title="4.2 spidev应用程序分析"></a>4.2 spidev应用程序分析</h2><p>内核提供的测试程序：<code>tools\spi\spidev_fdx.c</code></p><p>使用方法：</p><p>spidev_fdx [-h] [-m N] [-r N] /dev/spidevB.D</p><p>h: 打印用法</p><p>m N：先写1个字节0xaa，再读N个字节，<strong>注意：</strong>不是同时写同时读</p><p>r N：读N个字节</p><h2 id="4-3-spidev缺点"><a href="#4-3-spidev缺点" class="headerlink" title="4.3 spidev缺点"></a>4.3 spidev缺点</h2><p>使用read、write函数时，只能读、写，这是半双工方式。</p><p>使用ioctl可以达到全双工的读写。</p><p>但是spidev有2个缺点：</p><ul><li>不支持中断</li><li>只支持同步操作，不支持异步操作：就是read/write/ioctl这些函数只能执行完毕才可返回</li></ul><h3 id="5-1-SPI传输接口函数"><a href="#5-1-SPI传输接口函数" class="headerlink" title="5.1 SPI传输接口函数"></a>5.1 SPI传输接口函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">/include/linux/spi/spi.h<br><span class="hljs-comment">// 简易函数</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len)</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_write_then_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *txbuf, <span class="hljs-type">unsigned</span> n_tx, <span class="hljs-type">void</span> *rxbuf, <span class="hljs-type">unsigned</span> n_rx)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">spi_w8r8</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 cmd)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">spi_w8r16</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 cmd)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">spi_w8r16be</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, u8 cmd)</span>;<br><br><span class="hljs-comment">// 复杂函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_async</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_sync</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_message *message)</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spi_sync_transfer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spi_device *spi, <span class="hljs-keyword">struct</span> spi_transfer *xfers, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_xfers)</span>;<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust</title>
    <link href="/2023/05/20/Book/23_05-20_Rust/"/>
    <url>/2023/05/20/Book/23_05-20_Rust/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><ol><li><code>Even Better TOML</code>，支持 .toml 文件完整特性</li><li><code>Error Lens</code>, 更好的获得错误展示</li><li><code>One Dark Pro</code>, 非常好看的 VSCode 主题</li><li><code>CodeLLDB</code>, Debugger 程序</li></ol><h2 id="1-3-Cargo"><a href="#1-3-Cargo" class="headerlink" title="1.3 Cargo"></a>1.3 Cargo</h2><p><code>cargo new hello_world</code></p><p><code>tree</code></p><p><code>cargo run</code> is equal to <code>cargo build</code> + <code>./target/debug/world_hello</code> 默认的是debug模式，编译器不会做任何的优化，编译速度快，运行慢。</p><p>高性能模式，生产发布模式：</p><p><code>cargo run --release</code></p><p><code>cargo build --release</code></p><p><code>cargo check</code> 检查编译能否通过</p><p><code>cargo.toml</code> <strong>项目数据描述文件</strong></p><p><code>cargo.lock</code> <strong>项目依赖详细清单</strong></p><p>在cargo.toml中定义依赖的三种方式：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">[dependencies]<br>rand = <span class="hljs-string">"0.3"</span><br>hammer = { version = <span class="hljs-string">"0.5.0"</span>}<br>color = { git = <span class="hljs-string">"https://github.com/bjz/color-rs"</span> }<br>geometry = { path = <span class="hljs-string">"crates/geometry"</span> }<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-Rust-基础入门"><a href="#2-Rust-基础入门" class="headerlink" title="2. Rust 基础入门"></a>2. Rust 基础入门</h1><h2 id="2-1-变量绑定与解构"><a href="#2-1-变量绑定与解构" class="headerlink" title="2.1 变量绑定与解构"></a>2.1 变量绑定与解构</h2><h3 id="变量绑定与可变性"><a href="#变量绑定与可变性" class="headerlink" title="变量绑定与可变性"></a>变量绑定与可变性</h3><p>变量只有初始化之后才能使用。如下会报错。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span>; <span class="hljs-comment">// 未初始化，但被使用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x is equal to {}"</span>, x); <br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h3><p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。</p><p><code>let _x = 5; </code></p><h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><p><code>let (a, mut b): (bool,bool) = (true, false); // a = true,不可变; b = false，可变</code></p><h3 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h3><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>常量不允许使用 <code>mut</code>，<strong>常量不仅仅默认不可变，而且自始至终不可变</strong>。</li><li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明，并且值的类型<strong>必须</strong>标注。</li></ul><p>Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性。</p><p><code>const MAX_POINTS: u32 = 100_000;</code></p><h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p><h2 id="2-2-基本类型"><a href="#2-2-基本类型" class="headerlink" title="2.2 基本类型"></a>2.2 基本类型</h2><ul><li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li><li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li><li>布尔类型： <code>true</code>和<code>false</code></li><li>字符类型: <code>char</code>表示单个 Unicode 字符，存储为 4 个字节</li><li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li></ul><h3 id="2-2-1-数值类型"><a href="#2-2-1-数值类型" class="headerlink" title="2.2.1 数值类型"></a>2.2.1 数值类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p><ul><li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li><li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li><li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li><li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li></ul><p>下面是一个演示<code>wrapping_*</code>方法的示例：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> : <span class="hljs-type">u8</span> = <span class="hljs-number">255</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">wrapping_add</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, b);  <span class="hljs-comment">// 19</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p><ul><li>避免在浮点数上测试相等性</li><li>当结果在数学上可能存在未定义时，需要格外的小心</li></ul><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>所有跟 <code>NaN</code> 交互的操作，都会返回一个 <code>NaN</code></p><h4 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h4><p>只有同样类型，才能运算。</p><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>生成连续的数值，例如 <code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5。常常用于循环中：</p><p>序列只允许用于数字或字符类型。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> {<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>,i);<br>}<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'a'</span>..=<span class="hljs-string">'z'</span> {<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>,i);<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数。</p><h3 id="2-2-2-字符、布尔、单元类型"><a href="#2-2-2-字符、布尔、单元类型" class="headerlink" title="2.2.2 字符、布尔、单元类型"></a>2.2.2 字符、布尔、单元类型</h3><p>Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符。</p><p>字符类型<code>char</code>占用 4 个字节。</p><p>单元类型就是 <code>()</code> 。完全<strong>不占用</strong>任何内存。</p><h3 id="2-2-3-语句和表达式"><a href="#2-2-3-语句和表达式" class="headerlink" title="2.2.3 语句和表达式"></a>2.2.3 语句和表达式</h3><p><strong>表达式不能包含分号</strong>，表达式如果不返回任何值，会隐式地返回一个 <code>()</code></p><h3 id="2-2-4-函数"><a href="#2-2-4-函数" class="headerlink" title="2.2.4 函数"></a>2.2.4 函数</h3><p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dead_end</span>() <span class="hljs-punctuation">-&gt;</span> ! {<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"你已经到了穷途末路，崩溃吧！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="2-3-所有权和借用"><a href="#2-3-所有权和借用" class="headerlink" title="2.3 所有权和借用"></a>2.3 所有权和借用</h2><h3 id="2-3-1-所有权"><a href="#2-3-1-所有权" class="headerlink" title="2.3.1 所有权"></a>2.3.1 所有权</h3><ol><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li></ol><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 由于 Rust 禁止你使用无效的引用，错误</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}, world!"</span>, s1);<br>}<br><br><br><span class="hljs-comment">// 不报错，这个例子中，`x` 只是引用了存储在二进制中的字符串 `"hello, world"`，并没有持有所有权。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">"hello, world"</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{},{}"</span>,x,y);<br>}<br><br><span class="hljs-comment">// Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">"hello, world"</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{},{}"</span>,x,y);<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>clone</code></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"s1 = {}, s2 = {}"</span>, s1, s2);<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。</p><ul><li>所有整数类型，比如 <code>u32</code></li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li><li>所有浮点数类型，比如 <code>f64</code></li><li>字符类型，<code>char</code></li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li><li>不可变引用 <code>&amp;T</code> ，例如转移所有权中的最后一个例子&amp;str，<strong>但是注意: 可变引用 <code>&amp;mut T</code> 是不可以 Copy的</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Driver Common Essentials</title>
    <link href="/2023/05/19/Note/Linux_Driver/Universal/"/>
    <url>/2023/05/19/Note/Linux_Driver/Universal/</url>
    
    <content type="html"><![CDATA[<h1 id="NOT-indexed"><a href="#NOT-indexed" class="headerlink" title="NOT indexed"></a>NOT indexed</h1><p>include &lt;asm/xxx.h&gt; 先找arch/xxx/include/xxx.h，没有的话就找/include/asm-generic/xxx.h</p><p>从dts中获取regs地址并映射到virtual address:</p><p>linux5.10: void __iomem *devm_platform_get_and_ioremap_resource(struct platform_device *pdev, unsigned int index, struct resource **res)</p><p>linux5.4: void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev, unsigned int index)</p><p>相当于platform_get_resource + devm_request_mem_region <strong>+</strong> devm_ioremap</p><p>linux链表相关操作：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_entry(ptr, type, member) \ <span class="hljs-comment">/// list_entry作用和container_of相同</span></span><br>  container_of(ptr, type, member)<br><br>container_of(ptr, type, member)<br><br><span class="hljs-comment">// ptr:表示结构体中member的地址h(已知的)</span><br><span class="hljs-comment">// type:表示结构体类型 struct xxx</span><br><span class="hljs-comment">// member:表示结构体中的成员 yyy</span><br><span class="hljs-comment">// 返回结构体的首地址</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * list_for_each_entry  -iterate over list of given type</span><br><span class="hljs-comment"> * @pos:  the type * to use as a loop cursor. pos中的list_head被加入了第二个成员head中</span><br><span class="hljs-comment"> * @head:  the head for your list. 要循环的链表</span><br><span class="hljs-comment"> * @member:  the name of the list_head within the struct. pos中的list_head链表对象</span><br><span class="hljs-comment"> */</span><br>list_for_each_entry(pos, head, member)<br></code></pre></td></tr></tbody></table></figure><h1 id="Initcalls"><a href="#Initcalls" class="headerlink" title="Initcalls"></a>Initcalls</h1><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230524150950.png"></p><ul><li><p>图中initcalls优先级从上到下。这些都是只能用于builtin的modules。loadable的modules使用module_init()。</p></li><li><p>使用initcalls会在目标文件object file中创建ELF sections。</p></li></ul><p><strong>module_init()</strong></p><p>本质是device_initcall。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> module_init(x)  __initcall(x);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __initcall(fn) device_initcall(fn)</span><br></code></pre></td></tr></tbody></table></figure><p>kernel的<code>System.map</code>可以查看符号文件，其中<code>__initcall6_start</code>后的顺序就对应<code>device_initcall</code>的驱动加载顺序。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> pure_initcall(fn)    __define_initcall(fn, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> core_initcall(fn)    __define_initcall(fn, 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> postcore_initcall(fn)    __define_initcall(fn, 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> arch_initcall(fn)    __define_initcall(fn, 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> subsys_initcall(fn)    __define_initcall(fn, 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs_initcall(fn)      __define_initcall(fn, 5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rootfs_initcall(fn)    __define_initcall(fn, rootfs)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> device_initcall(fn)    __define_initcall(fn, 6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> late_initcall(fn)    __define_initcall(fn, 7)</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uCore_Chapter3 多道程序与分时多任务</title>
    <link href="/2023/05/17/Project/rCore_uCore/uCore_Chapter3/"/>
    <url>/2023/05/17/Project/rCore_uCore/uCore_Chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="分时多任务系统与抢占式调度"><a href="#分时多任务系统与抢占式调度" class="headerlink" title="分时多任务系统与抢占式调度"></a>分时多任务系统与抢占式调度</h1><h2 id="RISC-V架构中断"><a href="#RISC-V架构中断" class="headerlink" title="RISC-V架构中断"></a>RISC-V架构中断</h2><p>以内核所在的 S 特权级为例，中断屏蔽相应的 <code>CSR</code> 有 <code>sstatus</code> 和 <code>sie</code> 。<code>sstatus</code> 的 <code>sie</code> 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 <code>sstatus.sie</code> 置 1 ，还要看 <code>sie</code> 这个 CSR，它的三个字段 <code>ssie/stie/seie</code> 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。</p><ul><li>当 Trap 发生时，<code>sstatus.sie</code> 会被保存在 <code>sstatus.spie</code> 字段中，同时 <code>sstatus.sie</code> 置零，这也就在 Trap 处理的过程中屏蔽了所有 S 特权级的中断；</li><li>当 Trap 处理完毕 <code>sret</code> 的时候， <code>sstatus.sie</code> 会恢复到 <code>sstatus.spie</code> 内的值。</li></ul><p>也就是说，如果不去手动设置 <code>sstatus</code> CSR ，在只考虑 S 特权级中断的情况下，是不会出现 <strong>嵌套中断</strong> (Nested Interrupt) 的。</p><p>嵌套中断可以分为两部分：在处理一个中断的过程中又被同特权级/高特权级中断所打断。默认情况下硬件会避免前一部分，也可以通过手动设置来允许前一部分的存在；而从上面介绍的规则可以知道，后一部分则是无论如何设置都不可避免的。</p><h2 id="时钟中断与计时器"><a href="#时钟中断与计时器" class="headerlink" title="时钟中断与计时器"></a>时钟中断与计时器</h2><p>计数器保存在一个 64 位的 CSR <code>mtime</code></p><p>另外一个 64 位的 CSR <code>mtimecmp</code> 的作用是：一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断。这使得我们可以方便的通过设置 <code>mtimecmp</code> 的值来决定下一次时钟中断何时触发。</p><h1 id="Chapter3-练习"><a href="#Chapter3-练习" class="headerlink" title="Chapter3 练习"></a>Chapter3 练习</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    clean_bss();    <span class="hljs-comment">// 清空 bss 段    </span><br>    proc_init();     <span class="hljs-comment">// 初始化线程池</span><br>    loader_init();   <span class="hljs-comment">// 初始化 app_info_ptr 指针</span><br>    trap_init();     <span class="hljs-comment">// 开启中断</span><br>      set_kerneltrap(); <span class="hljs-comment">// 设置异常/中断入口为kerneltrap</span><br>        w_stvec((uint64)kerneltrap &amp; ~<span class="hljs-number">0x3</span>);<br>    timer_init();    <span class="hljs-comment">// 开启时钟中断，现在还没有</span><br>    run_all_app();  <span class="hljs-comment">// 加载所有用户程序</span><br>    scheduler();    <span class="hljs-comment">// 开始调度</span><br>      swtch(&amp;idle.context, &amp;p-&gt;context);<br>}<br><span class="hljs-comment">// swtch执行完后，会返回p-&gt;context.ra，在allocproc中设置为usertrapret，返回应用态</span><br>usertrapret();<br>  set_usertrap(); <span class="hljs-comment">// 这里设置异常、中断入口为uservec</span><br>  userret();<br>    sret<br>    <span class="hljs-comment">//...</span><br>usertrap(); <span class="hljs-comment">//应用程序异常/系统调用/中断入口</span><br>  set_kerneltrap();<br></code></pre></td></tr></tbody></table></figure><p>首先在kernel中<code>proc.h</code>中定义<code>TaskStatus</code>和<code>TaskInfo</code>与用户态对应上。注意到这里<code>TaskInfo</code>中添加了<code>t0</code>和<code>count</code>成员，是用户态没有的，这里是自己实现lab时候hack的做法。</p><p>在<code>struct proc</code>中添加 <code>TaskInfo *info</code>成员，用来记录进程的信息。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> {</span><br>  UnInit,<br>  Ready,<br>  Running,<br>  Exited,<br>} TaskStatus;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>  TaskStatus status;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> syscall_times[MAX_SYSCALL_NUM];<br>  <span class="hljs-type">int</span> time;<br>  <span class="hljs-type">int</span> t0;<br>  <span class="hljs-type">int</span> count;<br>} TaskInfo;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span><br>  <span class="hljs-comment">//...</span><br>  TaskInfo *info;<br>};<br></code></pre></td></tr></tbody></table></figure><p><code>syscall_ids.h</code>中定义<code>sys_task_info</code>系统调用号</p><p><code>#define SYS_task_info 410</code></p><p>注意到<code>proc.c</code>中定义了<code>__attribute__((aligned(4096))) char trapframe[NPROC][PAGE_SIZE]</code> proc_init初始化的时候</p><p><code>p-&gt;trapframe = (struct trapframe *)trapframe[p - pool];</code> 这个操作，看起来是先静态定义NPROC个<code>trapframe[PAGE_SIZE]</code>，在init的时候再分配，把NPROC个<code>trapframe[PAGE_SIZE]</code>转化成<code>(struct trapframe *)</code>。这里看起来是数组与指针之间的转化关系。</p><p><code>__attribute__((aligned(4096))) char ustack[NPROC][PAGE_SIZE];</code>则进行这样的转化：<code>p-&gt;kstack = (uint64)kstack[p - pool];</code>把NPROC个<code>char ustack[PAGE_SIZE]</code>转化成<code>uint64</code>了。</p><p><code>proc.c</code> <code>proc_init()</code>中添加初始化<code>proc</code>中<code>TaskInfo</code>的部分</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__((aligned(<span class="hljs-number">4096</span>))) <span class="hljs-type">char</span> info[NPROC][PAGE_SIZE];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-keyword">for</span> (p = pool; p &lt; &amp;pool[NPROC]; p++) {<br>    <span class="hljs-comment">//...</span><br>    p-&gt;info = (TaskInfo *)info[p - pool];<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>proc.c</code> 在<code>scheduler()</code>在进程被调度后，proc-&gt;TaskInfo的t0变量记录刚被调度的时间点。并初始化proc-&gt;TaskInfo-&gt;status为Running。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (p-&gt;info-&gt;count == <span class="hljs-number">0</span>) {<br>        p-&gt;info-&gt;t0 = get_cycle() / CPU_FREQ * <span class="hljs-number">1000</span> + (get_cycle() % CPU_FREQ) * <span class="hljs-number">1000</span> / CPU_FREQ; <span class="hljs-comment">//前面是s转化成ms，后面是余下的ms</span><br>        p-&gt;info-&gt;count++;<br>    }<br>    p-&gt;info-&gt;status = Running;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当应用程序调用sys_task_info后，流程为：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ch3_taskinfo.c</span><br>sys_task_info(&amp;info);<br><span class="hljs-comment">// user/lib/syscall.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_task_info</span><span class="hljs-params">(TaskInfo *ti)</span><br>    <span class="hljs-title function_">syscall</span><span class="hljs-params">(SYS_task_info, ti)</span>;<br><span class="hljs-comment">// os/syscall.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">case</span> SYS_task_info:<br>    sys_task_info();<br></code></pre></td></tr></tbody></table></figure><p>在<code>os/syscall.c</code>中添加sys_task_info系统调用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_task_info</span><span class="hljs-params">(TaskInfo *info)</span><br>{<br>  uint64 t1 = get_cycle() / CPU_FREQ * <span class="hljs-number">1000</span> + (get_cycle() % CPU_FREQ) * <span class="hljs-number">1000</span> / CPU_FREQ; <span class="hljs-comment">// s + ms</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">proc</span> =</span> curr_proc();<br>  info-&gt;status = proc-&gt;info-&gt;status;<br>  info-&gt;time = t1 - proc-&gt;info-&gt;t0;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_SYSCALL_NUM; i++)<br>    info-&gt;syscall_times[i] = curr_proc()-&gt;info-&gt;syscall_times[i];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h2><p><strong>1</strong></p><p><strong>2.1</strong> L79:刚进入 userret 时，a0、a1 分别代表了什么值。</p><p>a0代表了trameframe的地址。从userret((uint64)trapframe)可以发现。</p><p>a1代表了</p><p><strong>2.2</strong> L87-L88: sfence 指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？</p><p><strong>清除TLB缓存</strong><br>所有现代的处理器都用TLB来减少开销。为了降低这个缓存本身的开销，大多数处理器不会让它时刻与页表保持一致。这意味着如果操作系统修改了页表，那么这个缓存会变得陈旧而不可用。S 模式添加了另一条指令来解决这个问题。这条<code>sfence.vma</code> 会通知处理器，软件可能已经修改了页表，于是处理器可以相应地刷新转换缓存。它需要两个可选的参数，这样可以缩小缓存刷新的范围。一个位于 rs1，它指示了页表哪个虚址对应的转换被修改了；另一个位于 rs2，它给出了被修改页表的进程的地址空间标识符（ASID）。如果两者都是 x0，便会刷新整个转换缓存。</p><p>本章中还没引入页表，不会导致错误。</p><p><strong>2.3</strong> L96-L125: 为何注释中说要除去 a0？哪一个地址代表 a0？现在 a0 的值存在何处？</p><p>因为a0保存着trameframe的地址，其他寄存器的值都保存在trameframe中。a0的值存入sscratch寄存器。</p><p><strong>2.4</strong> userret：中发生状态切换在哪一条指令？为何执行之后会进入用户态？</p><p>sret。sret指令会返回spec寄存器中保存的返回地址。在w_sepc(trapframe-&gt;epc)中设置为trapframe-&gt;epc。</p><p>**2.5 **L29：执行之后，a0 和 sscratch 中各是什么值，为什么？</p><p>执行之后，a0为trapframe地址，sscrach为用户态传进来的第一个参数。</p><p><strong>2.6</strong> L32-L61: 从 trapframe 第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？</p><p>第六项trapframe-&gt;ra开始保存。</p><p><strong>2.7</strong> 进入 S 态是哪一条指令发生的？</p><p>ecall</p><p><strong>2.8</strong> L75-L76: ld t0, 16(a0) 执行之后，t0中的值是什么，解释该值的由来？</p><p>usertrap()的地址，  usertrapret中设置了trapframe-&gt;kernel_trap = (uint64)usertrap。</p><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uart Subsystem</title>
    <link href="/2023/05/15/Note/Linux_Driver/Uart/"/>
    <url>/2023/05/15/Note/Linux_Driver/Uart/</url>
    
    <content type="html"><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.kernel.org/doc/Documentation/serial/driver">https://www.kernel.org/doc/Documentation/serial/driver</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>波特率115200，bps每秒传输的bit数。</p><p>每一位1/115200秒，传输1byte需要10位（start, data, stop）,那么每秒能传11520byte。</p><p>115200，8n1。8:data，n:校验位不用，1：停止位。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230522151159.png"></p><h1 id="TTY体系中设备节点的差别"><a href="#TTY体系中设备节点的差别" class="headerlink" title="TTY体系中设备节点的差别"></a>TTY体系中设备节点的差别</h1><p>不关心终端是真实的还是虚拟的，都可以通过/dev/tty找到当前终端。</p><p><strong>/dev/console</strong></p><p>内核的打印信息可以通过cmdline来选择打印到哪个设备。</p><p>console=ttyS0 console=tty</p><p>console=ttyS0时，/dev/console就是ttyS0</p><p>console=ttyN时，/dev/console就是/dev/ttyN</p><p>console=tty时，/dev/console就是前台程序的虚拟终端</p><p>console=tty0时，/dev/console就是前台程序的虚拟终端</p><p>console有多个取值时，使用最后一个取值来判断。</p><p><strong>/dev/tty 和/dev/tty0区别</strong></p><p><code>/dev/tty</code>表示当前进程的控制终端，也就是当前进程与用户交互的终端。</p><p><code>/dev/tty0</code>则是当前所使用虚拟终端的一个别名</p><h1 id="Linux串口应用编程"><a href="#Linux串口应用编程" class="headerlink" title="Linux串口应用编程"></a>Linux串口应用编程</h1><p><a href="https://digilander.libero.it/robang/rubrica/serial.htm">https://digilander.libero.it/robang/rubrica/serial.htm</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">termios</span> <span class="hljs-title">options</span>;</span><br><br>open(<span class="hljs-string">"/dev/ttyS1"</span>, O_RDWR | O_NOCTTY | O_NDELAY)<span class="hljs-comment">// O_NOCTTY: 不用作控制终端 O_NDELAY: 使I/O变成非阻塞模式</span><br><br><br>fcntl(fd, F_SETFL, <span class="hljs-number">0</span>): <span class="hljs-comment">//读数据时，没有数据则阻塞等待</span><br>fcntl(fd, F_SETFL, FNDELAY): <span class="hljs-comment">//读数据时不等待，没有数据就返回0</span><br><br><br><span class="hljs-comment">/* c_cflag: Control Options */</span><br>options.c_cflag |= (CLOCAL | CREAD); <span class="hljs-comment">// 必须打开 Enable the receiver and set local mode</span><br><br>options.c_cflag &amp;= ~CSIZE; <span class="hljs-comment">/* Mask the character size bits */</span><br>options.c_cflag |= CS8;    <span class="hljs-comment">/* Select 8 data bits */</span><br><br>cfsetispeed(&amp;options, B19200); <span class="hljs-comment">//设置input output波特率</span><br>cfsetospeed(&amp;options, B19200);<br><br>options.c_cflag &amp;= ~PARENB <span class="hljs-comment">// no parity</span><br>options.c_cflag &amp;= ~CSTOPB<br><br>options.c_cflag &amp;= ~CNEW_RTSCTS; <span class="hljs-comment">// RTS CTS</span><br><br><br><span class="hljs-comment">/* c_lflag: Local Options */</span><br>options.c_lflag |= (ICANON | ECHO | ECHOE); <span class="hljs-comment">// 选择规范输入 Canonical Input</span><br>options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); <span class="hljs-comment">// 选择原始输入 Raw Input</span><br><br><span class="hljs-comment">/* c_iflag: Input Options*/</span><br>opt.c_iflag &amp;= ~INPCK;<br><br><span class="hljs-comment">/* c_oflag: Input Options*/</span><br>options.c_oflag &amp;= ~OPOST; <span class="hljs-comment">// raw output. When the OPOST option is disabled, all other option bits in c_oflag are ignored.</span><br><br>tcsetattr(fd, TCSANOW, &amp;options);<br></code></pre></td></tr></tbody></table></figure><p>VMIN: 读数据时的最小字节数，没读到这些数据就不返回</p><p>VTIME: 等待第一个数据的时间，比如VTIME=1，表示10秒内一个数据都没有的话就返回，如果10秒内至少读到一个字节，就继续等待，完全读到VMIN个数据返回。 VTIME=0表示一直等待。</p><p><strong>Timeouts are ignored in canonical input mode or when the *NDELAY* option is set on the file via *open* or *fcntl*.</strong></p><p>raw mode可以设置VMIN和VTIME，canonical input mode不用设置。</p><h1 id="8250-Uart-driver"><a href="#8250-Uart-driver" class="headerlink" title="8250 Uart driver"></a>8250 Uart driver</h1><h2 id="几个重要的结构体"><a href="#几个重要的结构体" class="headerlink" title="几个重要的结构体"></a>几个重要的结构体</h2><p><strong>uart_driver</strong>：通过<code>int uart_register_driver(struct uart_driver *drv)</code>注册进内核。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_driver</span> <span class="hljs-title">serial8250_reg</span> =</span> {<br>  .owner= THIS_MODULE, <span class="hljs-comment">///拥有该uart_driver的模块,一般为THIS_MODULE</span><br>  .driver_name= <span class="hljs-string">"serial"</span>, <span class="hljs-comment">///串口驱动名，串口设备文件名以驱动名为基础</span><br>  .dev_name= <span class="hljs-string">"ttyS"</span>, <span class="hljs-comment">/// 串口设备名</span><br>  .major= TTY_MAJOR,<br>  .minor= <span class="hljs-number">64</span>,<br>  .cons= SERIAL8250_CONSOLE, <span class="hljs-comment">/// 其对应的console.若该uart_driver支持serial console,否则为NULL</span><br>};<br><br>serial8250_reg.nr = UART_NR; <span class="hljs-comment">/// 支持最大的串口数量 UART_NR == 3</span><br></code></pre></td></tr></tbody></table></figure><p><strong>uart_port</strong>：对应一个串口设备，通过<code>int uart_add_one_port(struct uart_driver *drv,struct uart_port *port)</code>向该驱动添加<code>uart_port</code></p><p><strong>uart_ops</strong>：串口操作函数，为uart_port的成员。</p><p><strong>uart_8250_port</strong>：8250 serial driver抽象出来的结构体，包含了<strong>uart_port</strong>以及别的8250需要的成员。</p><p><strong>dw8250_data</strong>：dw 820 serial driver抽象出来的结构体</p><p>注意到<code>uart_port</code>和<code>uart_ops</code>中有相同的回调函数，这里的调用顺序为：首先<code>uart_ops</code>会检查<code>uart_port</code>是否实现了相同的回调函数，如果实现了则调用<code>uart_port</code>，否则调用<code>uart_ops</code>。具体可以参考<code>8250_dw.c</code>中的<code>p-&gt;set_termios = dw8250_set_termios</code>和<code>8250_port.c</code>中的<code>.set_termios  = serial8250_set_termios</code></p><h2 id="8250-core-c"><a href="#8250-core-c" class="headerlink" title="8250_core.c"></a>8250_core.c</h2><ul><li><p>注册uart_driver</p></li><li><p>注册uart_port（后面更底层的8250_dw.c会注册uart_port替换）</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//8250_core.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_8250_port</span> *<span class="hljs-title">up</span> =</span> &amp;serial8250_ports[i];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_port</span> *<span class="hljs-title">port</span> =</span> &amp;up-&gt;port;<br><br>port-&gt;line = i;<br>port-&gt;ops = &amp;serial8250_pops;<br>port-&gt;has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);<br>up-&gt;cur_iotype = <span class="hljs-number">0xFF</span>;<br>port-&gt;ops = &amp;univ8250_port_ops;<br><br>up-&gt;dl_read = default_serial_dl_read;<br>up-&gt;dl_write = default_serial_dl_write;<br>port-&gt;serial_in = io_serial_in;<br>port-&gt;serial_out = io_serial_out;<br>up-&gt;cur_iotype = p-&gt;iotype; <span class="hljs-comment">/// p-&gt;iotype=0</span><br>univ8250_port_ops = *base_ops; <span class="hljs-comment">/// 相当于又赋值回来port-&gt;ops = &amp;serial8250_pops;</span><br><br><br>serial8250_init(); <span class="hljs-comment">/// 内核打印: Serial: 8250/16550 driver, 3 ports, IRQ sharing disabled</span><br>  serial8250_isa_init_ports();<br>      serial8250_init_port(); <span class="hljs-comment">// 8250_port.c</span><br>    serial8250_set_defaults();<br>        set_io_from_upio();<br>    uart_register_driver();<br>      tty_register_driver();<br>    serial8250_register_ports(); <span class="hljs-comment">/// 注册三个uart_port(serial8250_ports)进uart_driver.</span><br>    uart_add_one_port(drv, &amp;up-&gt;port);<br>      uart_configure_port(); <span class="hljs-comment">// 会直接返回 因为port-&gt;iobase没初始化</span><br>  serial8250_probe();<br><br><br>console_initcall(univ8250_console_init);<br>  serial8250_isa_init_ports<br>    register_console<br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="8250-dw-c"><a href="#8250-dw-c" class="headerlink" title="8250_dw.c"></a>8250_dw.c</h2><p>在8250_core之后注册。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 8250_dw.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_8250_port</span> <span class="hljs-title">uart</span> =</span> {}, *up = &amp;uart;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_port</span> *<span class="hljs-title">p</span> =</span> &amp;up-&gt;port;<br><br>p-&gt;type    = PORT_8250;<br>p-&gt;flags  = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_BOOT_AUTOCONF; <span class="hljs-comment">//最后一个在之后append</span><br>p-&gt;dev    = dev;<br>p-&gt;iotype  = UPIO_MEM;<br>p-&gt;set_ldisc  = dw8250_set_ldisc;<br>p-&gt;set_termios  = dw8250_set_termios; <span class="hljs-comment">/// 在dw8250_quirks中又p-&gt;set_termios=NULL</span><br>p-&gt;membase = devm_ioremap(dev, regs-&gt;start, resource_size(regs));<br>p-&gt;private_data = &amp;data-&gt;data;<br>p-&gt;iotype = UPIO_MEM32;<br>p-&gt;serial_in = dw8250_serial_in32;<br>p-&gt;serial_out = dw8250_serial_out32;<br>p-&gt;line = id;<br>p-&gt;set_termios = <span class="hljs-literal">NULL</span>;<br>port-&gt;type = PORT_16550A;<br>up-&gt;capabilities = UART_CAP_FIFO;<br><br>dw8250_probe();<br>  dw8250_quirks();<br>    serial8250_register_8250_port();<br>    serial8250_find_match_or_unused();<br>        uart_remove_one_port();<br>            unregister_console(); <span class="hljs-comment">// 内核打印:printk: console [ttyS1] disabled</span><br>    serial8250_set_defaults();<br>        uart_add_one_port();<br>      uart_configure_port();<br>        port-&gt;ops-&gt;config_port(port, flags); <span class="hljs-comment">// 调用到8250_port.c中uart_ops的config_port</span><br>          autoconfig();<br>            autoconfig_16550a();<br>        uart_report_port();<span class="hljs-comment">// 打印: ...ttyS1 at MMIO 0x18810100 (irq = 13, base_baud = 1500000) is a 16550A</span><br>        register_console();<span class="hljs-comment">// 内核打印:printk: console [ttyS1] enabled</span><br>          try_enable_new_console();<br>            newcon-&gt;setup(); <span class="hljs-comment">// 这里调用到8250_core.c中univ8250_console.setup创建console</span><br>          unregister_console();<span class="hljs-comment">//内核打印:bootconsole [earlycon0] disabled</span><br><br><br><span class="hljs-comment">// 中断处理</span><br>p-&gt;handle_irq  = dw8250_handle_irq;<br>dw8250_handle_irq();<br>  serial8250_handle_irq();<br>    serial8250_rx_chars(); <span class="hljs-comment">// 读数据</span><br>    serial8250_tx_chars(); <span class="hljs-comment">// 发数据</span><br><br></code></pre></td></tr></tbody></table></figure><h2 id="Serial-core-c"><a href="#Serial-core-c" class="headerlink" title="Serial_core.c"></a>Serial_core.c</h2><p>注册一个<code>tty driver</code>, 提供了<code>static const struct tty_operations uart_ops</code> <code>static const struct tty_port_operations uart_port_ops</code>供上层调用。</p><h1 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h1><p>以linux5.10为例。（注意到最新的linux6.3 printk流程不一样了）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//kernel/printk/printk.c</span><br>printk;<br>  vprintk_func <span class="hljs-comment">// printk_safe.c</span><br>    vprintk_default<br>      vprintk_emit<br>        vprintk_store <span class="hljs-comment">// 把要打印的信息保存在log_buf中</span><br>              log_output<br>            console_unlock<br>              call_console_drivers<br>                con-&gt;write(con, text, len); <span class="hljs-comment">// 调用console driver的write函数</span><br><br><span class="hljs-comment">// 8250 consle</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> <span class="hljs-title">univ8250_console</span> =</span> {<br>  .name= <span class="hljs-string">"ttyS"</span>,<br>  .write= univ8250_console_write,<br>  .device= uart_console_device,<br>  .setup= univ8250_console_setup,<br>  .match= univ8250_console_match,<br>  .flags= CON_PRINTBUFFER | CON_ANYTIME,<br>  .index= <span class="hljs-number">-1</span>,<br>  .data= &amp;serial8250_reg,<br>};<br><br>univ8250_console_write();<br>  serial8250_console_write();<br>    uart_console_write();<br>      <span class="hljs-built_in">putchar</span>();<span class="hljs-comment">//即serial8250_console_putchar();</span><br>        serial_port_out(port, UART_TX, ch); <span class="hljs-comment">// 往UART_TX寄存器写数据</span><br>          up-&gt;serial_out(up, offset, value); <span class="hljs-comment">// 调用到8250_dw.c中写寄存器函数</span><br></code></pre></td></tr></tbody></table></figure><h1 id="Early-printk"><a href="#Early-printk" class="headerlink" title="Early printk"></a>Early printk</h1><p>打开<code>CONFIG_EARLY_PRINTK</code></p><p>如果在设备树cmdline中添加了<code>earlyprintk</code>，会进入<code>/arch/arm/kernel/early_printk.c</code> 中<code>early_param(" earlyprintk", setup_early_printk);</code>指定的setup_early_printk函数。可以看到这个earlyprintk是在arch arm上实现的，比如其他risc-v是没有的(通过earlycon实现)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">setup_early_printk();<br>  register_console(&amp;early_console_dev); <span class="hljs-comment">// 注册了一个console，printk会调用console的.write回调函数</span><br><br>early_console_write();<br>  early_write();<br>    printascii(); <span class="hljs-comment">// arch/arm/kernel/debug.S</span><br>      addruart_current<br>                addruart<br>                  ldr\rp, =CONFIG_DEBUG_UART_PHYS <span class="hljs-comment">// 需要在linux menuconfig中手动设定earlyprink的Uart串口地址</span><br>                  ldr\rv, =CONFIG_DEBUG_UART_VIRT<br>            waituarttxrdy<br>            senduart<br>            busyuart<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">register_console<br>      <span class="hljs-title function_">pr_info</span><span class="hljs-params">(<span class="hljs-string">"%sconsole [%s%d] enabled\n"</span>,</span><br><span class="hljs-params">    (newcon-&gt;flags &amp; CON_BOOT) ? <span class="hljs-string">"boot"</span> : <span class="hljs-string">""</span> ,</span><br><span class="hljs-params">    newcon-&gt;name, newcon-&gt;index)</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="Earlycon"><a href="#Earlycon" class="headerlink" title="Earlycon"></a>Earlycon</h1><ul><li>command line中<code>earlycon</code>如果不带参数，参数在下面的<code>stdout-path</code>中，所以要解析设备树。</li></ul><p>使用”/chosen”下的”stdout-path”找到节点，根据节点的<code>"compatible"</code>找到对应的<code>OF_EARLYCON_DECLARE</code>，进入setup函数。</p><ul><li>如果<code>earlycon=xxx</code>含参数，无需设备树。</li></ul><p>可以利用<code>EARLYCON_DECLARE</code>宏，根据<code>name(xxx)</code>，找到对应的setup函数。</p><p>例如<code>earlycon-riscv-sbi.c</code>中<code>EARLYCON_DECLARE(sbi, early_sbi_setup);</code> 只需在设备树中指定<code>earlycon=sbi</code></p><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>两个串口对接，一个串口tx发送16bytes 0x55给另一个串口，为什么另一个串口会回16bytes 0x55回来到rx？</p>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO Subsystem</title>
    <link href="/2023/05/12/Note/Linux_Driver/GPIO/"/>
    <url>/2023/05/12/Note/Linux_Driver/GPIO/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/41942876">https://zhuanlan.zhihu.com/p/41942876</a></p><p><strong>push pull推挽输出</strong></p><p>推挽输出的最大特点是可以真正能真正的输出高电平和低电平，在两种电平下都具有驱动能力。</p><p><strong>open drain开漏输出</strong></p><p><strong>open source开集输出</strong></p><p>这两种输出的原理和特性基本是类似的，区别在于一个是使用MOS管，其中的”漏”指的就是MOS管的漏极；另一个使用三极管，其中的”集”指的就是MOS三极管的集电极。这两者其实都是和推挽输出相对应的输出模式，由于使用MOS管的情况较多，很多时候就用”开漏输出”这个词代替了开漏输出和开集输出。</p><p>开漏、开集输出最主要的特性就是高电平没有驱动能力，需要借助外部上拉电阻才能真正输出高电平。</p><h1 id="Kernel-doc-General-Purpose-Input-x2F-Output-GPIO"><a href="#Kernel-doc-General-Purpose-Input-x2F-Output-GPIO" class="headerlink" title="Kernel doc: General Purpose Input/Output (GPIO)"></a>Kernel doc: General Purpose Input/Output (GPIO)</h1><h2 id="GPIO-Driver-Interface"><a href="#GPIO-Driver-Interface" class="headerlink" title="GPIO Driver Interface"></a>GPIO Driver Interface</h2><h3 id="Controller-Drivers-gpio-chip"><a href="#Controller-Drivers-gpio-chip" class="headerlink" title="Controller Drivers: gpio_chip"></a>Controller Drivers: gpio_chip</h3><p><code>struct gpio_chip</code> 抽象gpio controller。</p><p><code>gpiochip_add_data()</code> or <code>devm_gpiochip_add_data()</code>接口用来注册gpio controller。<code>gpiochip_remove()</code>释放gpio controller。</p><p><code>gpiochip_is_request()</code>在gpio controller driver中用于检测某个gpio是否被其他chip占用，没占用返回NULL，占用返回request时传入的string。</p><h3 id="GPIO-electrical-configuration"><a href="#GPIO-electrical-configuration" class="headerlink" title="GPIO electrical configuration"></a>GPIO electrical configuration</h3><p>gpio_chip的<code>.set_config</code>回调用于设置：</p><ul><li>Debouncing</li><li>Single-ended modes (open drain/open source)</li><li>Pull up and pull down resistor enablement</li></ul><p>这些属性可以在dts中指定，<code>include/dt-bindings/gpio/gpio.h</code> <code>GPIO_PUSH_PULL</code> <code>GPIO_LINE_OPEN_SOURCE</code> <code>GPIO_OPEN_DRAIN </code>…</p><p>可以设置为<code>gpiochip_generic_config()</code>会调用到<code>pinctrl_gpio_set_config()</code>-&gt;<code>ops-&gt;pin_config_set</code></p><h3 id="GPIO-drivers-providing-IRQs"><a href="#GPIO-drivers-providing-IRQs" class="headerlink" title="GPIO drivers providing IRQs"></a>GPIO drivers providing IRQs</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">gpiod_to_irq(); <span class="hljs-comment">// 传入gpio_desc，返回gpio的irq number(软件映射的，不是irq hw id)</span><br>  gpio_chip_hwgpio();<br>    gc-&gt;to_irq();<br>      rts_gpio_to_irq();<br>        irq_linear_revmap();<br><br></code></pre></td></tr></tbody></table></figure><h4 id="Cascaded-GPIO-irqchips"><a href="#Cascaded-GPIO-irqchips" class="headerlink" title="Cascaded GPIO irqchips"></a>Cascaded GPIO irqchips</h4><ol><li>CHAINED CASCADED GPIO IRQCHIPS：挺多soc上是这种做法，打开<code>CONFIG_GPIOLIB_IRQCHIP</code>设置girq-&gt;parent_handler。gpio controller注册过程中通过<strong>irq_set_chained_handler</strong>设置中断处理函数，因此在中断处理函数中需要chained_irq_enter，chained_irq_exit。相当于级联中断处理器的做法。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">foo_gpio_irq</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *data)</span> <span class="hljs-comment">/// 中断处理函数</span><br>    <span class="hljs-title function_">chained_irq_enter</span><span class="hljs-params">(...)</span>;<br>    generic_handle_irq(...);<br>    chained_irq_exit(...);<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>GENERIC CHAINED GPIO IRQCHIPS：rts3917是这种做法，通过<strong>reuqest_irq</strong>进入的rts_irq_handler中断处理函数。发现的每一个gpio都进入generic_handle_irq，最后会到各自irq_desc中通过request_irq的中断处理函数。</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">rts_irq_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br>    <span class="hljs-keyword">for</span> each detected GPIO IRQ<br>        <span class="hljs-title function_">generic_handle_irq</span><span class="hljs-params">(...)</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>NESTED THREADED GPIO IRQCHIPS：gpio expander的做法，不深究。</li></ol><h3 id="Infrastructure-helpers-for-GPIO-irqchips"><a href="#Infrastructure-helpers-for-GPIO-irqchips" class="headerlink" title="Infrastructure helpers for GPIO irqchips"></a>Infrastructure helpers for GPIO irqchips</h3><p>GPIO子系统有针对中断的一套框架，Kconfig为<code>GPIOLIB_IRQCHIP</code>，rts没有用到就不分析了。可以看文档中具体的解释。</p><p>注意一点，方法一：如果parent_handler赋值了<code>girq-&gt;parent_handler = ftgpio_gpio_irq_handler</code>应该就是上面<code>CHAINED CASCADED GPIO IRQCHIPS</code>的做法。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gpiochip_add_data();<br>    gpiochip_add_data_with_key();<br>      gpiochip_add_irqchip();<br>        irq_set_chained_handler_and_data(gc-&gt;irq.parents[i], gc-&gt;irq.parent_handler, data);<br></code></pre></td></tr></tbody></table></figure><p>方法二：<code>girq-&gt;parent_handler = NULL</code>，直接在driver中<code>devm_request_threaded_irq</code>对应<code>GENERIC CHAINED GPIO IRQCHIPS</code>的做法。</p><h2 id="GPIO-Descriptor-Consumer-Interface"><a href="#GPIO-Descriptor-Consumer-Interface" class="headerlink" title="GPIO Descriptor Consumer Interface"></a>GPIO Descriptor Consumer Interface</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/gpio.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get_index</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br><span class="hljs-comment">// return NULL 如果没有request到GPIO</span><br><span class="hljs-keyword">struct</span> gpio_desc *<span class="hljs-title function_">gpiod_get_optional</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id, <span class="hljs-keyword">enum</span> gpiod_flags flags)</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="GPIO-Mappings"><a href="#GPIO-Mappings" class="headerlink" title="GPIO Mappings"></a>GPIO Mappings</h2><h3 id="device-tree"><a href="#device-tree" class="headerlink" title="device tree"></a>device tree</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">foo_device {<br>        compatible = <span class="hljs-string">"acme,foo"</span>;<br>        ...<br>        led-gpios = &lt;&amp;gpio <span class="hljs-number">15</span> GPIO_ACTIVE_HIGH&gt;, <span class="hljs-comment">/* red */</span><br>                    &lt;&amp;gpio <span class="hljs-number">16</span> GPIO_ACTIVE_HIGH&gt;, <span class="hljs-comment">/* green */</span><br>                    &lt;&amp;gpio <span class="hljs-number">17</span> GPIO_ACTIVE_HIGH&gt;; <span class="hljs-comment">/* blue */</span><br><br>        power-gpios = &lt;&amp;gpio <span class="hljs-number">1</span> GPIO_ACTIVE_LOW&gt;;<br>};<br></code></pre></td></tr></tbody></table></figure><p>对应</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_desc</span> *<span class="hljs-title">red</span>, *<span class="hljs-title">green</span>, *<span class="hljs-title">blue</span>, *<span class="hljs-title">power</span>;</span><br><br>red = gpiod_get_index(dev, <span class="hljs-string">"led"</span>, <span class="hljs-number">0</span>, GPIOD_OUT_HIGH);<br>green = gpiod_get_index(dev, <span class="hljs-string">"led"</span>, <span class="hljs-number">1</span>, GPIOD_OUT_HIGH);<br>blue = gpiod_get_index(dev, <span class="hljs-string">"led"</span>, <span class="hljs-number">2</span>, GPIOD_OUT_HIGH);<br><br>power = gpiod_get(dev, <span class="hljs-string">"power"</span>, GPIOD_OUT_HIGH);<br></code></pre></td></tr></tbody></table></figure><p>gpiod_set_value设置的值是“逻辑值”，不一定等于物理值。</p><h2 id="Sysfs接口"><a href="#Sysfs接口" class="headerlink" title="Sysfs接口"></a>Sysfs接口</h2><p>/sys/class/gpio/</p><p>echo 19 &gt; export</p><p>/sys/class/gpio/gpioN/</p><p>/sys/kernel/debug/gpio 可以看哪些gpio被申请了</p>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMA&amp;DMA</title>
    <link href="/2023/05/10/Note/Linux_Driver/CMA&amp;DMA/"/>
    <url>/2023/05/10/Note/Linux_Driver/CMA&amp;DMA/</url>
    
    <content type="html"><![CDATA[<h1 id="Reserved-memory"><a href="#Reserved-memory" class="headerlink" title="Reserved-memory"></a>Reserved-memory</h1><p>参考：<a href="http://www.wowotech.net/memory_management/cma.html">http://www.wowotech.net/memory_management/cma.html</a></p><p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841683/Linux+Reserved+Memory?view=blog">https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18841683/Linux+Reserved+Memory?view=blog</a></p><p>/Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</p><p>定义了no-map属性的，不会自动映射到虚拟地址，需要自行在driver中映射。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dts</span><br>reserved: buffer@<span class="hljs-number">0x38000000</span> {<br>    no-<span class="hljs-built_in">map</span>;<br>    reg = &lt;<span class="hljs-number">0x38000000</span> <span class="hljs-number">0x08000000</span>&gt;;<br>};<br><br><span class="hljs-comment">/* Get reserved memory region from Device-tree */</span><br>np = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">"memory-region"</span>, <span class="hljs-number">0</span>);<br><br>rc = of_address_to_resource(np, <span class="hljs-number">0</span>, &amp;r);<br><br>lp-&gt;paddr = r.start;<br>lp-&gt;vaddr = memremap(r.start, resource_size(&amp;r), MEMREMAP_WB);<br></code></pre></td></tr></tbody></table></figure><p>定义”shared-dma-pool” 就可以创建DMA memory pool，使用DMA engine API了。of_reserved_mem_device_init中会帮我们创建映射。（DMA在of_reserved_mem_device_init阶段会进行memremap同上，这个remap不是直接映射的方式）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dts</span><br>reserved: buffer@<span class="hljs-number">0</span> {<br>  compatible = <span class="hljs-string">"shared-dma-pool"</span>;<br>  no-<span class="hljs-built_in">map</span>;<br>  reg = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0x70000000</span> <span class="hljs-number">0x0</span> <span class="hljs-number">0x10000000</span>&gt;;<br>};<br><br><span class="hljs-comment">/* Initialize reserved memory resources */</span><br>rc = of_reserved_mem_device_init(dev);<br><br><span class="hljs-comment">/* Allocate memory */</span><br>dma_set_coherent_mask(dev, <span class="hljs-number">0xFFFFFFFF</span>);<br>lp-&gt;vaddr = dma_alloc_coherent(dev, ALLOC_SIZE, &amp;lp-&gt;paddr, GFP_KERNEL);<br></code></pre></td></tr></tbody></table></figure><p>log:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[    0.000000] Reserved memory: created DMA memory pool at 0x0000000070000000, size 256 MiB<br>[    0.000000] Reserved memory: initialized node buffer@0, compatible id shared-dma-pool<br></code></pre></td></tr></tbody></table></figure><p>加上resuable属性，变成CMA pool。（CMA在dma_alloc_coherent时会通过__va宏返回直接映射的虚拟地址）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">reserved: buffer@<span class="hljs-number">0</span> {<br>  compatible = <span class="hljs-string">"shared-dma-pool"</span>;<br>  reusable;<br>  reg = &lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0x70000000</span> <span class="hljs-number">0x0</span> <span class="hljs-number">0x10000000</span>&gt;;<br>};<br></code></pre></td></tr></tbody></table></figure><p>log：</p><figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">[    <span class="hljs-number">0.000000</span>] Reserved <span class="hljs-keyword">memory</span>: created CMA <span class="hljs-keyword">memory</span> pool at <span class="hljs-number">0x0000000070000000</span>, <span class="hljs-keyword">size</span> <span class="hljs-number">256</span> MiB<br>[    <span class="hljs-number">0.000000</span>] Reserved <span class="hljs-keyword">memory</span>: initialized node buffer@0, compatible id shared-dma-pool<br></code></pre></td></tr></tbody></table></figure><p><strong>DMA pool是driver独有的，CMA pool在driver不使用的时候会被共享。</strong></p><h1 id="Dynamic-DMA-mapping-Guide"><a href="#Dynamic-DMA-mapping-Guide" class="headerlink" title="Dynamic DMA mapping Guide"></a>Dynamic DMA mapping Guide</h1><p><a href="https://docs.kernel.org/core-api/dma-api-howto.html">https://docs.kernel.org/core-api/dma-api-howto.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/109919756">https://zhuanlan.zhihu.com/p/109919756</a></p><h2 id="CPU-and-DMA-addresses"><a href="#CPU-and-DMA-addresses" class="headerlink" title="CPU and DMA addresses"></a>CPU and DMA addresses</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230510112218.png"></p><p>有IOMMU的设备，设备device访问的地址是bus address（等同于dma address），IOMMU负责CPU physical address和bus address的映射。</p><p>嵌入式设备一般没有IOMMU，此时bus address=CPU pyhsical address。设备直接访问cpu的物理地址。</p><h2 id="What-memory-is-DMA’able"><a href="#What-memory-is-DMA’able" class="headerlink" title="What memory is DMA’able?"></a>What memory is DMA’able?</h2><p><code>__get_free_page*()</code>, <code>kmalloc()</code>, <code>kmem_cache_alloc()</code>这些分配连续空间地址的都可以dma mapping。</p><p><code>vmalloc()</code>, <code>kmap()</code>不行。</p><h2 id="DMA-addressing-capabilities"><a href="#DMA-addressing-capabilities" class="headerlink" title="DMA addressing capabilities"></a>DMA addressing capabilities</h2><p>设置设备通过DMA能驱动多少位地址，寻址能力。</p><p>同时设置streaming和coherent mapping：</p><p><code>int dma_set_mask_and_coherent(struct device *dev, u64 mask)</code></p><p>只设置streaming mapping：</p><p><code>int dma_set_mask(struct device *dev, u64 mask);</code></p><p>只设置coherent mapping：</p><p><code>int dma_set_coherent_mask(struct device *dev, u64 mask);</code></p><h2 id="Types-of-DMA-mappings"><a href="#Types-of-DMA-mappings" class="headerlink" title="Types of DMA mappings"></a>Types of DMA mappings</h2><ul><li>一致性DMA映射（consistent DMA mappings）。driver初始化时map，shutdown时unmap。<ul><li>不需要考虑cache的影响，也就是说不需要软件进行cache操作，CPU和DMA controller都可以看到对方对DMA buffer的更新。CPU对memory的修改device可以立即感知到，反之亦然。</li><li>一致性的DMA映射并不意味着不需要memory barrier这样的工具来保证memory order。</li><li>在有些平台上，修改了DMA Consistent buffer后，你的驱动可能需要flush write buffer，以便让device侧感知到memory的变化。</li></ul></li><li>流式DMA映射（Streaming DMA mappings）。一次性的，需要进行DMA传输的时候map，DMA传输完成，就ummap。<code>spi-dw-rts.c</code>中ssi的传输就是流式dma映射。</li></ul><h2 id="一致性DMA映射"><a href="#一致性DMA映射" class="headerlink" title="一致性DMA映射"></a>一致性DMA映射</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-comment">//cpu_addr:虚拟地址，dma_handle:总线地址，没有IOMMU相当于物理地址</span><br>cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);<br></code></pre></td></tr></tbody></table></figure><p>You may however need to make sure to flush the processor’s write buffers before telling devices to read that memory.见下方sync的API。</p><p>如果driver需要许多小的buffer,可以使用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">pool</span>;</span><br>pool = dma_pool_create(name, dev, size, align, boundary);<br>cpu_addr = dma_pool_alloc(pool, flags, &amp;dma_handle);<br></code></pre></td></tr></tbody></table></figure><h2 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h2><p>流式DMA映射需要设置DMA direction。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DMA_BIDIRECTIONAL<br>DMA_TO_DEVICE<br>DMA_FROM_DEVICE<br>DMA_NONE<br></code></pre></td></tr></tbody></table></figure><p>接口一<code>dma_map_single</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;my_dev-&gt;dev;<br><span class="hljs-type">dma_addr_t</span> dma_handle;<br><span class="hljs-type">void</span> *addr = buffer-&gt;ptr;<br><span class="hljs-type">size_t</span> size = buffer-&gt;len;<br><br>dma_handle = dma_map_single(dev, addr, size, direction);<br><span class="hljs-keyword">if</span> (dma_mapping_error(dev, dma_handle)) {<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * reduce current DMA mapping usage,</span><br><span class="hljs-comment">         * delay and try again later or</span><br><span class="hljs-comment">         * reset driver.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">goto</span> map_error_handling;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接口二<code>dma_map_page</code></p><p>因为dma_map_single函数在进行DMA mapping的时候使用的是CPU指针（虚拟地址），导致该函数有一个弊端：不能使用HIGHMEM memory进行mapping。因为HIGHMEM memory没有进行线性映射，所以没有虚拟地址。</p><p>接口三<code>dma_map_sg</code></p><p>用于scatterlist情况，映射的对象是分散的若干段DMA buffer。具体不分析了。</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>如果你需要多次访问同一个streaming DMA buffer，并且在DMA传输之间读写DMA Buffer上的数据，这时候你需要小心进行DMA buffer的sync操作，以便CPU和设备（DMA controller）可以看到最新的、正确的数据。</p><p><code>dma_sync_single_for_cpu(dev, dma_handle, size, direction)</code></p><p>如果，CPU操作了DMA buffer的数据，然后你又想把控制权交给设备上的DMA控制器，让DMA controller访问DMA buffer，这时候，在真正让HW（指DMA控制器）去访问DMA buffer之前，需要：</p><p><code>dma_sync_single_for_device(dev, dma_handle, size, direction)</code></p><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p><a href="https://blog.csdn.net/wangyunqian6/article/details/6670110">https://blog.csdn.net/wangyunqian6/article/details/6670110</a></p><p>DMA是直接操作总线地址的，这里先当作物理地址来看待吧。如果cache缓存的内存区域不包括DMA分配到的区域，那么就没有一致性的问题。但是如果cache缓存包括了DMA目的地址的话，会出现什么什么问题呢？</p><p>问题出在，经过DMA操作，cache缓存对应的内存数据已经被修改了，而CPU本身不知道（DMA传输是不通过CPU的），它仍然认为cache中的数据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用旧的Cache数据。这样就发生Cache与内存的数据“不一致性”错误。</p><p>顺便提一下，总线地址是从设备角度上看到的内存，物理地址是CPU的角度看到的未经过转换的内存（经过转换的是虚拟地址）</p><p>由上面可以看出，DMA如果使用cache，那么一定要考虑cache的一致性。解决DMA导致的一致性的方法最简单的就是禁止DMA目标地址范围内的cache功能。但是这样就会牺牲性能。</p><p>因此在DMA是否使用cache的问题上，可以根据DMA缓冲区期望保留的的时间长短来决策。DAM的映射就分为：<strong>一致性DMA映射</strong>和<strong>流式DMA映射</strong>。</p><p>因为LCD随时都在使用，因此在Frame buffer驱动中，使用一致性DMA映射上面的代码中用到 <strong>dma_alloc_wc</strong>（<strong>non-cache, buffered</strong>）函数，另外还有一个一致性DMA映射函数<strong>dma_alloc_coherent</strong>（<strong>non-cache，non-buffer</strong>）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dma_alloc_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">    <span class="hljs-type">dma_addr_t</span> *dma_handle, <span class="hljs-type">gfp_t</span> gfp)</span><br>{<br>  <span class="hljs-keyword">return</span> dma_alloc_attrs(dev, size, dma_handle, gfp,<br>      (gfp &amp; __GFP_NOWARN) ? DMA_ATTR_NO_WARN : <span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dma_alloc_wc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">         <span class="hljs-type">dma_addr_t</span> *dma_addr, <span class="hljs-type">gfp_t</span> gfp)</span><br>{<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> attrs = DMA_ATTR_WRITE_COMBINE;<br><br>  <span class="hljs-keyword">if</span> (gfp &amp; __GFP_NOWARN)<br>    attrs |= DMA_ATTR_NO_WARN;<br><br>  <span class="hljs-keyword">return</span> dma_alloc_attrs(dev, size, dma_addr, gfp, attrs);<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">dma_alloc_attrs();<br>  dma_alloc_from_dev_coherent(); <span class="hljs-comment">// 如果dts有reserved memory会走这个函数</span><br>    dev_get_coherent_memory();<br>      <span class="hljs-keyword">return</span> dev-&gt;dma_mem <span class="hljs-comment">// 直接返回reserved-memory中分配的地址了</span><br>  <span class="hljs-keyword">return</span> cpu_addr;<br><br><span class="hljs-comment">// dev-&gt;mem的分配：</span><br>dma_init_reserved_memory();<br>  ops-&gt;device_init(dma_reserved_default_memory, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reserved_mem_ops</span> <span class="hljs-title">rmem_dma_ops</span> =</span> {<br>  .device_init= rmem_dma_device_init,<br>};<br>rmem_dma_device_init();<br>  dma_init_coherent_memory();<br>  dma_assign_coherent_memory();<br>    dev-&gt;dma_mem = mem;<br><br></code></pre></td></tr></tbody></table></figure><p>看起来如果在dts中分配了reserved-memory，<code>dma_alloc_coherent</code>和<code>dma_alloc_wc</code>流程是一样的，都会走<code>dma_alloc_from_dev_coherent</code>从reserved-memory中分配空间（<strong>这块区域是cached？buffer？</strong>，rts3917启动中有打印：<code>Memory policy: Data cache writeback</code>是否与reserved memory有关系）</p><p><strong>所以rts_fb.c中有<code>dma_sync_single_for_device</code>?</strong></p><table><thead><tr><th>是否启用cache</th><th>是否启用 buffer</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>无cache，无写缓冲<br>读、写都直达外设硬件</td></tr><tr><td>0</td><td>1</td><td>无cache，有写缓冲<br>读操作直达外设硬件；写操作，CPU将数据写入到写缓冲后继续运行，由写缓冲进行写回操作。</td></tr><tr><td>1</td><td>0</td><td>有cache，写通模式write through。<br>数据要同时写入cache和内存，所以cache和内存中的数据保持一致。</td></tr><tr><td>1</td><td>1</td><td>有cache，写回模式write back<br>新数据只是写入cache ，不会立刻写入内存。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinctrl Subsystem</title>
    <link href="/2023/05/10/Note/Linux_Driver/pinctrl/"/>
    <url>/2023/05/10/Note/Linux_Driver/pinctrl/</url>
    
    <content type="html"><![CDATA[<p>/sys/kernel/debug/pinctrl</p><p>其他驱动调用pinctrl子系统：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pinctrl/consumer.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl</span> *<span class="hljs-title">xxx_pinctrl</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_state</span> *<span class="hljs-title">default_state</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// dts</span><br>pinctrl<span class="hljs-number">-0</span> = &lt;&amp;state1&gt;<br><br>pinctrl<span class="hljs-number">-1</span> = &lt;&amp;state2&gt;<br><br><span class="hljs-number">1.</span> <span class="hljs-comment">/*&nbsp;获取pin&nbsp;control&nbsp;state&nbsp;holder&nbsp;的句柄&nbsp;*/</span><br><br>    pinctrl&nbsp;=&nbsp;devm_pinctrl_get(dev);<br><br><span class="hljs-number">2.</span> <span class="hljs-comment">/*&nbsp;得到名字为state1和state2对应的pin&nbsp;state&nbsp;*/</span><br><br>    **<span class="hljs-class"><span class="hljs-keyword">struct</span>**&nbsp;<span class="hljs-title">pinctrl_state</span>&nbsp;*&nbsp;<span class="hljs-title">turnon_tes</span>&nbsp;=</span>&nbsp;pinctrl_lookup_state(pinctrl,&nbsp;<span class="hljs-string">"state1"</span>);<br><br>    **<span class="hljs-class"><span class="hljs-keyword">struct</span>**&nbsp;<span class="hljs-title">pinctrl_state</span>&nbsp;*&nbsp;<span class="hljs-title">turnoff_tes</span>&nbsp;=</span>&nbsp;pinctrl_lookup_state(pinctrl,&nbsp;<span class="hljs-string">"state2"</span>);<br><br><span class="hljs-number">3.</span> pinctrl_select_state(pinctrl,&nbsp;turnon_tes)。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">devm_pinctrl_get(<span class="hljs-keyword">struct</span> device *dev) <span class="hljs-comment">//返回一个pinctrl句柄</span><br>  pinctrl_get(<span class="hljs-keyword">struct</span> device *dev)<br>    find_pinctrl(<span class="hljs-keyword">struct</span> device *dev) <span class="hljs-comment">// 查看是否device core已经创建了该pinctrl句柄</span><br>    create_pinctrl(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> pinctrl_dev *pctldev)<br>      pinctrl_dt_to_map(<span class="hljs-keyword">struct</span> pinctrl *p, <span class="hljs-keyword">struct</span> pinctrl_dev *pctldev) <span class="hljs-comment">//从设备树中获取信息保存到pinctrl_map结构体中</span><br>        <span class="hljs-keyword">for</span> (state = <span class="hljs-number">0</span>; ; state++) {<br>          propname = kasprintf(GFP_KERNEL, <span class="hljs-string">"pinctrl-%d"</span>, state); <span class="hljs-comment">//查找pinctrl-0,1,2属性</span><br>                    <span class="hljs-comment">//size保存了pinctrl-0中phandle的个数，比如有的节点pinctrl-0 = &lt;&amp;x1, &amp;x2&gt;</span><br>          prop = of_find_property(np, propname, &amp;size);<br>          <span class="hljs-built_in">list</span> = prop-&gt;value; <span class="hljs-comment">//list保存了phandle列表</span><br>                    <span class="hljs-comment">//保存pinctrl-names index为state的name,比如pinctrl-names = "default"</span><br>          ret = of_property_read_string_index(np, <span class="hljs-string">"pinctrl-names"</span>, state, &amp;statename);<br>          <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                        <span class="hljs-comment">// 如果没有定义pinctrl-names属性，那么我们将pinctrl-0 pinctrl-1 pinctrl-2……中的那个ID取出来作为state name</span><br>            statename = prop-&gt;name + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">"pinctrl-"</span>);<br>          <span class="hljs-keyword">for</span> (config = <span class="hljs-number">0</span>; config &lt; size; config++) {<br>            phandle = be32_to_cpup(<span class="hljs-built_in">list</span>++);<br>            np_config = of_find_node_by_phandle(phandle); <span class="hljs-comment">// 找到pinctrl-x=&lt;&amp;x1, &amp;x2&gt;中的config节点</span><br>            dt_to_map_one_config(p, pctldev, statename, np_config);<br>              np_pctldev = of_node_get(np_config);<br>              np_pctldev = of_get_next_parent(np_pctldev); <span class="hljs-comment">// 找到pinctrl controller节点</span><br>              pctldev = get_pinctrl_dev_from_of_node(np_pctldev); <span class="hljs-comment">//找到pinctrl_dev</span><br>                          <span class="hljs-comment">//调用底层的callback函数处理pin configuration node。</span><br>              ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="hljs-built_in">map</span>, &amp;num_maps);<br>                .dt_node_to_map = pinconf_generic_dt_node_to_map_all <span class="hljs-comment">//rts pinctrl 用的框架通用函数</span><br>                    pinconf_generic_dt_node_to_map()<br>                      ret = pinconf_generic_dt_subnode_to_map();<br>                      for_each_available_child_of_node(np_config, np)<br>                                                <span class="hljs-comment">//rts pinctrl每一个config节点下都有子节点 逐个分析子节点</span><br>                        ret = pinconf_generic_dt_subnode_to_map();<br>                      pinconf_generic_parse_dt_config(np, pctldev, &amp;configs, &amp;num_configs);<br>                          <span class="hljs-comment">//将该pin configuration node的mapping entry信息注册到系统中</span><br>              dt_remember_or_free_map(p, statename, pctldev, <span class="hljs-built_in">map</span>, num_maps);<br>          }<br>        }<br>      add_setting(p, pctldev, <span class="hljs-built_in">map</span>); <span class="hljs-comment">// 将pinctrl_map信息传递给pinctrl_mapping, 把这个setting的代码加入到holder中</span><br>        setting-&gt;type = <span class="hljs-built_in">map</span>-&gt;type;<br>        setting-&gt;pctldev = get_pinctrl_dev_from_devname(<span class="hljs-built_in">map</span>-&gt;ctrl_dev_name);<br>        setting-&gt;dev_name = <span class="hljs-built_in">map</span>-&gt;dev_name;<br>        pinmux_map_to_setting(<span class="hljs-built_in">map</span>, setting);<br>        pinconf_map_to_setting(<span class="hljs-built_in">map</span>, setting);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">pinctrl_lookup_state(<span class="hljs-keyword">struct</span> pinctrl *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>  find_state(p, name);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">pinctrl_select_state()<br>  pinctrl_commit_state(p, state);<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<br>      pinmux_enable_setting(setting);<br>        ops-&gt;set_mux(pctldev, setting-&gt;data.mux.func, setting-&gt;data.mux.group);<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<br>    <span class="hljs-keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<br>      pinconf_apply_setting(setting);<br>        <span class="hljs-keyword">switch</span> (setting-&gt;type)<br>          ops-&gt;pin_config_set()<br>          ops-&gt;pin_config_group_set()<br></code></pre></td></tr></tbody></table></figure><p>统一驱动设备模型会处理pin control：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_driver_register()<br>  driver_register();<br>    bus_add_driver();<br>      driver_attach();<br>        __driver_attach();<br>          device_driver_attach(drv, dev);<br>            driver_probe_device(drv, dev);<br>              really_probe(dev, drv);<br><br>  really_probe(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_driver *drv)<br>    pinctrl_bind_pins(dev);<br>      devm_pinctrl_get(dev);<br>        pinctrl_lookup_state(dev-&gt;pins-&gt;p, PINCTRL_STATE_DEFAULT);<br>        pinctrl_lookup_state(dev-&gt;pins-&gt;p, PINCTRL_STATE_INIT);<br>        pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;default_state);<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB</title>
    <link href="/2023/05/08/Note/23-05-08_GDB/"/>
    <url>/2023/05/08/Note/23-05-08_GDB/</url>
    
    <content type="html"><![CDATA[<h2 id="Stepping"><a href="#Stepping" class="headerlink" title="Stepping"></a>Stepping</h2><p><code>step(s)/stepi(si) + &lt;n&gt;</code>: 执行n行c/assembly 代码, 会跳进函数。<br><code>next(n)/nexti(ni) + &lt;n&gt;</code>: 执行n行c/assembly 代码，不会跳进函数。</p><h2 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h2><p><code>continue(c)</code>: run code 直到遇到breakpoint。<br><code>finish</code>: run code直到当前函数return。<br><code>advance &lt;location&gt;</code>: run code直到指令到达<location>。和设置breakpoint然后</location></p><h2 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h2><p><code>break &lt;location&gt;</code>: 设置断点，location可以是内存地址<code>"*0x7c00"</code>或者名称<code>"mon_backtrace", "monitor.c:71"</code><br><code>break &lt;location&gt; if &lt;condition&gt;</code>: 只有condition满足的时候才会break。<br><code>cond &lt;number&gt; &lt;condition&gt;</code>: 给某个断点增加condition。</p><h2 id="Watchpoints"><a href="#Watchpoints" class="headerlink" title="Watchpoints"></a>Watchpoints</h2><p><code>watch &lt;expression&gt;</code>: 表达式值发生改变时，会停止执行指令。<br><code>watch -l &lt;address&gt;</code>: 内存地址的值发生改变时，会停止执行指令。<br><code>rwatch [-l] &lt;expression&gt;</code>: 表达式值被read后，会停止执行指令。</p><h2 id="Examining"><a href="#Examining" class="headerlink" title="Examining"></a>Examining</h2><p><code>x</code>: 打印内存的原始数据，<code>x/x</code>十六进制，<code>x/i</code>汇编。<br><code>print(p)</code>: 打印C expression。<br><code>info registers</code>: 打印寄存器。<br><code>info frame</code>: 打印当前栈帧。<br><code>list &lt;location&gt;</code>: 打印具体位置的source code。<br><code>backtrace</code></p><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p><code>tui enable</code></p><p><code>layout &lt;name&gt;</code><br><code>layout src</code>：显示源代码窗口<br><code>layout asm</code>：显示汇编窗口<br><code>layout regs</code>：显示源代码/汇编和寄存器窗口<br><code>layout split</code>：显示源代码和汇编窗口<br><code>layout next</code>：显示下一个layout<br><code>layout prev</code>：显示上一个layout<br><code>Ctrl + L</code>：刷新窗口<br><code>Ctrl + x</code>，再按1：单窗口模式，显示一个窗口<br><code>Ctrl + x</code>，再按2：双窗口模式，显示两个窗口<br><code>Ctrl + x</code>，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。</p><p><code>focus src/asm/regs</code>: 移动到某个窗口</p><h2 id="Other-tricks"><a href="#Other-tricks" class="headerlink" title="Other tricks"></a>Other tricks</h2><p><code>set</code><br><code>symbol-file</code></p><h2 id="GDB调试core-dump文件"><a href="#GDB调试core-dump文件" class="headerlink" title="GDB调试core dump文件"></a>GDB调试core dump文件</h2><p>默认程序运行触发core dump是不会生成core dump message的，运行<code>ulimit -c</code>可以发现为0.</p><p>生成core dump文件: <code>ulimit -c unlimited</code><br>设置core dump文件路径为当前目录并写入系统环境变量。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">if ! grep -qi 'kernel.core_pattern' /etc/sysctl.conf; then<br>  sudo sh -c 'echo "kernel.core_pattern=core.%p.%u.%s.%e.%t" &gt;&gt; /etc/sysctl.conf'<br>  sudo sysctl -p # 立即生效配置<br>fi<br></code></pre></td></tr></tbody></table></figure><p>提供一个除0错误的core dump源代码<code>test.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">actual_calc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>{<br>  <span class="hljs-type">int</span> c;<br>  c=a/b;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">()</span>{<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">int</span> b;<br>  a=<span class="hljs-number">13</span>;<br>  b=<span class="hljs-number">0</span>;<br>  actual_calc(a, b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>  calc();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>gcc -ggdb test.c -o test.out</code> : -ggdb 生成使用GDB调试器所需的调试信息，而不仅仅是标准的GDB调试信息.<br><code>gdb ./test.out ./core.1341870.1000.8.test.out.1598867712</code></p><p><code>bt</code> 查看出错情况的backtrace。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) bt<br>#<span class="hljs-number">0</span>  <span class="hljs-number">0x000056468844813b</span> in <span class="hljs-title function_">actual_calc</span> <span class="hljs-params">(a=<span class="hljs-number">13</span>, b=<span class="hljs-number">0</span>)</span> at test.c:3<br>#1  0x0000564688448171 in <span class="hljs-title function_">calc</span> <span class="hljs-params">()</span> at test.c:12<br>#2  0x000056468844818a in <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> at test.c:17<br></code></pre></td></tr></tbody></table></figure><p><code>frame/f 2</code> 查看第二帧信息。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://linuxconfig.org/gdb-debugging-tutorial-for-beginners">https://linuxconfig.org/gdb-debugging-tutorial-for-beginners</a><br>to do</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Time Subsystem</title>
    <link href="/2023/05/08/Note/Linux_Driver/Time/"/>
    <url>/2023/05/08/Note/Linux_Driver/Time/</url>
    
    <content type="html"><![CDATA[<p>CONFIG_GENERIC_CLOCKEVENTS：新的时间子系统</p><p>以下选项三选一：</p><p>CONFIG_HZ_PERIODIC：无论何时，都启用用周期性的tick，即便是在系统idle的时候。</p><p>CONFIG_NO_HZ_IDLE：在系统idle的时候，停掉周期性tick。会同时enable NO_HZ_COMMON。</p><p>CONFIG_NO_HZ_FULL：即便在非idle的状态下，也就是说cpu上还运行在task，也可能会停掉tick。会同时enable NO_HZ_COMMON。</p><p>CONFIG_HIGH_RES_TIMERS：高精度timer。</p><p>如果配置了高精度timer，或者配置了NO_HZ_COMMON的选项，那么一定需要配置CONFIG_TICK_ONESHOT，表示系统支持支持one-shot类型的tick device。</p><h1 id="sysfs接口"><a href="#sysfs接口" class="headerlink" title="sysfs接口"></a>sysfs接口</h1><p>cd /sys/bus/clocksource/devices/clocksource0</p><p>cat current_clocksource: 查看当前的clocksource</p><p>cat available_clocksource: 查看可用的clocksource</p><p>echo xxx &gt; current_clocksource: 设置clocksource</p><p>cd /sys/bus/clockevents/devices/clockevent0</p><p>cat current_device: 查看当前的clockevent</p><h1 id="Clocksource"><a href="#Clocksource" class="headerlink" title="Clocksource"></a>Clocksource</h1><h1 id="Clockevent"><a href="#Clockevent" class="headerlink" title="Clockevent"></a>Clockevent</h1>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interrupt Subsystem</title>
    <link href="/2023/05/08/Note/Linux_Driver/Interrupt/"/>
    <url>/2023/05/08/Note/Linux_Driver/Interrupt/</url>
    
    <content type="html"><![CDATA[<h1 id="IRQ-domain"><a href="#IRQ-domain" class="headerlink" title="IRQ domain"></a>IRQ domain</h1><p><a href="http://www.wowotech.net/linux_kenrel/irq-domain.html">http://www.wowotech.net/linux_kenrel/irq-domain.html</a></p><h2 id="1-向系统注册irq-domain"><a href="#1-向系统注册irq-domain" class="headerlink" title="1. 向系统注册irq domain"></a>1. 向系统注册irq domain</h2><p>interrupt controller初始化的过程中，注册irq domain</p><p><code>irq_domain_add_linear(struct device_node *of_node, unsigned int size, const struct irq_domain_ops *ops, void *host_data)</code></p><h2 id="2-为irq-domain创建映射"><a href="#2-为irq-domain创建映射" class="headerlink" title="2. 为irq domain创建映射"></a>2. 为irq domain创建映射</h2><p>在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系。</p><p><strong>方法1</strong>：<code>irq_create_mapping(struct irq_domain *host, irq_hw_number_t hwirq);</code></p><p>比如<code>drivers/clocksource/timer-riscv.c</code>中<code>irq_create_mapping(domain, RV_IRQ_TIMER);</code>直接将hw id(RV_IRQ_TIMER)传入, 创建hw id和irq number的映射。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_create_mapping(domain, hwirq);<br>  irq_create_mapping_affinity();<br>    irq_domain_alloc_descs(); <span class="hljs-comment">// 创建hw id和irq number的映射</span><br>    irq_domain_associate();<br>      domain-&gt;ops-&gt;<span class="hljs-built_in">map</span>(); <span class="hljs-comment">//调用到interrupt controller的map函数</span><br></code></pre></td></tr></tbody></table></figure><p><strong>方法2</strong>：<code>irq_of_parse_and_map</code>. 需要在设备树中指定hw id。</p><p>比如<code>drivers/irqchip/irq-realtek-plic.c</code>中<code>irq_of_parse_and_map</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_of_parse_and_map(<span class="hljs-keyword">struct</span> device_node *dev, <span class="hljs-type">int</span> index);<br>  of_irq_parse_one(dev, index, &amp;oirq); <span class="hljs-comment">// 解析设备树</span><br>  irq_create_of_mapping(&amp;oirq);<br>    irq_create_fwspec_mapping();<br>      irq_create_mapping(domain, hwirq); <span class="hljs-comment">// 最终还是调用到irq_create_mapping</span><br></code></pre></td></tr></tbody></table></figure><p><strong>方法3</strong>：外设driver中直接<code>platform_get_irq</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_get_irq();<br>  platform_get_irq_optional();<br>    of_irq_get();<br>      of_irq_parse_one();<br>      irq_create_of_mapping(); <span class="hljs-comment">// 到这里和上面一样了</span><br></code></pre></td></tr></tbody></table></figure><p><code>struct irq_domain_ops</code>抽象了一个<code>irq domain</code>的callback函数。</p><p><code>(*map)</code>函数在irq domain创建映射<code>irq_create_mapping</code>时会调用到。</p><p><code>(*xlate)</code>用来翻译设备树。</p><p>如果定义了<code>CONFIG_IRQ_DOMAIN_HIERARCHY</code>，<code>(*map)</code>函数对应到<code>*(alloc)</code>, <code>(*xlate)</code>对应到<code>(*translate)</code>。</p><p>参考<code>irq_create_of_mapping-&gt;irq_create_fwspec_mapping</code>如下部分：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (irq_domain_is_hierarchy(domain)) {<br>    virq = irq_domain_alloc_irqs(domain, <span class="hljs-number">1</span>, NUMA_NO_NODE, fwspec); <span class="hljs-comment">// 往下追会调用到domain-&gt;ops-&gt;alloc</span><br>    <span class="hljs-keyword">if</span> (virq &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">/* Create mapping */</span><br>    virq = irq_create_mapping(domain, hwirq); <span class="hljs-comment">// 往下追会调用到domain-&gt;ops-&gt;map</span><br>    <span class="hljs-keyword">if</span> (!virq)<br>        <span class="hljs-keyword">return</span> virq;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在map/alloc函数中需要做的有：</p><p>（1）设定该IRQ number对应的中断描述符（struct irq_desc）的irq chip</p><p>（2）设定该IRQ number对应的中断描述符的highlevel irq-events handler</p><p>（3）设定该IRQ number对应的中断描述符的 irq chip data</p><p>有一个API，<code>irq_domain_set_info</code></p><h1 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h1><p><a href="http://www.wowotech.net/irq_subsystem/interrupt_descriptor.html">http://www.wowotech.net/irq_subsystem/interrupt_descriptor.html</a></p><h3 id="irq-desc"><a href="#irq-desc" class="headerlink" title="irq_desc"></a>irq_desc</h3><p>每个外设驱动调用platform_get_irq就会调用到irq_domain中的.map/.alloc函数，填充irq_desc结构体。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> <span class="hljs-title">irq_desc</span>[<span class="hljs-title">NR_IRQS</span>] // 全局<span class="hljs-title">irq_desc</span>数组，每个外设的中断对应一个<span class="hljs-title">irq_desc</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">// <span class="hljs-title">init</span>/<span class="hljs-title">main</span>.<span class="hljs-title">c</span></span><br><span class="hljs-class"><span class="hljs-title">early_irq_init</span>();</span><br>  desc_set_defaults(); <span class="hljs-comment">// 对每个irq_desc都初始化赋值</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> {</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span>        <span class="hljs-title">irq_data</span>;</span><br>    <span class="hljs-type">irq_flow_handler_t</span>    handle_irq;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span>    *<span class="hljs-title">action</span>;</span><br>  <span class="hljs-comment">//...</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>handle_irq就是highlevel irq-events handler。irq_set_chip_and_handlerz等接口中会设置。</p><p>highlevel irq-events handler可以分成：</p><p>（a）处理电平触发类型的中断handler（handle_level_irq）</p><p>（b）处理边缘触发类型的中断handler（handle_edge_irq）</p><p>（c）处理简单类型的中断handler（handle_simple_irq）</p><p>（d）处理EOI类型的中断handler（handle_fasteoi_irq）</p><h3 id="irq-data"><a href="#irq-data" class="headerlink" title="irq_data"></a>irq_data</h3><p>irq_desc中包含irq_data，irq_data中保存了irq_chip, irq_domain等数据结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> {</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        irq; <span class="hljs-comment">// IRQ number</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        hwirq; <span class="hljs-comment">//HW interrupt ID</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_chip</span>        *<span class="hljs-title">chip</span>;</span> <span class="hljs-comment">//该中断描述符对应的irq chip数据结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_domain</span>    *<span class="hljs-title">domain</span>;</span> <span class="hljs-comment">//该中断描述符对应的irq domain数据结构</span><br>    <span class="hljs-type">void</span>            *handler_data; <span class="hljs-comment">//和外设specific handler相关的私有数据</span><br>    <span class="hljs-type">void</span>            *chip_data; <span class="hljs-comment">//和中断控制器相关的私有数据 e.g.irq_set_chip_data(gpioirq, rtspc);</span><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="irq-chip"><a href="#irq-chip" class="headerlink" title="irq_chip"></a>irq_chip</h3><p>提供回调函数，在request_irq过程中会被调用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_chip</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*irq_startup)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_data *data)</span>; <span class="hljs-comment">// start up the interrupt (defaults to -&gt;irq_enable if NULL)</span><br>  <span class="hljs-type">void</span>(*irq_shutdown)(<span class="hljs-keyword">struct</span> irq_data *data);<br>  <span class="hljs-type">void</span>(*irq_enable)(<span class="hljs-keyword">struct</span> irq_data *data); <span class="hljs-comment">// enable the interrupt (defaults to -&gt;irq_unmask if NULL)</span><br>  <span class="hljs-type">void</span>(*irq_disable)(<span class="hljs-keyword">struct</span> irq_data *data);<br>  <span class="hljs-type">void</span>(*irq_mask)(<span class="hljs-keyword">struct</span> irq_data *data);<br>  <span class="hljs-type">void</span>(*irq_unmask)(<span class="hljs-keyword">struct</span> irq_data *data);<br>  <span class="hljs-type">int</span>(*irq_set_type)(<span class="hljs-keyword">struct</span> irq_data *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flow_type); <span class="hljs-comment">// 指定触发方式，电平触发还是边缘触发</span><br></code></pre></td></tr></tbody></table></figure><p>一些设置的API:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_set_chip<br>irq_set_irq_type<br>irq_set_chip_data<br>__irq_set_handler<br>irq_set_chip_and_handler<br>irq_set_chip_and_handler_name<br>irq_domain_set_info<br></code></pre></td></tr></tbody></table></figure><h1 id="第一级IRQ-Domain-cpu-intc"><a href="#第一级IRQ-Domain-cpu-intc" class="headerlink" title="第一级IRQ Domain cpu-intc"></a>第一级IRQ Domain cpu-intc</h1><p> <code>irq-riscv-intc.c</code></p><p>irq初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init/main.c</span><br>init_IRQ();<br><span class="hljs-comment">//arch/riscv/kernel/irq.c</span><br>init_IRQ();<br>  irqchip_init();<br><span class="hljs-comment">// drivers/irqchip/irqchip.c</span><br>irqchip_init();<br>  of_irq_init();<br>    IRQCHIP_DECLARE(riscv, <span class="hljs-string">"riscv,cpu-intc"</span>, riscv_intc_init); <span class="hljs-comment">// 进入riscv_intc_init</span><br><br>riscv_intc_init();<br>intc_domain = irq_domain_add_linear(node, BITS_PER_LONG, &amp;riscv_intc_domain_ops, <span class="hljs-literal">NULL</span> <span class="hljs-comment">/// 注册irq_domain</span><br>set_handle_irq(&amp;riscv_intc_irq); <span class="hljs-comment">/// 设置中断handler</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 每个cpu int都会调用到cpu interrupt controller的map函数，会填充irq_desc。</span><br>irq_create_mapping();<br>domain-&gt;ops-&gt;<span class="hljs-built_in">map</span>;<br>.<span class="hljs-built_in">map</span> = riscv_intc_domain_map();<br>  irq_domain_set_info();<br>    irq_set_chip_and_handler_name(virq, chip, handler, handler_name);<br>      irq_set_chip();<br>        desc-&gt;irq_data.chip = chip;<br>      __irq_set_handler();<br>        desc-&gt;handle_irq = handle; <span class="hljs-comment">// handle是handle_percpu_devid_irq</span><br>    irq_set_chip_data(virq, chip_data); <span class="hljs-comment">// d-&gt;host_data irq_domain_add_linear最后一个参数</span><br>      desc-&gt;irq_data.chip_data = data; <span class="hljs-comment">// irq chip的私有数据</span><br>    irq_set_handler_data(virq, handler_data);<br>      desc-&gt;irq_common_data.handler_data = data; <span class="hljs-comment">// data=NULL</span><br></code></pre></td></tr></tbody></table></figure><h1 id="第二级-IRQ-Domain-Plic"><a href="#第二级-IRQ-Domain-Plic" class="headerlink" title="第二级 IRQ Domain Plic"></a>第二级 IRQ Domain Plic</h1><p><code>irq-realtek-plic.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">irq_domain_add_linear(node, nr_irqs + <span class="hljs-number">1</span>, &amp;plic_irqdomain_ops, priv);<br>irq_of_parse_and_map(node, i);<br>irq_set_chained_handler(plic_parent_irq, plic_handle_irq); <span class="hljs-comment">//发生9号外部中断(plic_parent_irq)，会进plic_handle_irq</span><br></code></pre></td></tr></tbody></table></figure><p>级联的第二级interrupt controller调用<code>irq_set_chained_handler</code>设置 interrupt handler</p><h1 id="IRQ-Domain-GPIO-interrupt-controller"><a href="#IRQ-Domain-GPIO-interrupt-controller" class="headerlink" title="IRQ Domain GPIO interrupt controller"></a>IRQ Domain GPIO interrupt controller</h1><p><code>pinctrl-rts3917.c</code> 做法不像plic的级联中断处理。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">rtspc-&gt;irq_domain = irq_domain_add_linear();<br><span class="hljs-type">int</span> gpioirq = irq_create_mapping();<br>irq_set_chip_and_handler();<br><span class="hljs-comment">// 中断来了会先进handle_simple_irq，再进rts_irq_handler</span><br>request_irq();<br></code></pre></td></tr></tbody></table></figure><p>外设调用platform_get_irq：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">platform_get_irq();<br>...<br>irq_create_of_mapping<br>  irq_create_fwspec_mapping<br>    irq_domain_alloc_irqs<br>      __irq_domain_alloc_irqs<br>        irq_domain_alloc_irqs_hierarchy<br>          domain-&gt;ops-&gt;alloc<br>            irq_domain_translate_onecell<br>            plic_irqdomain_map<br>              irq_domain_set_info<br>                ...<br>                  desc-&gt;handle_irq = handle; <span class="hljs-comment">// handle: handle_fasteoi_irq</span><br></code></pre></td></tr></tbody></table></figure><h1 id="risc-v中断处理流程"><a href="#risc-v中断处理流程" class="headerlink" title="risc-v中断处理流程"></a>risc-v中断处理流程</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// head.S</span><br>setup_trap_vector:<br>  la a0, handle_exception<br>  csrw CSR_TVEC, a0     <span class="hljs-comment">// handle_exception地址传入CSR_TVEC</span><br>  csrw CSR_SCRATCH, zero   <span class="hljs-comment">// CSR_SCRATCH清零</span><br><br><span class="hljs-comment">// entry.S</span><br>ENTRY(handle_exception)<br>  handle_arch_irq();<br>    set_handle_irq();<br>      riscv_intc_irq();<br>        handle_domain_irq();<br>          __handle_domain_irq();<br>            generic_handle_irq();<br>              generic_handle_irq_desc();<br>                <span class="hljs-comment">// 不同的中断控制器在一开始初始化会设置</span><br>                desc-&gt;handle_irq(desc);<br>  handle_syscall(); <span class="hljs-comment">//处理系统调用</span><br>  excp_vect_table(); <span class="hljs-comment">//处理异常</span><br><br><span class="hljs-comment">// 这里cpu int会进入handle_percpu_devid_irq, 在irq-riscv-intc.c irq_domain_set_info中设定</span><br>handle_percpu_devid_irq();<br>  action-&gt;handler(); <span class="hljs-comment">// timer-riscv.c 中request_irq会把中断处理函数赋值给action-&gt;handler();</span><br><br><span class="hljs-comment">// external int 会进入plic_handle_irq, 在irq-realtek-plic.c irq_set_chained_handler中设定</span><br>plic_handle_irq();<br>  generic_handle_irq();<br>    generic_handle_irq_desc();<br>      desc-&gt;handle_irq(desc);<br>        handle_fasteoi_irq();<br>          ...<br>                    <span class="hljs-comment">// request_irq中会把自定义的handler function赋值给action-&gt;handler</span><br>                    action-&gt;handler();<br></code></pre></td></tr></tbody></table></figure><p><em><strong>是否所有的irq_domain的irq number是按顺序排列下去，每个irq_number设置一个interrupt handler，不会重复？</strong></em></p><h1 id="Bottom-half"><a href="#Bottom-half" class="headerlink" title="Bottom half"></a>Bottom half</h1><p>softirq，tasklet，workqueue。</p><p>workqueue运行在<strong>process context</strong>，而softirq和tasklet运行在<strong>interrupt context</strong>。</p><p>在有sleep需求的场景中，defering task必须延迟到kernel thread中执行，也就是说必须使用workqueue机制。</p><p>softirq更倾向于性能，而tasklet更倾向于易用性。软中断可以在多个CPU上并行运行，因此需要考虑可重入问题，而tasklet会绑定在某个cpu上运行，不要求重入问题，因此性能会下降一些。</p>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uCore_Chapter1 应用程序与基本执行环境</title>
    <link href="/2023/04/25/Project/rCore_uCore/uCore_Chapter1/"/>
    <url>/2023/04/25/Project/rCore_uCore/uCore_Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">make build # 仅编译<br>make run # 编译+运行qemu<br>make run LOG=trace # 其他选项可以看Makefile<br>make clean # rm build/<br>make debug # 编译+运行gdb调试<br></code></pre></td></tr></tbody></table></figure><p>每次在make run之前，尽量先执行make clean以删除缓存，特别是在切换ch分支之后。</p><p><strong>退出 qemu 的方法</strong></p><p>如果是正常推出，uCore 会自动关闭 qemu，但如果 os 跑飞了，我们不能通过 <code>Ctrl + C</code> 来推出。此时可以先按下 <code>Ctrl+A</code> ，再按下 <code>X</code> 来退出 Qemu。</p><h1 id="ch1"><a href="#ch1" class="headerlink" title="ch1"></a>ch1</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// entry.S</span><br>_entry<br>    la sp, boot_stack_top <span class="hljs-comment">//设置堆栈</span><br>    call main<br><span class="hljs-comment">// main.c</span><br>  clean_bss();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello wrold!\n"</span>);<br>    consputc();<br>      console_putchar(<span class="hljs-type">int</span> c);<br>        sbi_call(SBI_CONSOLE_PUTCHAR, c, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><p class="note note-danger">怎么用gdb调试？`file kernel`然后？</p><h2 id="Makefile流程分析"><a href="#Makefile流程分析" class="headerlink" title="Makefile流程分析"></a>Makefile流程分析</h2><p>根据<code>make run </code>打印的信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -fno-stack-protector -D LOG_LEVEL_ERROR  -fno-pie -no-pie -c os/console.c -o build/os/console.o<br>... # 编译所有的.c文件成.o文件<br>riscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/sbi.o build/os/printf.o  build/os/entry.o build/os/link_app.o # 链接<br>riscv64-unknown-elf-objdump -S build/kernel &gt; build/kernel.asm<br>riscv64-unknown-elf-objdump -t build/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; build/kernel.sym<br>Build kernel done<br></code></pre></td></tr></tbody></table></figure><p>比较熟悉的是<code>objdump -d</code> <code>objdump -D</code>将所有段都反汇编，而<code>-d</code>应该仅反汇编代码段。</p><p><code>objdump -S</code>是在-d的基础上，代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用<code>-g</code>参数，即需要调试信息。</p><p><code>objdump -t</code>打印符号表。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uCore_Chapter2 批处理系统</title>
    <link href="/2023/04/25/Project/rCore_uCore/uCore_Chapter2/"/>
    <url>/2023/04/25/Project/rCore_uCore/uCore_Chapter2/</url>
    
    <content type="html"><![CDATA[<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make -C user clean <span class="hljs-comment"># 在os目录，相当于cd user;make clean;cd ..</span><br>make clean <span class="hljs-comment"># 或者在user目录</span><br>git checkout ch2<br>make user BASE=1 CHAPTER=2<br>make run<br>make test BASE=1 <span class="hljs-comment"># make test 会完成　make user 和 make run 两个步骤（自动设置 CHAPTER）</span><br></code></pre></td></tr></tbody></table></figure><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">main();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello wrold!\n"</span>);<br>  trap_init(); <span class="hljs-comment">// 设置中断/异常处理地址</span><br>    w_stvec((uint64)uservec &amp; ~<span class="hljs-number">0x3</span>); <span class="hljs-comment">//把uservec地址传入,uservec在trampoline.S中定义</span><br>      <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">"csrw stvec, %0"</span> : : <span class="hljs-string">"r"</span>(x))</span>; <span class="hljs-comment">// 设置stvec CSR</span><br>  loader_init();<br>  run_next_app();<br>    load_app();<br>    usertrapret(trapframe, (uint64)boot_stack_top);<br>      w_sepc(trapframe-&gt;epc);<br>      r_sstatus();<br>      w_sstatus();<br>      userret();<br>        sret <span class="hljs-comment">// 返回到sepc中的值，0x80400000第一个app</span><br><br></code></pre></td></tr></tbody></table></figure><h2 id="应用程序系统调用ecall进入内核异常处理过程"><a href="#应用程序系统调用ecall进入内核异常处理过程" class="headerlink" title="应用程序系统调用ecall进入内核异常处理过程"></a>应用程序系统调用ecall进入内核异常处理过程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进入应用程序</span><br><span class="hljs-built_in">exit</span>(MAGIC);<br>  syscall(SYS_exit, code);<br>    __syscall1(n, <span class="hljs-type">long</span>(<span class="hljs-number">1234</span>));<br>      __asm_syscall(<span class="hljs-string">"r"</span>(a7), <span class="hljs-string">"0"</span>(a0));<br>        ecall <span class="hljs-comment">//通过ecall 进入uservec</span><br><br>uservec<br>  <span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span>; <span class="hljs-comment">// ld t0, 16(a0) jr t0</span><br>    r_scause();<br>      csrr %<span class="hljs-number">0</span>, scause <span class="hljs-comment">// 应用层调用了ecall指令，所以scause自动被设置为8</span><br>    syscall();<br>      <span class="hljs-comment">//在uservec中应用层传入eid到寄存器a7,这里读a7来判断是什么system call</span><br>      id = trapframe-&gt;a7;<br>    usertrapret(); <span class="hljs-comment">// 这里回到第九行一样，循环，执行第二个应用程序</span><br></code></pre></td></tr></tbody></table></figure><p>分析下<code>uservec</code>,注意：这里只是把stvec设置为uservec地址，并不会执行uservec下的代码，要等U mode的中断/异常到来时才会从uservec开始执行。</p><p class="note note-warning">uservec是U mode异常/中断的入口。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl uservec<br>uservec:<br>        csrrw a0, sscratch, a0 # 交换a0和sscratch<br><br>        # save the user registers in TRAPFRAME<br>        sd ra, 40(a0)<br>        sd sp, 48(a0)<br>    ...<br>        sd t6, 280(a0)<br><br>  # save the user a0 in p-&gt;trapframe-&gt;a0<br>        csrr t0, sscratch<br>        sd t0, 112(a0)<br><br>        csrr t1, sepc<br>        sd t1, 24(a0) # BASE_ADDRESS 0x80400000<br><br>        ld sp, 8(a0) # kstack + PGSIZE<br>        ld tp, 32(a0)<br>        ld t1, 0(a0)<br>        # csrw satp, t1<br>        # sfence.vma zero, zero<br>        ld t0, 16(a0)<br>        jr t0<br><br></code></pre></td></tr></tbody></table></figure><p>这里需要注意sscratch这个CSR寄存器的作用就是一个cache，它只负责存某一个值，这里它保存的就是trapframe结构体的位置。</p><h1 id="实现批处理操作系统的细节"><a href="#实现批处理操作系统的细节" class="headerlink" title="实现批处理操作系统的细节"></a>实现批处理操作系统的细节</h1><p>从Makefile中可以发现，scripts/pack.py，scripts/kernelld.py用来生成os/link_app.S和os/kernel_app.ld。link_app.S将用户程序加入kernel可执行文件中。kernel_app.ld规定了用户程序所在的段(.data.app[x])。在load_app()中将用户程序relocate到0x80400000。</p><p>需要relocate的原因：我们并不能直接跳转到 app_n_start 直接运行，因为用户程序在编译的时候，会假定程序处在虚存的特定位置，而由于我们还没有虚存机制，因此我们在运行之前还需要将用户程序加载到规定的物理内存位置。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>U-Boot启动流程</title>
    <link href="/2023/04/19/Misc/U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/04/19/Misc/U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Uboot编译流程"><a href="#Uboot编译流程" class="headerlink" title="Uboot编译流程"></a>Uboot编译流程</h1><p><a href="https://blog.csdn.net/ooonebook/article/details/53000893">https://blog.csdn.net/ooonebook/article/details/53000893</a></p><p>编译生成的文件：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414152845.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414152904.png"></p><p>具体可以参考Uboot Makefile</p><h2 id="u-boot-Makefile"><a href="#u-boot-Makefile" class="headerlink" title="u-boot Makefile"></a>u-boot Makefile</h2><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><br><span class="hljs-section">u-boot.cfg: <span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(srctree)</span>/scripts/Makefile.autoconf $(@)</span><br><span class="hljs-section">cfg: u-boot.cfg</span><br><span class="hljs-section">prepare2: prepare3 outputmakefile cfg</span><br><span class="hljs-section">prepare1: prepare2<span class="hljs-variable">$(version_h)</span> <span class="hljs-variable">$(timestamp_h)</span> <span class="hljs-variable">$(dt_h)</span> <span class="hljs-variable">$(env_h)</span> include/config/auto.conf</span><br><span class="hljs-section">archprepare: prepare1 scripts_basic</span><br><span class="hljs-section">prepare0: archprepare</span><br><span class="hljs-section">prepare:prepare0</span><br><span class="hljs-section">scripts: scripts_basic scripts_dtc include/config/auto.conf</span><br><br><span class="hljs-section">$(u-boot-dirs): prepare scripts</span><br><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(u-boot-init)</span> $(u-boot-main)): $(u-boot-dirs)<br><br>u-boot-init := $(head-y)<br>u-boot-main := $(libs-y)<br>u-boot-keep-syms-lto := keep-syms-lto.o<br><span class="hljs-section">u-boot.lds: <span class="hljs-variable">$(LDSCRIPT)</span> prepare</span><br><br><span class="hljs-section">u-boot:  $(u-boot-init) $(u-boot-main) $(u-boot-keep-syms-lto) u-boot.lds</span><br><span class="hljs-section">u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb</span><br><span class="hljs-section">u-boot-nodtb.bin: u-boot</span><br><span class="hljs-section">dts/dt.dtb: u-boot</span><br><br><span class="hljs-section">u-boot.srec: u-boot</span><br><span class="hljs-section">u-boot.bin: u-boot-dtb.bin</span><br><span class="hljs-section">u-boot.sym: u-boot</span><br><span class="hljs-section">System.map:  u-boot</span><br><span class="hljs-section">binary_size_check: u-boot-nodtb.bin</span><br><span class="hljs-section">u-boot.dtb: dts/dt.dtb</span><br><br>INPUTS-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check<br>INPUTS-<span class="hljs-variable">$(CONFIG_OF_SEPARATE)</span> += <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(CONFIG_OF_OMIT_DTB)</span>,dts/dt.dtb,u-boot.dtb)</span><br><br><span class="hljs-section">.binman_stamp: $(INPUTS-y)</span><br><br><span class="hljs-section">all: .binman_stamp</span><br><br></code></pre></td></tr></tbody></table></figure><h1 id="Uboot-启动流程"><a href="#Uboot-启动流程" class="headerlink" title="Uboot 启动流程"></a>Uboot 启动流程</h1><p><a href="https://blog.csdn.net/ooonebook/article/details/53070065">https://blog.csdn.net/ooonebook/article/details/53070065</a></p><h2 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h2><p>Nor/Nand run code from <strong>flash</strong>.</p><p>Emmc boot/security boot run code from <strong>ROM</strong>.</p><p>初始化CPU、拷贝第二阶段代码到sram</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/realtek/rts3917/ram_init/boot.S</span><br>_start:<br>    save_boot_params<br>        bsave_boot_params_ret<br><br>save_boot_params_ret:<br>    cpu_init_cp15<br><br>    ldrr0, =(CONFIG_SYS_FLASH_BASE + CONFIG_RAMINIT_OFFSET) <span class="hljs-comment">// CONFIG_SYS_FLASH_BASE = 0   CONFIG_RAMINIT_OFFSET = 2048</span><br>    ldrr1, =(CONFIG_LOAD_BASE) <span class="hljs-comment">// 0x19000000 sram地址</span><br>    ldrr2, =(CONFIG_SYS_FLASH_BASE + CONFIG_RAMINIT_OFFSET \ <span class="hljs-comment">// CONFIG_RAMINIT_SIZE = stat -c %s init.bin 即uboot第二阶段代码的长度</span><br>        + CONFIG_RAMINIT_SIZE)<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * r0 = source address</span><br><span class="hljs-comment">     * r1 = target address</span><br><span class="hljs-comment">     * r2 = source end address</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-number">1</span>:<br>    ldrr3, [r0], #<span class="hljs-number">4</span> <span class="hljs-comment">// 拷贝第二阶段代码到sram</span><br>    strr3, [r1], #<span class="hljs-number">4</span><br>    cmpr0, r2<br>    bne<span class="hljs-number">1b</span><br><br>    ldr pc,=(CONFIG_LOAD_BASE) <span class="hljs-comment">// 0x19000000 sram地址</span><br></code></pre></td></tr></tbody></table></figure><h2 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h2><p>初始化cpu，初始化ddr，ddr controller，时钟，拷贝uboot到ddr</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/realtek/rts3917/ram_init/init.S</span><br>_start:<br>    bsave_boot_params<br>        bsave_boot_params_ret<br><br>save_boot_params_ret:<br>    blcpu_init_cp15<br>    ldrr0, =(CONFIG_SYS_INIT_SP_ADDR_SRAM) <span class="hljs-comment">/// 设置堆栈为C code准备 CONFIG_SYS_INIT_SP_ADDR_SRAM = 0x19010000</span><br>    bicr0, r0, #<span class="hljs-number">7</span><span class="hljs-comment">/* 8-byte alignment for ABI compliance */</span><br>    movsp, r0<br><br>    blbsp_boot_init_plat <span class="hljs-comment">/// bsp_init.c 初始化时钟、DDR、DDR controller</span><br>    blfast_copy <span class="hljs-comment">//dma_copy.c 拷贝uboot到0x82800000</span><br>    ldr pc,=(CONFIG_LOAD_BASE) <span class="hljs-comment">/// 0x82800000</span><br></code></pre></td></tr></tbody></table></figure><h2 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h2><p>初始化cpu，relocate uboot，初始化串口，flash，网卡等。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/vectors.S</span><br>_start:<br>    ARM_VECTORS<br>.macro ARM_VECTORS<br>    breset<br><br><span class="hljs-comment">// arch/arm/cpu/armv7/start.S</span><br>reset:<br>    bsave_boot_params<br><br><span class="hljs-title function_">ENTRY</span><span class="hljs-params">(save_boot_params)</span><br>    bsave_boot_params_ret@ back to my caller<br><br>save_boot_params_ret:<br>    cpu_init_cp15<br>    cpu_init_crit<br>        lowlevel_init <span class="hljs-comment">// board/realtek/rts3917/low_level.S</span><br>    _main<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># arch/arm/lib/crt0.S<br>ENTRY(_main)<br>  ldrr0, =(CONFIG_SYS_INIT_SP_ADDR)<br>  blboard_init_f_alloc_reserve # board_init.c 设置global_data起始地址<br>  blboard_init_f_init_reserve # board_init.c 初始化global_data，清零<br>  # 对gd成员赋值，对relocate进行空间规划；计算relocate后的偏移；relocate旧的gd到新的gd空间上<br>  blboard_init_f<br>  brelocate_code # 重定位u-boot<br>  blrelocate_vectors #重定位异常向量表<br>  SPL_CLEAR_BSS<br>  board_init_r<br>    run_main_loop<br>      main_loop<br>      s = bootdelay_process # s = "bootcmd"<br>      autoboot_command(s) # 自动执行bootcmd<br>      cli_loop # 获取命令<br></code></pre></td></tr></tbody></table></figure><p>经过<code>board_init_f_init_reserve</code>后</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230417154543.png"></p><p>经过<code>board_init_f</code>规划后新的u-boot分布：</p><p>调用<code>bd_info</code>命令可以查看relocate后各gd成员的地址。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230417142657.png"></p><p>env初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// nor flash为例</span><br>env_init(); <span class="hljs-comment">// board_f.c</span><br>  drv-&gt;init();<br><br>env_sf_init(); <span class="hljs-comment">// CONFIG_ENV_IS_IN_SPI_FLAH sf.c drv-&gt;init();</span><br>    gd-&gt;env_addr = (ulong)&amp;default_environment[<span class="hljs-number">0</span>]; <span class="hljs-comment">/// 加载默认的环境变量</span><br>    gd-&gt;env_valid = <span class="hljs-number">1</span>;<br><br><br>initr_env(); <span class="hljs-comment">// board_r.c</span><br>  env_relocate();<br>    env_load();<br>      drv-&gt;load();<br><br>env_sf_load(); <span class="hljs-comment">// sf.c drv-&gt;load();</span><br>  get_rst_mode();<br>  setup_flash_device(); <span class="hljs-comment">// 初始化nor flash</span><br>    spi_flash_probe();<br>  spi_flash_read(flash, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE, buf); <span class="hljs-comment">// 从flash上读环境变量</span><br>  env_import(buf, <span class="hljs-number">1</span>);<br>    crc32(<span class="hljs-number">0</span>, ep-&gt;data, ENV_SIZE)； <span class="hljs-comment">// check crc</span><br>    himport_r(); <span class="hljs-comment">// 将环境变量存入一个hash table</span><br><br><br>env_get()<br>  <span class="hljs-keyword">if</span> (gd-&gt;flags &amp; GD_FLG_ENV_READY) { <span class="hljs-comment">// board_r.c 初始化完环境变量后GD_FLG_ENV_READY</span><br>  ...<br>  }；<br>  env_get_f() <span class="hljs-comment">// 在初始化环境变量前，会从default_environment[]中读取匹配变量，存入gd-&gt;env_buf</span><br>      env_match()<br></code></pre></td></tr></tbody></table></figure><p>fdt初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">fdtdec_setup();<br>  board_fdt_blob_setup()<br>reserve_fdt();<br>reloc_fdt();<br>initr_get_fdt_offset();<br>  _do_get_offset(<span class="hljs-string">"kernel"</span>);<br>    dma_copy_dtb_to_ddr(<span class="hljs-string">"dtb_offset"</span>); <span class="hljs-comment">/// 拷贝dtb</span><br></code></pre></td></tr></tbody></table></figure><h2 id="global-data"><a href="#global-data" class="headerlink" title="global_data"></a>global_data</h2><p>uboot中定义了一个宏<code>DECLARE_GLOBAL_DATA_PTR</code>，使我们可以更加简单地获取global_data。</p><p>global_data的地址存放在r9中，直接从r9寄存器中获取其地址即可。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//arch/arm/include/asm/global_data.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_GLOBAL_DATA_PTR    register volatile gd_t *gd asm (<span class="hljs-string">"r9"</span>)</span><br><br><span class="hljs-comment">// DECLARE_GLOBAL_DATA_PTR定义了gd_t *gd，并且其地址是r9中的值。</span><br><span class="hljs-comment">// 一旦使用了DECLARE_GLOBAL_DATA_PTR声明之后，后续就可以直接使用gd变量，也就是global_data了。</span><br></code></pre></td></tr></tbody></table></figure><h1 id="Uboot启动kernel"><a href="#Uboot启动kernel" class="headerlink" title="Uboot启动kernel"></a>Uboot启动kernel</h1><p>uboot用image_header来表示Legacy-uImage的头部</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">image_header</span> {</span><br>  <span class="hljs-type">uint32_t</span>ih_magic;<span class="hljs-comment">/* Image Header Magic Number*/</span><br>  <span class="hljs-type">uint32_t</span>ih_hcrc;<span class="hljs-comment">/* Image Header CRC Checksum*/</span><br>  <span class="hljs-type">uint32_t</span>ih_time;<span class="hljs-comment">/* Image Creation Timestamp*/</span><br>  <span class="hljs-type">uint32_t</span>ih_size;<span class="hljs-comment">/* Image Data Size*/</span><br>  <span class="hljs-type">uint32_t</span>ih_load;<span class="hljs-comment">/* Data Load  Address*/</span><br>  <span class="hljs-type">uint32_t</span>ih_ep;<span class="hljs-comment">/* Entry Point Address*/</span><br>  <span class="hljs-type">uint32_t</span>ih_dcrc;<span class="hljs-comment">/* Image Data CRC Checksum*/</span><br>  <span class="hljs-type">uint8_t</span>ih_os;<span class="hljs-comment">/* Operating System*/</span><br>  <span class="hljs-type">uint8_t</span>ih_arch;<span class="hljs-comment">/* CPU architecture*/</span><br>  <span class="hljs-type">uint8_t</span>ih_type;<span class="hljs-comment">/* Image Type*/</span><br>  <span class="hljs-type">uint8_t</span>ih_comp;<span class="hljs-comment">/* Compression Type*/</span><br>  <span class="hljs-type">uint8_t</span>ih_name[IH_NMLEN];<span class="hljs-comment">/* Image Name*/</span><br>} <span class="hljs-type">image_header_t</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230419101548.png"></p><p><code>ih_magic=0x27051956</code>表示是一个<code>Legacy-uImage</code></p><p><code>ih_load=81000000</code></p><p><code>ih_ep=81000000</code></p><p><code>ih_os, ih_arch, ih_type, ih_comp=05, 02, 02, 00</code> 具体定义在uboot<code> image.h</code>中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cmd/bootm.c</span><br>bootm();<br>  do_bootm();<br>    do_bootm_states(BOOTM_STATE_START |<br>    BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |<br>    BOOTM_STATE_LOADOS | BOOTM_STATE_OS_PREP |<br>         BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);<br><br><span class="hljs-comment">// common/bootm.c</span><br>bootm_start();<br>  images.verify = env_get_yesno(<span class="hljs-string">"verify"</span>); <span class="hljs-comment">/// 不存在verify，return -1，默认为true</span><br>bootm_find_os(); <span class="hljs-comment">// 填充bootm_headers_t images</span><br>  <span class="hljs-comment">// 获取kernel image的data起始地址和长度</span><br>  os_hdr = boot_get_kernel(&amp;images.os.image_start, &amp;images.os.image_len);<br>    img_addr = genimg_get_kernel_addr_fit(); <span class="hljs-comment">// 获取kernel地址</span><br>    genimg_get_image(img_addr);<br>    image_get_kernel(img_addr, images-&gt;verify);<br>           image_print_contents(); <span class="hljs-comment">// 打印信息</span><br>      image_check_dcrc(); <span class="hljs-comment">// check crc</span><br>    images.os.type = image_get_type(os_hdr); <span class="hljs-comment">/// Kernel Image</span><br>    images.os.comp = image_get_comp(os_hdr); <span class="hljs-comment">/// uncompressed</span><br>    images.os.os = image_get_os(os_hdr); <span class="hljs-comment">/// Linux</span><br>    images.os.end = image_get_image_end(os_hdr);<br>    images.os.load = image_get_load(os_hdr); <span class="hljs-comment">/// 0x81000000</span><br>    images.os.arch = image_get_arch(os_hdr); <span class="hljs-comment">/// ARM</span><br>  images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy); <span class="hljs-comment">/// 0x81000000</span><br>  images.os.start = map_to_sysmem(os_hdr); <span class="hljs-comment">// 0xC0000</span><br>bootm_find_other();<br>  bootm_find_images();<br>    boot_get_fdt(&amp;images.ft_addr, &amp;images.ft_len); <span class="hljs-comment">// 获取fdt地址和长度</span><br>bootm_disable_interrupts();<br>bootm_load_os(images, <span class="hljs-number">0</span>);<br>  image_decomp(); <span class="hljs-comment">// 这里会拷贝kernel image从flash到load address</span><br>boot_fn = bootm_os_get_boot_func(images-&gt;os.os);<br>boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);<br>  do_bootm_linux(); <span class="hljs-comment">//arch/arm/lib/bootm.c</span><br>    boot_prep_linux(); <span class="hljs-comment">//arch/arm/lib/bootm.c</span><br>      image_setup_linux(); <span class="hljs-comment">// common/image.c</span><br>        boot_relocate_fdt();<br>        image_setup_libfdt();<br>      board_prep_linux(); <span class="hljs-comment">// skip</span><br>boot_selected_os(argc, argv, BOOTM_STATE_OS_GO, images, boot_fn);<br>    boot_fn(state, argc, argv, images);<br>      do_bootm_linux();<br>        boot_jump_linux();<br>          kernel_entry = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, uint))images-&gt;ep;<br>          kernel_entry(<span class="hljs-number">0</span>, machid, r2); <span class="hljs-comment">// 进入kernel entry point</span><br></code></pre></td></tr></tbody></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/ooonebook/category_6484145.html">U-boot专栏</a></p><p><a href="%5B%3Chttps://xyc-1316422823.cos.ap-shanghai.myqcloud.com/uboot_introduction.ppt%3E%5D(%3Chttps://xyc-1316422823.cos.ap-shanghai.myqcloud.com/uboot_introduction.ppt%3E)">Uboot PPT</a></p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>U-Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C Subsystem</title>
    <link href="/2023/04/13/Note/Linux_Driver/I2C/"/>
    <url>/2023/04/13/Note/Linux_Driver/I2C/</url>
    
    <content type="html"><![CDATA[<h1 id="用户层测试指令"><a href="#用户层测试指令" class="headerlink" title="用户层测试指令"></a>用户层测试指令</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检测当前系统有几组i2c总线</span><br>i2cdetect -l<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看i2c-0接口上的设备</span><br>i2cdetect -y -a 0 # Force scanning of non-regular addresses<br>i2cdetect -y -r 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取指定设备的全部寄存器的值</span><br>i2cdump -f -y 0 0x68<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取指定i2c设备的某个寄存器的值，如下读取i2c-0地址为0x68器件中的0x01寄存器</span><br>i2cget -f -y 0 0x68 0x01<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入指定i2c设备的某个寄存器的值，如下写入i2c-0地址为0x68器件中的0x01寄存器值为0x6f</span><br>i2cset -f -y 0 0x68 0x01 0x6f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入i2c-0地址为0x50的eeprom，从偏移为0x64地址读8个byte。</span><br>i2ctransfer -f -y 0 w1@0x50 0x64 r8<br></code></pre></td></tr></tbody></table></figure><h1 id="I2C-基础知识"><a href="#I2C-基础知识" class="headerlink" title="I2C 基础知识"></a>I2C 基础知识</h1><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><ul><li>主芯片要发出一个start信号</li><li>然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读/写，0表示写，1表示读)</li><li>从设备回应(用来确定这个设备是否存在)，然后就可以传输数据</li><li>主设备发送一个字节数据给从设备，并等待回应</li><li>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</li><li>数据发送完之后，主芯片就会发送一个停止信号。</li></ul><p>下图：白色背景表示”主→从”，灰色背景表示”从→主”</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143312.png"></p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143336.png"></p><h2 id="I2C信号"><a href="#I2C信号" class="headerlink" title="I2C信号"></a>I2C信号</h2><p>I2C协议中数据传输的单位是字节，也就是8位。但是要用到9个时钟：前面8个时钟用来传输8数据，第9个时钟用来传输回应信号。传输时，先传输最高位(MSB)。</p><ul><li>开始信号（S）：SCL为高电平时，SDA山高电平向低电平跳变，开始传送数据。</li><li>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li><li>响应信号(ACK)：接收器在接收到8位数据后，在第9个时钟周期，拉低SDA</li><li>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化</li></ul><p>I2C协议信号如下：</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143408.png"></p><h2 id="SMBus协议"><a href="#SMBus协议" class="headerlink" title="SMBus协议"></a>SMBus协议</h2><p>System Management Bus，系统管理总线。<strong>是I2C协议的一个子集</strong></p><ul><li><p>VDD的极限值不一样</p><ul><li>I2C协议：范围很广，甚至讨论了高达12V的情况</li><li>SMBus：1.8V~5V</li></ul></li><li><p>最小时钟频率、最大的Clock Stretching</p><ul><li>Clock Stretching含义：某个设备需要更多时间进行内部的处理时，它可以把SCL拉低占住I2C总线</li><li>I2C协议：时钟频率最小值无限制，Clock Stretching时长也没有限制</li><li>SMBus：时钟频率最小值是10KHz，Clock Stretching的最大时间值也有限制</li></ul></li><li><p>地址回应(Address Acknowledge)</p><ul><li>一个I2C设备接收到它的设备地址后，是否必须发出回应信号？</li><li>I2C协议：没有强制要求必须发出回应信号</li><li>SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了</li></ul></li><li><p>SMBus协议明确了数据的传输格式</p><ul><li>I2C协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义</li><li>SMBus：定义了几种数据格式(后面分析)</li></ul></li><li><p>REPEATED START Condition(重复发出S信号)</p><ul><li><p>比如读EEPROM时，涉及2个操作：</p><ul><li>把存储地址发给设备</li><li>读数据</li></ul></li><li><p>在写、读之间，可以不发出P信号，而是直接发出S信号：这个S信号就是<code>REPEATED START</code></p></li><li><p>如下图所示</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230414143735.png"></p></li></ul></li><li><p>SMBus Low Power Version</p><ul><li>SMBus也有低功耗的版本</li></ul></li></ul><h1 id="I2C-provider"><a href="#I2C-provider" class="headerlink" title="I2C provider"></a>I2C provider</h1><p><a href="http://www.wowotech.net/comm/i2c_provider.html">http://www.wowotech.net/comm/i2c_provider.html</a></p><p><code>i2c_adapter</code>抽象I2C控制器</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> {</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span>  <span class="hljs-comment">/* classes to allow probing for */</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> *<span class="hljs-title">algo</span>;</span> <span class="hljs-comment">/* the algorithm to access the bus */</span><br>  <span class="hljs-type">void</span> *algo_data;<br><br>  <span class="hljs-comment">/* data fields that are valid for all devices*/</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_lock_operations</span> *<span class="hljs-title">lock_ops</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">bus_lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex</span> <span class="hljs-title">mux_lock</span>;</span><br><br>  <span class="hljs-type">int</span> timeout;<span class="hljs-comment">/* in jiffies */</span><br>  <span class="hljs-type">int</span> retries;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* the adapter device */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_flags;<span class="hljs-comment">/* owned by the I2C core */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_ALF_IS_SUSPENDED    0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_ALF_SUSPEND_REPORTED  1</span><br><br>  <span class="hljs-type">int</span> nr;<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">48</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">dev_released</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">userspace_clients_lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">userspace_clients</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_bus_recovery_info</span> *<span class="hljs-title">bus_recovery_info</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter_quirks</span> *<span class="hljs-title">quirks</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_domain</span> *<span class="hljs-title">host_notify_domain</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure><p><code>i2c_algorithm</code>抽象了通过I2C总线发送和接收数据的方法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> {</span><br>  <span class="hljs-type">int</span> (*master_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, <span class="hljs-keyword">struct</span> i2c_msg *msgs,<br>         <span class="hljs-type">int</span> num);<br>    <span class="hljs-comment">// 功能跟master_xfer一样，在atomic context环境下使用</span><br>  <span class="hljs-type">int</span> (*master_xfer_atomic)(<span class="hljs-keyword">struct</span> i2c_adapter *adap,<br>           <span class="hljs-keyword">struct</span> i2c_msg *msgs, <span class="hljs-type">int</span> num);<br>    <span class="hljs-comment">// 实现SMBus传输，如果不提供这个函数，SMBus传输会使用master_xfer来模拟</span><br>  <span class="hljs-type">int</span> (*smbus_xfer)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<br>        u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<br>  <span class="hljs-type">int</span> (*smbus_xfer_atomic)(<span class="hljs-keyword">struct</span> i2c_adapter *adap, u16 addr,<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags, <span class="hljs-type">char</span> read_write,<br>         u8 command, <span class="hljs-type">int</span> size, <span class="hljs-keyword">union</span> i2c_smbus_data *data);<br><br>  <span class="hljs-comment">/* To determine what the adapter supports */</span><br>  u32 (*functionality)(<span class="hljs-keyword">struct</span> i2c_adapter *adap);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span><br>    <span class="hljs-comment">// reg_slave就是把一个i2c_client注册到I2C Adapter，就是让这个I2C Adapter模拟该i2c_client</span><br>  <span class="hljs-type">int</span> (*reg_slave)(<span class="hljs-keyword">struct</span> i2c_client *client);<br>  <span class="hljs-type">int</span> (*unreg_slave)(<span class="hljs-keyword">struct</span> i2c_client *client);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>};<br></code></pre></td></tr></tbody></table></figure><p>I2C传输以<code>i2c_msg</code>为单位</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_msg</span> {</span><br>  __u16 addr;<span class="hljs-comment">/* slave address*/</span><br>  __u16 flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RD    0x0001<span class="hljs-comment">/* read data, from slave to master */</span></span><br>          <span class="hljs-comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_TEN    0x0010<span class="hljs-comment">/* this is a ten bit chip address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_DMA_SAFE    0x0200<span class="hljs-comment">/* the buffer of this message is DMA safe */</span></span><br>          <span class="hljs-comment">/* makes only sense in kernelspace */</span><br>          <span class="hljs-comment">/* userspace buffers are copied anyway */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_RECV_LEN    0x0400<span class="hljs-comment">/* length will be first received byte */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NO_RD_ACK    0x0800<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_IGNORE_NAK  0x1000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_NOSTART    0x4000<span class="hljs-comment">/* if I2C_FUNC_NOSTART */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_M_STOP    0x8000<span class="hljs-comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span><br>  __u16 len;<span class="hljs-comment">/* msg length*/</span><br>  __u8 *buf;<span class="hljs-comment">/* pointer to msg data*/</span><br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="I2C-consumer"><a href="#I2C-consumer" class="headerlink" title="I2C consumer"></a>I2C consumer</h1><p><a href="http://www.wowotech.net/comm/i2c_consumer.html">http://www.wowotech.net/comm/i2c_consumer.html</a></p><p><strong>形态1</strong>：CPU和设备之间的所有数据交互，都是通过I2C总线进行。</p><p><strong>形态2</strong>：I2C只是CPU和设备之间进行数据交互的一种，例如HDMI，图像以及音频数据通过TDMS接口传输，EDID等信息的交互通过I2C总线。</p><p><strong>形态1</strong>：直接在device tree中i2c设备节点下加一个子节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;i2c1 {<br>        clock-frequency = &lt;<span class="hljs-number">100000</span>&gt;;<br>        pinctrl-names = <span class="hljs-string">"default"</span>;<br>        pinctrl<span class="hljs-number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;<br>        status = <span class="hljs-string">"okay"</span>;<br>        …<br>        pmic: pf0100@<span class="hljs-number">08</span> {<br>                compatible = <span class="hljs-string">"fsl,pfuze100"</span>;<br>                …<br>        };<br></code></pre></td></tr></tbody></table></figure><p><strong>形态2</strong>：在自己的设备节点下引用i2c节点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp;hdmi {<br>       ddc-i2c-bus = &lt;&amp;i2c2&gt;;<br>        status = <span class="hljs-string">"okay"</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="驱动编写步骤"><a href="#驱动编写步骤" class="headerlink" title="驱动编写步骤"></a>驱动编写步骤</h2><p><strong>形态1</strong>：需要编写一个<code>i2c driver</code>。定义一个<code>struct i2c_driver</code>类型的变量，并调用<code>module_i2c_driver</code>接口将其注册到<code>I2C core</code>中。</p><p>以<code>struct i2c_client</code>指针为参数，可以调用<code>i2c_master_send/i2c_master_recv</code>接口进行简单的I2C传输，同时，也可以通过该指针获得所属的<code>I2C adapter</code>指针，然后通过<code>i2c_transfer</code>接口，进行更为复杂的read、write操作。</p><p><strong>形态2</strong>：通过设备树API接口获得<code>struct i2c_adapter</code>指针，通过<code>i2c_transfer</code>接口，进行read、write操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">adap = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">"ddc-i2c-bus"</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (adap) {<br>        panel-&gt;adap = of_find_i2c_adapter_by_node(adap); <span class="hljs-comment">//获取i2c adapter指针</span><br>        of_node_put(adap);<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>i2c client</code>抽象i2c设备</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> {</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> flags;<span class="hljs-comment">/* flags，指示该I2C slave device一些特性 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_PEC    0x04<span class="hljs-comment">/* Use Packet Error Checking */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_TEN    0x10<span class="hljs-comment">/* we have a ten bit chip address */</span></span><br>          <span class="hljs-comment">/* Must equal I2C_M_TEN below */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_SLAVE  0x20<span class="hljs-comment">/* we are the slave */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_HOST_NOTIFY  0x40<span class="hljs-comment">/* We want to use I2C host notify */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_WAKE    0x80<span class="hljs-comment">/* for board_info; true iff can wake */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CLIENT_SCCB    0x9000<span class="hljs-comment">/* Use Omnivision SCCB protocol */</span></span><br>          <span class="hljs-comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> addr;<span class="hljs-comment">/* 该设备的7-bit的slave地址。*/</span><br>          <span class="hljs-comment">/* addresses are stored in the*/</span><br>          <span class="hljs-comment">/* _LOWER_ 7 bits*/</span><br>  <span class="hljs-type">char</span> name[I2C_NAME_SIZE];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">adapter</span>;</span><span class="hljs-comment">/* 该设备所在的I2C controller*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* the device structure*/</span><br>  <span class="hljs-type">int</span> init_irq;<span class="hljs-comment">/* irq set at initialization*/</span><br>  <span class="hljs-type">int</span> irq;<span class="hljs-comment">/* irq issued by device*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">detected</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span><br>  <span class="hljs-type">i2c_slave_cb_t</span> slave_cb;<span class="hljs-comment">/* callback for slave mode*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>};<br></code></pre></td></tr></tbody></table></figure><p>通常情况下，<code>struct i2c_client</code>变量是由I2C core在register adapter的时候，解析adapter的child node自行创建的。该数据结构中的有些信息，可通过DTS配置。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">xxx:xxx@<span class="hljs-number">08</span> {<br>        reg = &lt;<span class="hljs-number">0x08</span>&gt;;                               <span class="hljs-comment">/* 对应struct i2c_client中的‘addr’*/</span><br>        interrupts = &lt;<span class="hljs-number">16</span> <span class="hljs-number">8</span>&gt;;                       <span class="hljs-comment">/* 对应struct i2c_client中的‘irq’*/</span><br>        wakeup-source;                             <span class="hljs-comment">/* 对应flags中的I2C_CLIENT_WAKE */</span><br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="Synopsys-DesignWare-I2C-driver"><a href="#Synopsys-DesignWare-I2C-driver" class="headerlink" title="Synopsys DesignWare I2C driver"></a>Synopsys DesignWare I2C driver</h1><p>i2c 传输的频率可以通过设备树<code>"clock-frequency"</code>来设置<code>t-&gt;bus_freq_hz</code>。不设置则为默认的400kHz</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">dw_i2c_plat_probe()<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dw_i2c_dev</span> *<span class="hljs-title">dev</span>;</span><br>    dw_i2c_plat_request_regs(dev);<br>    dev-&gt;base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br>  i2c_parse_fw_timings(&amp;pdev-&gt;dev, t, <span class="hljs-literal">false</span>);<br>  i2c_dw_configure();<br>          i2c_dw_configure_slave();<br>          i2c_dw_configure_master(); <span class="hljs-comment">// 设置一些dev-&gt;func dev-&gt;master_cfg等属性后续使用</span><br>     i2c_dw_probe()<br>          i2c_dw_probe_slave();<br>     i2c_dw_probe_master();<br><br>i2c_dw_probe_master(<span class="hljs-keyword">struct</span> dw_i2c_dev *dev)<br>    dev-&gt;init = i2c_dw_init_master;<br>  dev-&gt;disable = i2c_dw_disable;<br>  dev-&gt;disable_int = i2c_dw_disable_int;<br>  i2c_dw_init_regmap();<br>    i2c_dw_set_timings_master(); <span class="hljs-comment">//设置standard/fast h/lcnt</span><br>    i2c_dw_set_sda_hold(); <span class="hljs-comment">// 设置sda_hold,不过rts直接在dev-&gt;init中设置为20</span><br>    i2c_dw_set_fifo_size(); <span class="hljs-comment">//设置tx/rx_fifo_depth</span><br>  dev-&gt;init(); <span class="hljs-comment">// 写之前设置好配置的寄存器</span><br>    __i2c_dw_disable(); <span class="hljs-comment">// disable adapter</span><br>      __i2c_dw_disable_nowait();<br>    i2c_dw_configure_fifo_master();<span class="hljs-comment">//写tx/rx_fifo寄存器,根据dev-&gt;master_cfg写con寄存器</span><br>  i2c_dw_disable_int(); <span class="hljs-comment">// 先把中断mask全部置1，禁止中断</span><br>  devm_request_irq();<br>  i2c_dw_init_recovery_info();<br>  i2c_add_numbered_adapter();<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buildroot</title>
    <link href="/2023/04/13/Note/23-04-13_Buildroot/"/>
    <url>/2023/04/13/Note/23-04-13_Buildroot/</url>
    
    <content type="html"><![CDATA[<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p><code>./lanuch</code> 最终的操作是</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd sdk_3921/buildroot-dist # 进入buildroot目录<br>make BR2_EXTERNAL=sdk_3921/platform/ O=sdk3921/out/rts3923_fpga/ rts3923_fpga_defconfig<br></code></pre></td></tr></tbody></table></figure><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">local.mk <span class="hljs-comment"># BR2_PACKAGE_OVERRIDE_FILE 在platform/configs中定义</span><br>external.mk<br>    <span class="hljs-keyword">include</span> common.mk<br>      <span class="hljs-keyword">include</span> package/*/*/*.mk<br>      <span class="hljs-keyword">include</span> package/*/*.mk<br>    <span class="hljs-keyword">include</span> package/*/*/src.mki<br>    <span class="hljs-keyword">include</span> package/*/*/gen.mki<br>    <span class="hljs-keyword">include</span> post_pkg.mk<br></code></pre></td></tr></tbody></table></figure><p><code>platform/local.mk</code>: 指定自定义源码位置</p><p>在<code>local.mk</code>中还定义了：</p><p><code>make rr</code>: Reconstruct rootfs</p><p><code>make rp</code>: Rebuild external packages</p><h2 id="Managing-the-build-and-the-configuration"><a href="#Managing-the-build-and-the-configuration" class="headerlink" title="Managing the build and the configuration"></a>Managing the build and the configuration</h2><h3 id="Out-of-tree-build"><a href="#Out-of-tree-build" class="headerlink" title="Out of tree build"></a>Out of tree build</h3><p>在<code>buildroot Makefile</code>中有</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(O)</span>,<span class="hljs-variable">$(CURDIR)</span>/output)<br>CONFIG_DIR := <span class="hljs-variable">$(CURDIR)</span><br>NEED_WRAPPER =<br><span class="hljs-keyword">else</span><br>CONFIG_DIR := <span class="hljs-variable">$(O)</span><br>NEED_WRAPPER = y<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></tbody></table></figure><p>可以看出，如果<code>O != buildroot_dist/output</code>, <code>CONFIG_DIR = sdk3921/out/rts3923_fpga/ </code></p><p>在<code>CONFIG_DIR</code>目录下，保存着<code>.config</code>配置文件。</p><h3 id="Other-building-tips"><a href="#Other-building-tips" class="headerlink" title="Other building tips"></a>Other building tips</h3><p>Cleaning all the build output, but keeping the configuration file(删除build/):</p><p><code>make clean</code></p><p>Cleaning everything, including the configuration file, and downloaded file if at the<br>default location (相当于删除了build/和.config一系列配置文件，需要重新make menuconfig):</p><p><code>make distclean</code></p><h2 id="Buildroot-source-and-build-trees"><a href="#Buildroot-source-and-build-trees" class="headerlink" title="Buildroot source and build trees"></a>Buildroot source and build trees</h2><h3 id="Build-tree"><a href="#Build-tree" class="headerlink" title="Build tree"></a>Build tree</h3><ul><li><code>output/</code>对应<code>BASE_DIR</code></li><li><code>output/build/</code>对应<code>BUILD_DIR</code></li><li><code>output/host/</code>对应<code>HOST_DIR</code><ul><li>Contains both the tools built for the host (cross-compiler, etc.) and the sysroot of<br>the toolchain</li><li>Host tools are directly in <code>host/</code></li><li>The sysroot is in <code>host/&lt;tuple&gt;/sysroot/usr</code>E.g: <code>arm-unknown-linux-gnueabihf</code></li><li>Variable for the sysroot: <code>STAGING_DIR</code>. <code>ouput</code>目录下的<code>staging</code>目录也是软连接到这的</li></ul></li><li><code>output/target/</code>对应<code>TARGET_DIR</code><ul><li>Used to generate the final root filesystem images in<code> images/</code></li></ul></li><li><code>output/image/</code>对应<code>BINARIES_DIR</code></li></ul><h2 id="Managing-the-Linux-kernel-configuration"><a href="#Managing-the-Linux-kernel-configuration" class="headerlink" title="Managing the Linux kernel configuration"></a>Managing the Linux kernel configuration</h2><ul><li><code>make linux-update-config</code>, to save a full config file</li><li><code>make linux-update-defconfig</code>, to save a minimal defconfig</li></ul><h2 id="Root-filesystem-in-Buildroot"><a href="#Root-filesystem-in-Buildroot" class="headerlink" title="Root filesystem in Buildroot"></a>Root filesystem in Buildroot</h2><p>copy rootfs overlays-&gt;execute post-build scripts-&gt;execute post-image scripts</p><p><code>platform/board/rts3923/rootfs_overlay</code></p><p><code>platform/board/rts3923/post_build.sh</code></p><p><code>platform/board/rts3923/post_image.sh</code></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230412162924.png"></p><h2 id="Advanced-topics"><a href="#Advanced-topics" class="headerlink" title="Advanced topics"></a>Advanced topics</h2><h3 id="BR2-EXTERNAL"><a href="#BR2-EXTERNAL" class="headerlink" title="BR2_EXTERNAL"></a>BR2_EXTERNAL</h3><p>Ipcam sdk在make的时候指定</p><p><code>make BR2_EXTERNAL=sdk_3921/platform/ O=sdk3921/out/rts3923_fpga/ rts3923_fpga_defconfig</code></p><p>Each external directory must contain:</p><ul><li><code>external.desc</code>, which provides a name and description. The <code>$BR2_EXTERNAL_&lt;NAME&gt;_PATH</code> variable is available, where NAME is defined in <code>external.desc</code>.</li><li><code>Config.in</code>, configuration options that will be included in menuconfig（在menuconfig external options里）</li><li><code>external.mk</code>, will be included in the make logic</li></ul><p><code>make &lt;pkg&gt;-dirclean</code>, completely remove the package source code directory. The next make invocation will fully rebuild this package. 相当于直接删除<code>build/&lt;pkg&gt;</code></p><p><code>make &lt;pkg&gt;-rebuild</code>, force to re-execute the build and installation steps of the package.</p><p><code>make &lt;pkg&gt;-reconfigure</code>, force to re-execute the configure, build and installation steps of the package.</p><h1 id="legacy"><a href="#legacy" class="headerlink" title="legacy"></a>legacy</h1><h2 id="添加自己的软件包"><a href="#添加自己的软件包" class="headerlink" title="添加自己的软件包"></a>添加自己的软件包</h2><h3 id="添加package-x2F-Config-in入口"><a href="#添加package-x2F-Config-in入口" class="headerlink" title="添加package/Config.in入口"></a>添加package/Config.in入口</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kufds">config BR2_PACKAGE_HELLOWORLD<br>bool "helloworld"<br>help<br>  This is a demo to add myown(fuzidage) package.<br></code></pre></td></tr></tbody></table></figure><h3 id="配置APP对应的Config-in和mk文件"><a href="#配置APP对应的Config-in和mk文件" class="headerlink" title="配置APP对应的Config.in和mk文件"></a>配置APP对应的Config.in和mk文件</h3><p>在package中新增目录helloworld，并在里面添加Config.in和helloworld.mk<br><strong>Config.in</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fdsf">config BR2_PACKAGE_HELLOWORLD<br>bool "helloworld"<br>help<br>  This is a demo to add myown(fuzidage) package.<br></code></pre></td></tr></tbody></table></figure><p><strong>helloworld.mk</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dfsdf">HELLOWORLD_VERSION:= 1.0.0<br>HELLOWORLD_SITE:= $(BR2_EXTERNAL)/source/ipcam/helloworld<br>HELLOWORLD_SITE_METHOD:=local<br>HELLOWORLD_INSTALL_TARGET:=YES<br><br>$(eval $(cmake-package))<br><br></code></pre></td></tr></tbody></table></figure><h2 id="如何重新编译软件包"><a href="#如何重新编译软件包" class="headerlink" title="如何重新编译软件包"></a>如何重新编译软件包</h2><p>经过第一次完整编译后，如果我们需要对源码包重新配置，我们不能直接在buildroot上的根目录下直接make，buildroot是不知道你已经对源码进行重新配置，它只会将第一次编译出来的文件，再次打包成根文件系统镜像文件。</p><p>那么可以通过以下2种方式重新编译：</p><p><strong>1. 直接删除源码包,然后make all</strong></p><p>例如我们要重新编译helloworld，那么可以直接删除output/build/helloworld目录，那么当你make的时候，就会自动从dl文件夹下，解压缩源码包，并重新安装。这种效率偏低</p><p><strong>2. 进行xxx-rebuild,然后make all</strong></p><p>也是以helloworld为例子，我们直接输入make helloworld-rebuild，即可对build/helloworld/目录进行重新编译，然后还要进行make all(或者make helloworld)</p><h2 id="Config-in-语法"><a href="#Config-in-语法" class="headerlink" title="Config.in 语法"></a>Config.in 语法</h2><p>用Kconfig语言编写，用来配置packages</p><p>必须以<code>BR2_PACKAGE_&lt;PACKAGE&gt;</code>开头</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxwbwcmsauj30i303zt8t.jpg"></p><p>Config.in 是层级结构<code>package/&lt;pkg&gt;/Config.in</code>都被包含在<code>package/Config.in</code></p><h3 id="menu-x2F-endmenu"><a href="#menu-x2F-endmenu" class="headerlink" title="menu/endmenu"></a>menu/endmenu</h3><p>menuconfig中层级目录由<code>menu</code>来嵌套定义</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kbuild">menu "Base System"<br>source "$BR2_EXTERNAL_platform_PATH/package/example/Config.in"<br>source "$BR2_EXTERNAL_platform_PATH/package/fstools/Config.in"<br>endmenu<br><br>menu "Test Package"<br>source "$BR2_EXTERNAL_platform_PATH/package/foobar/Config.in"<br>endmenu<br><br>// Test Package在Base System下一级目录<br>menu "Base System"<br>menu "Test Package"<br>endmenu<br>endmenu<br></code></pre></td></tr></tbody></table></figure><h3 id="if-x2F-endif"><a href="#if-x2F-endif" class="headerlink" title="if/endif"></a>if/endif</h3><h3 id="choice-x2F-endchoice"><a href="#choice-x2F-endchoice" class="headerlink" title="choice/endchoice"></a>choice/endchoice</h3><h3 id="select、depends-on"><a href="#select、depends-on" class="headerlink" title="select、depends on"></a>select、depends on</h3><p>select是一种自动依赖，如果A select B，只要A被enable，B就会被enable，而且不可unselected</p><p>depends on是一种用户定义的依赖，如果A depends on B, A只有在B被enable后才可见</p><ul><li><code>make \&lt;pkg\&gt;-show-depend</code>: 查看pkg依赖的包</li><li><code>make \&lt;pkg\&gt;-show-rdepend</code>: 查看依赖pkg的包</li></ul><h2 id="mk文件"><a href="#mk文件" class="headerlink" title=".mk文件"></a>.mk文件</h2><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">xxx_SITE_METHOD</span> = local<br><span class="hljs-attr">xxx_SITE</span> = 本地源码库地址<br><br><span class="hljs-attr">xxx_SITE_METHOD</span> = remote<br><span class="hljs-attr">xxx_SITE</span> = 远程URL<br></code></pre></td></tr></tbody></table></figure><p>Packages可以被安装到不同目录：</p><ul><li>target目录：<code>$(TARGET_DIR)</code></li><li>staging目录：<code>$(STAGING_DIR)</code></li><li>images目录：<code>$(BINARIES_DIR)</code></li></ul><p>分别由三个变量决定：</p><ul><li><code>&lt;pkg&gt;_INSTALL_TARGET</code> , defaults to <code>YES</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_TARGET_CMDS</code> will be called </li><li><code>&lt;pkg&gt;_INSTALL_STAGING</code> , defaults to <code>NO</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_STAGING_CMDS</code> will be called </li><li><code>&lt;pkg&gt;_INSTALL_IMAGES</code> , defaults to <code>NO</code>. If <code>YES</code>, then <code>&lt;pkg&gt;_INSTALL_IMAGES_CMDS</code> will be called <br><br></li><li>Application Package一般只要安装到target</li><li>Shared library动态库必须安装到target与staging</li><li>header-based library和static-only library静态库只安装到staging</li><li>bootloader和linux要安装到images</li></ul><p>Config.in文件不规定编译顺序，.mk文件中的&lt;pkg&gt;_DEPENDENCIES可以规定编译顺序，&lt;pkg&gt;_DEPENDENCIES后面的软件包先编译。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/fuzidage/p/12049442.html">https://www.cnblogs.com/fuzidage/p/12049442.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Buildroot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWM Subsystem</title>
    <link href="/2023/03/21/Note/Linux_Driver/PWM/"/>
    <url>/2023/03/21/Note/Linux_Driver/PWM/</url>
    
    <content type="html"><![CDATA[<h1 id="PWM-子系统"><a href="#PWM-子系统" class="headerlink" title="PWM 子系统"></a>PWM 子系统</h1><h1 id="PWM原理"><a href="#PWM原理" class="headerlink" title="PWM原理"></a>PWM原理</h1><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/Untitled.png"></p><p>利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，其本质是一种对模拟信号电平进行数字编码的方法。在嵌入式设备中，PWM多用于控制马达、LED、振动器等模拟器件。</p><ul><li>脉冲周期（T），单位是时间，ns, us ,ms。</li><li>脉冲频率（f），单位是赫兹（Hz），与脉冲周期成倒数关系，f=1/T。</li><li>脉冲宽度（W），简称“脉宽”，是脉冲高电平持续的时间。单位是时间，ns, us, ms。</li><li>占空比（D），脉宽除以脉冲周期的值。</li></ul><p>W = ton</p><p>T = ton + toff = 1/f</p><p>D = ton / (ton+ toff) = ton / T</p><h1 id="PWM-consumer"><a href="#PWM-consumer" class="headerlink" title="PWM consumer"></a>PWM consumer</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/linux/pwm.h */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_config</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm, <span class="hljs-type">int</span> duty_ns, <span class="hljs-type">int</span> period_ns)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pwm_apply_state</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pwm_state *state)</span>;<br></code></pre></td></tr></tbody></table></figure><p><code>pwm_config</code>，用于控制PWM输出信号的频率和占空比，其中频率是以周期（<code>period_ns</code>）的形式配置的，占空比是以有效时间（<code>duty_ns</code>）的形式配置的。</p><p><code>pwm_enable/pwm_disable</code>，用于控制PWM信号输出与否。</p><p> <code>pwm_apply_state</code>需要定义一个<code>pwm_state</code>，可以一下子修改<code>period/duty_cycle/polarity/enabled</code>。</p><p>上面的API都以<code>struct pwm_device</code>类型的指针为操作句柄，该指针抽象了一个PWM设备，那么怎么获得PWM句柄呢？使用如下的API：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* include/linux/pwm.h */</span><br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">of_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pwm_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">devm_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-keyword">struct</span> pwm_device *<span class="hljs-title function_">devm_of_pwm_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> device_node *np, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *con_id)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">devm_pwm_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-keyword">struct</span> pwm_device *pwm)</span>;<br></code></pre></td></tr></tbody></table></figure><p><code>pwm_get/devm_pwm_get</code>，从指定设备（dev）的DTS节点中，获得对应的PWM句柄。可以通过con_id指定一个名称，或者会获取和该设备绑定的第一个PWM句柄。设备的DTS文件需要用这样的格式指定所使用的PWM device：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bl: backlight {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>pwms = &lt;&amp;pwm <span class="hljs-number">0</span> <span class="hljs-number">5000000</span> PWM_POLARITY_INVERTED&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>pwm-names = <span class="hljs-string">"backlight"</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果“con_id”为NULL，则返回DTS中“pwms”字段所指定的第一个PWM device；如果“con_id”不为空，如是“backlight”，则返回和“pwm-names ”字段所指定的name对应的PWM device。</p><p>上面“pwms”字段各个域的含义如下：<br>1）<code>&amp;pwm</code>，对DTS中pwm节点的引用；<br>2）<code>0</code>，pwm device的设备号，具体需要参考SOC以及pwm driver的实际情况；<br>3）<code>5000000</code>，PWM信号默认的周期，单位是纳秒（ns）；<br>4）<code>PWM_POLARITY_INVERTED</code>，可选字段，是否提供由pwm driver决定，表示pwm信号的极性，若为0，则正常极性，若为<code>PWM_POLARITY_INVERTED</code>，则反转极性。</p><p><code>of_pwm_get/devm_of_pwm_get</code>，和<code>pwm_get/devm_pwm_get</code>类似，区别是可以指定需要从中解析PWM信息的<code>device node</code>，而不是直接指定device指针。</p><h1 id="PWM-provider"><a href="#PWM-provider" class="headerlink" title="PWM provider"></a>PWM provider</h1><h3 id="2-1-pwm-chip"><a href="#2-1-pwm-chip" class="headerlink" title="2.1 pwm_chip"></a>2.1 pwm_chip</h3><p>抽象PWM控制器</p><p>在一个SOC中，可以同时支持多路PWM输出，以便同时控制多个PWM设备。这样每一路PWM输出，可以看做一个PWM设备（struct pwm_device）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct pwm_chip - abstract a PWM controller</span><br><span class="hljs-comment"> * @dev: device providing the PWMs</span><br><span class="hljs-comment"> * @ops: callbacks for this PWM controller</span><br><span class="hljs-comment"> * @base: number of first PWM controlled by this chip</span><br><span class="hljs-comment"> * @npwm: number of PWMs controlled by this chip</span><br><span class="hljs-comment"> * @of_xlate: request a PWM device given a device tree PWM specifier</span><br><span class="hljs-comment"> * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier</span><br><span class="hljs-comment"> * @list: list node for internal use</span><br><span class="hljs-comment"> * @pwms: array of PWM devices allocated by the framework</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> {</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_ops</span> *<span class="hljs-title">ops</span>;</span><br>  <span class="hljs-type">int</span> base; <span class="hljs-comment">// 动态指定pwm起始软件编号。旧的pwm_request会使用。在底层driver指定，传入-1即可。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npwm;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> * (*<span class="hljs-title">of_xlate</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> *<span class="hljs-title">pc</span>,</span><br><span class="hljs-class">          <span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">of_phandle_args</span> *<span class="hljs-title">args</span>);</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> of_pwm_n_cells;<br><br>  <span class="hljs-comment">/* only used internally by the PWM framework */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> *<span class="hljs-title">pwms</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure><p><code>dev</code>，该pwm chip对应的设备，一般由pwm driver对应的platform驱动指定。必须提供！</p><p><code>ops</code>，操作PWM设备的回调函数，后面会详细介绍。必须提供！</p><p><code>npwm</code>，该pwm chip可以支持的pwm channel（也可以称作pwm device由struct pwm_device表示）个数，kernel会根据该number，分配相应个数的struct pwm_device结构，保存在pwms指针中。必须提供！</p><p><code>pwms</code>，保存所有pwm device的数组，kernel会自行分配，不需要driver关心。</p><p><code>base</code>，在将该chip下所有pwm device组成radix tree时使用，只有旧的pwm_request接口会使用，因此忽略它吧，编写pwm driver不需要关心。</p><p><code>of_pwm_n_cells</code>，该PWM chip所提供的DTS node的cell，一般是2或者3，例如：为3时，consumer需要在DTS指定pwm number、pwm period和pwm flag三种信息（如2.1中的介绍）；为2时，没有flag信息。</p><p><code>of_xlate</code>，用于解析consumer中指定的、pwm信息的DTS node的回调函数（如2.1中介绍的，pwms = &lt;&amp;pwm 0 5000000 PWM_POLARITY_INVERTED&gt;）。</p><p>注2：一般情况下，of_pwm_n_cells取值为3，或者2（不关心极性），of_xlate则可以使用kernel提供的of_pwm_xlate_with_flags（解析of_pwm_n_cells为3的chip）或者of_pwm_simple_xlate（解析of_pwm_n_cells为2的情况）。</p><h3 id="2-2-pwm-ops"><a href="#2-2-pwm-ops" class="headerlink" title="2.2 pwm_ops"></a>2.2 pwm_ops</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_ops</span> {</span><br>  <span class="hljs-type">int</span> (*request)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">int</span> (*capture)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>           <span class="hljs-keyword">struct</span> pwm_capture *result, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout);<br>  <span class="hljs-type">int</span> (*apply)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>         <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pwm_state *state);<br>  <span class="hljs-type">void</span> (*get_state)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>        <span class="hljs-keyword">struct</span> pwm_state *state);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><br>  <span class="hljs-comment">/* Only used by legacy drivers 目前rts使用的是legacy接口 */</span><br>  <span class="hljs-type">int</span> (*config)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>          <span class="hljs-type">int</span> duty_ns, <span class="hljs-type">int</span> period_ns);<br>  <span class="hljs-type">int</span> (*set_polarity)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm,<br>          <span class="hljs-keyword">enum</span> pwm_polarity polarity);<br>  <span class="hljs-type">int</span> (*enable)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>  <span class="hljs-type">void</span> (*disable)(<span class="hljs-keyword">struct</span> pwm_chip *chip, <span class="hljs-keyword">struct</span> pwm_device *pwm);<br>};<br></code></pre></td></tr></tbody></table></figure><p>这些回调函数的操作对象是具体的<code>pwm device</code>，包括：</p><p><code>config</code>，配置<code>pwm device</code>的频率、占空比。必须提供！</p><p><code>enable/disable</code>，使能/禁止pwm信号输出。必须提供！</p><p><code>request/free</code>，不再使用。</p><p><code>set_polarity</code>，设置pwm信号的极性。可选，具体需要参考<code>of_pwm_n_cells</code>的定义。</p><h3 id="2-3-pwm-device"><a href="#2-3-pwm-device" class="headerlink" title="2.3 pwm device"></a>2.3 pwm device</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_device</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hwpwm; <span class="hljs-comment">// pwm device对应的hardware pwm number，可用于寄存器的寻址操作</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pwm; <span class="hljs-comment">// chip-&gt;base + hwpwm</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_chip</span> *<span class="hljs-title">chip</span>;</span><br>  <span class="hljs-type">void</span> *chip_data;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_args</span> <span class="hljs-title">args</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pwm_state</span> <span class="hljs-title">state</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="2-4-pwmchip-add-x2F-pwmchip-remove"><a href="#2-4-pwmchip-add-x2F-pwmchip-remove" class="headerlink" title="2.4 pwmchip_add/pwmchip_remove"></a>2.4 <strong>pwmchip_add/pwmchip_remove</strong></h3><p>初始化完成后的pwm chip可以通过pwmchip_add接口注册到kernel中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>: <span class="hljs-type">int</span> <span class="hljs-title function_">pwmchip_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_chip *chip)</span>;<br><span class="hljs-number">2</span>: <span class="hljs-type">int</span> <span class="hljs-title function_">pwmchip_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pwm_chip *chip)</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="API使用指南"><a href="#API使用指南" class="headerlink" title="API使用指南"></a>API使用指南</h1><h3 id="3-2-provider编写PWM-driver的步骤"><a href="#3-2-provider编写PWM-driver的步骤" class="headerlink" title="3.2 provider编写PWM driver的步骤"></a>3.2 provider编写PWM driver的步骤</h3><p>1）创建代表该pwm driver的DTS节点，并提供platform device有关的资源信息，例如：</p><p>2）定义一个<code>pwm chip</code>变量。</p><p>3）注册相应的platform driver，并在driver的.probe()接口中，初始化pwm chip变量，至少要包括如下字段：</p><p><code>dev</code>，使用platform device中的dev指针即可；<code>npwm；ops</code>，至少包括<code>config、enable、disable</code>三个回调函数。</p><p><strong>如果该pwm chip支持额外的flag（如PWM极性，或者自定义的flag），将PWM cell指定为3（of_pwm_n_cells），of_xlate指定为of_pwm_xlate_with_flags。</strong></p><p>4）每当consumer有API调用时，kernel会以pwm device为参数，调用pwm driver提供的pwm ops，相应的回调函数可以从pwm device中取出pwm number（该number的意义driver自行解释），并操作对应的寄存器即可。</p><h3 id="3-3-consumer使用PWM的步骤"><a href="#3-3-consumer使用PWM的步骤" class="headerlink" title="3.3 consumer使用PWM的步骤"></a>3.3 <strong>consumer使用PWM的步骤</strong></h3><p>1）查看pwm provider所提供的pwm dts binding信息（一般会在“Documentation/devicetree/bindings/pwm”目录中），并以此在该device所在的dts node中添加“pwms ”以及“pwm-names ”相关的配置。例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch\arm\boot\dts\imx23-evk.dts */</span><br><br>backlight {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>compatible = <span class="hljs-string">"pwm-backlight"</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>pwms = &lt;&amp;pwm <span class="hljs-number">2</span> <span class="hljs-number">5000000</span>&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>brightness-levels = &lt;<span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span> <span class="hljs-number">128</span> <span class="hljs-number">255</span>&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span class="hljs-keyword">default</span>-brightness-level = &lt;<span class="hljs-number">6</span>&gt;;<br>};<br></code></pre></td></tr></tbody></table></figure><p>2）在driver的probe接口中，调用<strong>devm_pwm_get</strong>接口，获取<strong>pwm device</strong>句柄，并保存起来。</p><p>3）devm_pwm_get成功后，该pwm信号已经具备初始的周期和极性。后续根据需要，可以调用<strong>pwm_config</strong>更改该pwm信号的周期、占空比。</p><p>4）driver可以根据需要，调用<strong>pwm_enable/pwm_disable</strong>接口，打开或者关闭pwm信号的输出。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>原理介绍：<a href="https://zhuanlan.zhihu.com/p/374083276">https://zhuanlan.zhihu.com/p/374083276</a></p><p>Driver解析：<a href="http://www.wowotech.net/comm/pwm_overview.html">http://www.wowotech.net/comm/pwm_overview.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux driver</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS2022 PA2</title>
    <link href="/2023/01/31/Project/ICS/PA2/"/>
    <url>/2023/01/31/Project/ICS/PA2/</url>
    
    <content type="html"><![CDATA[<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><p>mul-longlong.c中check <code>0xaeb1c2aa * 0xaeb1c2aa = 0x19d29ab9db1a18e4LL</code></p><p>实现mulh指令遇到的一个问题：</p><p>由于<code>src1</code>和<code>src2</code>都是<code>unsigned int</code>，强制类型转换为<code>long</code>（零扩展），得到的是无符号相乘结果<code>0x7736200d</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// 直接u32*u32会溢出，乘出来还是u32</span><br>u32 src1 = <span class="hljs-number">0xaeb1c2aa</span>;<br>u32 src2 = <span class="hljs-number">0xaeb1c2aa</span><br>INSTPAT(<span class="hljs-string">"..."</span>, mulh, R, R(dest) = (((<span class="hljs-type">long</span>)src1 * (<span class="hljs-type">long</span>)src2) &gt;&gt; <span class="hljs-number">32</span>));<br></code></pre></td></tr></tbody></table></figure><p>先修改为<code>int</code>型，再改为<code>long</code>型（符号扩展）则可以顺利得到<code>0x19d29ab9</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">INSTPAT(<span class="hljs-string">"..."</span>, mulh, R, R(dest) = (((<span class="hljs-type">long</span>)(<span class="hljs-type">int</span>)src1 * (<span class="hljs-type">long</span>)(<span class="hljs-type">int</span>)src2) &gt;&gt; <span class="hljs-number">32</span>));<br><br></code></pre></td></tr></tbody></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230201173605.png" alt="无符号整型转换表"></div><div class="group-image-wrap"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230201173534.png" alt="带符号整型转换表"></div></div></div><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><h3 id="通过批处理模式运行NEMU"><a href="#通过批处理模式运行NEMU" class="headerlink" title="通过批处理模式运行NEMU"></a>通过批处理模式运行NEMU</h3><p><code>abstract-machine/scripts/platform/nemu.mk</code>中<code>NEMUFLAGS</code>加上<code>-b</code>，选择批处理模式，不用每次进入nemu都输入<code>c</code>。</p><h2 id="Diff-test"><a href="#Diff-test" class="headerlink" title="Diff test"></a>Diff test</h2><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li>端口映射IO</li><li>内存映射IO</li></ul><p><code>nemu/src/device/</code>提供了设备相关的代码。</p><p><code>nemu/include/device/map.h</code>中定义了<code>IOMap</code>结构体来抽象内存映射. 包括名字, 映射的起始地址和结束地址, 映射的目标空间, 以及一个回调函数.<br><code>nemu/src/device/io/map.c</code>实现了映射的管理, 包括I/O空间的分配及其映射, 还有映射的访问接口.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>  <span class="hljs-comment">// we treat ioaddr_t as paddr_t here</span><br>  <span class="hljs-type">paddr_t</span> low;<br>  <span class="hljs-type">paddr_t</span> high;<br>  <span class="hljs-type">void</span> *space;<br>  <span class="hljs-type">io_callback_t</span> callback;<br>} IOMap;<br></code></pre></td></tr></tbody></table></figure><h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p><code>[*] Devices  ---&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Missing Semester of Computer Science</title>
    <link href="/2023/01/30/Note/23-01-30_Missing-semester/"/>
    <url>/2023/01/30/Note/23-01-30_Missing-semester/</url>
    
    <content type="html"><![CDATA[<h2 id="Ch1-shell-scripts"><a href="#Ch1-shell-scripts" class="headerlink" title="Ch1 shell_scripts"></a>Ch1 shell_scripts</h2><p><code>foo=bar</code> 变量定义<code>=</code>左右不能加空格。</p><p>用<code>'</code>分隔的字符串是字面值字符串，不会替换变量值，而用<code>"</code>分隔的字符串会。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo=bar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$foo</span>"</span><br><span class="hljs-comment"># prints bar</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'$foo'</span><br><span class="hljs-comment"># prints $foo</span><br></code></pre></td></tr></tbody></table></figure><p><code>$0</code>- Name of the script<br><code>$1</code>- to $9 - Arguments to the script. $1 is the first argument and so on.<br><code>$@</code>- All the arguments<br><code>$#</code>- Number of arguments<br><code>$?</code>- Return code of the previous command<br><code>$$</code>- Process identification number (PID) for the current script<br><code>!!</code>- Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code><br><code>$_</code>- Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by <code>.</code> or <code>Alt+.</code></p><p>The <code>true</code> program will always have a 0 return code and the <code>false</code> command will always have a 1 return code.</p><p><code>Command1 &amp;&amp; Command2</code> 如果Command1命令运行成功，则继续运行Command2命令。<br><code>Command1 || Command2</code> 如果Command1命令运行失败，则继续运行Command2命令。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"Oops, fail"</span><br><span class="hljs-comment"># Oops, fail</span><br><br><span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"Will not be printed"</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"Things went well"</span><br><span class="hljs-comment"># Things went well</span><br><br><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">"Will not be printed"</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">"This will always run"</span><br><span class="hljs-comment"># This will always run</span><br><br><span class="hljs-literal">false</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">"This will always run"</span><br><span class="hljs-comment"># This will always run</span><br></code></pre></td></tr></tbody></table></figure><h3 id="command-substitution"><a href="#command-substitution" class="headerlink" title="command substitution"></a>command substitution</h3><p><code>$(CMD)</code> will execute CMD, get the output of the command and substitute it in place.<br><code>for file in $(ls)</code> will first call ls and then iterate over those values.</p><h3 id="process-substitution"><a href="#process-substitution" class="headerlink" title="process substitution"></a>process substitution</h3><p><code>&lt;(CMD)</code> will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name.<br><code>diff &lt;(ls foo) &lt;(ls bar)</code> will show differences between files in dirs foo and bar.</p><p>Example:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Starting program at <span class="hljs-subst">$(date)</span>"</span> <span class="hljs-comment"># Date will be substituted</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$"</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>; <span class="hljs-keyword">do</span><br>    grep foobar <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> &gt; /dev/null 2&gt; /dev/null <span class="hljs-comment"># 标准输出和标准错误都重定向到/dev/null</span><br>    <span class="hljs-comment"># When pattern is not found, grep has exit status 1</span><br>    <span class="hljs-comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"File <span class="hljs-variable">$file</span> does not have any foobar, adding one"</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"# foobar"</span> &gt;&gt; <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></tbody></table></figure><div class="note note-info">            <p>try to use double brackets [[ ]] in favor of simple brackets [ ]</p>          </div><h3 id="shell-globbing"><a href="#shell-globbing" class="headerlink" title="shell globbing"></a>shell globbing</h3><ul><li>Wildcards<ul><li><code>?</code>替换单个字符</li><li><code>*</code>替换后面所有字符</li></ul></li><li>Curly braces <code>{}</code></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">convert image.{png,jpg}<br><span class="hljs-comment"># Will expand to</span><br>convert image.png image.jpg<br><br><span class="hljs-built_in">cp</span> /path/to/project/{foo,bar,baz}.sh /newpath<br><span class="hljs-comment"># Will expand to</span><br><span class="hljs-built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<br><br><span class="hljs-comment"># Globbing techniques can also be combined</span><br><span class="hljs-built_in">mv</span> *{.py,.sh} folder<br><span class="hljs-comment"># Will move all *.py and *.sh files</span><br></code></pre></td></tr></tbody></table></figure><h2 id="Ch4-commandline-environment"><a href="#Ch4-commandline-environment" class="headerlink" title="Ch4 commandline_environment"></a>Ch4 commandline_environment</h2><h3 id="Job-control"><a href="#Job-control" class="headerlink" title="Job control"></a>Job control</h3><p><code>jobs</code>: lists the unfinished jobs associated with the current terminal session.</p><p><code>fg + %num </code>: <code>num</code>是<code>jobs</code>命令显示进程对应的序号。</p><p><code>bg+ %num</code>: 让进程在后台从stopped-&gt;running。</p><p><code>ctrl + z</code>: 让当前进程进入后台并suspend。</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Missing semester</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/01/12/Note/23-01-12_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/01/12/Note/23-01-12_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://regexone.com/">RegexOne</a></p><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">github正则表达式</a></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230112170412.png"></p><p>需要转义的特殊字符：<br><code>* . ? + $ ^ [ ] ( ) { } | \ /</code></p><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><h2 id="Lesson-1-The-123s"><a href="#Lesson-1-The-123s" class="headerlink" title="Lesson 1 The 123s"></a>Lesson 1 The 123s</h2><p><code>\d</code>any single digit character</p><p><code>\D</code>any single non-digit character</p><h2 id="Lesson-2-The-Dot"><a href="#Lesson-2-The-Dot" class="headerlink" title="Lesson 2: The Dot"></a>Lesson 2: The Dot</h2><p><code>.</code>any single character</p><p><code>\.</code>period</p><h2 id="Lesson-3-Matching-specific-characters"><a href="#Lesson-3-Matching-specific-characters" class="headerlink" title="Lesson 3: Matching specific characters"></a>Lesson 3: Matching specific characters</h2><p><code>[abc]</code>only a, b, c single character</p><h2 id="Lesson-4-Excluding-specific-characters"><a href="#Lesson-4-Excluding-specific-characters" class="headerlink" title="Lesson 4: Excluding specific characters"></a>Lesson 4: Excluding specific characters</h2><p><code>[^abc]</code>not a, b or c</p><h2 id="Lesson-5-Character-ranges"><a href="#Lesson-5-Character-ranges" class="headerlink" title="Lesson 5: Character ranges"></a>Lesson 5: Character ranges</h2><p><code>[a-z]</code>characters a to z</p><p><code>[0-9]</code>number 0 to 9</p><p><code>\w</code>字母，数字，下划线。等价于<code>[A-Za-z0-9_]</code></p><p><code>\W</code>等价于<code>\[^A-Za-z0-9_]</code></p><h2 id="Lesson-6-Catching-some-zzz’s"><a href="#Lesson-6-Catching-some-zzz’s" class="headerlink" title="Lesson 6: Catching some zzz’s"></a>Lesson 6: Catching some zzz’s</h2><p><code>{m}</code>m repetitions</p><p><code>{m, n}</code>m to n repetitions</p><p>Examples:</p><p><code>w{3}</code> (three w)</p><p><code>[wxy]{5}</code> (five characters, each of which can be a w, x, or y)</p><h2 id="Lesson-7-Mr-Kleene-Mr-Kleene"><a href="#Lesson-7-Mr-Kleene-Mr-Kleene" class="headerlink" title="Lesson 7: Mr. Kleene, Mr. Kleene"></a>Lesson 7: Mr. Kleene, Mr. Kleene</h2><p><code>*</code> <strong>zero</strong> or more repetitions *前的字符可以重复0次或者更多次</p><p><code>+</code><strong>one</strong> or more repetitions +前的字符可以重复1次或者更多次</p><p>Match<code>aaaabcc</code></p><p>Match<code>aabbbbc</code></p><p>Match<code>aacc</code></p><p>Skip<code>a</code></p><p>answer: <code>aa+b*c+</code></p><h2 id="Lesson-8-Characters-optional"><a href="#Lesson-8-Characters-optional" class="headerlink" title="Lesson 8: Characters optional"></a>Lesson 8: Characters optional</h2><p><code>?</code>optional character ?前的字符可以出现0次或者1次</p><p><code>ab?c</code> will match either the strings “<code>abc</code>“ or “<code>ac</code>“</p><h2 id="Lesson-9-All-this-whitespace"><a href="#Lesson-9-All-this-whitespace" class="headerlink" title="Lesson 9: All this whitespace"></a>Lesson 9: All this whitespace</h2><p><code>\s</code>代替any whitespace 包括space, tab(\t), new line(\n), return(\r)</p><p><code>\S</code>相反</p><h2 id="Lesson-10-Starting-and-ending"><a href="#Lesson-10-Starting-and-ending" class="headerlink" title="Lesson 10: Starting and ending"></a>Lesson 10: Starting and ending</h2><p><code>^...$</code>starts and ends</p><p><code>^Mission: successful$</code>文本必须以Mission: 开头, successful结尾</p><h2 id="Lesson-11-Match-groups"><a href="#Lesson-11-Match-groups" class="headerlink" title="Lesson 11: Match groups"></a>Lesson 11: Match groups</h2><p><code>(...)</code>capture group</p><p><code>(a(bc))</code>capture sub-group</p><p><code>(.*)</code>capture all</p><h2 id="Lesson-14-It’s-all-conditional"><a href="#Lesson-14-It’s-all-conditional" class="headerlink" title="Lesson 14: It’s all conditional"></a>Lesson 14: It’s all conditional</h2><p><code>(abc|def)</code>matches abc or def</p><h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h1><h2 id="Problem-1-Matching-a-decimal-numbers"><a href="#Problem-1-Matching-a-decimal-numbers" class="headerlink" title="Problem 1: Matching a decimal numbers"></a>Problem 1: Matching a decimal numbers</h2><table><thead><tr><th>Task</th><th>Text</th></tr></thead><tbody><tr><td>Match</td><td>3.14529</td></tr><tr><td>Match</td><td>-255.34</td></tr><tr><td>Match</td><td>128</td></tr><tr><td>Match</td><td>1.9e10</td></tr><tr><td>Match</td><td>123,340.00</td></tr><tr><td>Skip</td><td>720p</td></tr></tbody></table><p>answer:<code>^-?\d+(,\d+)*(\.\d+(e\d+)?)?$</code></p><h2 id="Problem-2-Matching-phone-numbers"><a href="#Problem-2-Matching-phone-numbers" class="headerlink" title="Problem 2: Matching phone numbers"></a>Problem 2: Matching phone numbers</h2><p>后面还有很多problems</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表示式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沉默的大多数</title>
    <link href="/2023/01/11/reading/%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B9%90%E8%B6%A3/"/>
    <url>/2023/01/11/reading/%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B9%90%E8%B6%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="思维的乐趣"><a href="#思维的乐趣" class="headerlink" title="思维的乐趣"></a>思维的乐趣</h1><p>假如一个人每天吃一样的饭，干一样的活，再加上把八个样板戏翻过来倒过去地看，看到听了上句就知道下句的程度，就值得我最大的同情。我最赞同罗素先生的一句话：“须知参差多态，乃是幸福本源”。</p><p>在我们生活的这个世界上，最大的不幸就是有些人完全拒绝新奇。</p><p>这世界上有人喜欢丰富，有人喜欢单纯；我未见过喜欢丰富的人妒恨，伤害喜欢单纯的人，我见到的情形总是相反。</p><p>据此我认为我们国家自汉代以后，一直在进行思想上的大屠杀；而我能够这样想，只说明我是幸存者之一。除了对此表示悲伤之外，我想不到别的了。</p>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ICS2022 PA1</title>
    <link href="/2023/01/10/Project/ICS/PA1/"/>
    <url>/2023/01/10/Project/ICS/PA1/</url>
    
    <content type="html"><![CDATA[<h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># nemu/scripts/native.mk</span><br><br><span class="hljs-section">compile_git:</span><br>  <span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, "compile NEMU")</span><br><span class="hljs-variable">$(BINARY)</span>: compile_git<br><br><span class="hljs-keyword">override</span> ARGS ?= --log=<span class="hljs-variable">$(BUILD_DIR)</span>/nemu-log.txt<br><span class="hljs-keyword">override</span> ARGS += <span class="hljs-variable">$(ARGS_DIFF)</span> <span class="hljs-comment"># nemu/tools/difftest.mk中CONFIG_DIFFTEST未定义，所以ARGS_DIFF不存在</span><br><br>IMG ?=<br><br>NEMU_EXEC := <span class="hljs-variable">$(BINARY)</span> <span class="hljs-variable">$(ARGS)</span> <span class="hljs-variable">$(IMG)</span><br><br><span class="hljs-section">run: run-env</span><br>  <span class="hljs-variable">$(<span class="hljs-built_in">call</span> git_commit, "run NEMU")</span><br>  <span class="hljs-variable">$(NEMU_EXEC)</span><br><br></code></pre></td></tr></tbody></table></figure><p>由makefile可知，输入<code>make run</code>启动nemu时，传递给<code>monitor.c parse_args(argc, argv)</code>的参数为<br><code>--log=$(BUILD_DIR)/nemu-log.txt</code></p><h2 id="配置系统和项目构建"><a href="#配置系统和项目构建" class="headerlink" title="配置系统和项目构建"></a>配置系统和项目构建</h2><p>在<code>nemu</code>目录下执行<code>make menuconfig</code>,结果会保存至<code>nemu/.config</code></p><p>生成</p><p>可以被包含到C代码中的宏定义：<code>nemu/include/generated/autoconf.h</code></p><p>可以被包含到Makefile中的变量定义：<code>nemu/include/config/auto.conf</code></p><ul><li><code>SRCS-y</code> - 参与编译的源文件的候选集合</li><li><code>SRCS-BLACKLIST-y</code> - 不参与编译的源文件的黑名单集合</li><li><code>DIRS-y</code> - 参与编译的目录集合, 该目录下的所有文件都会被加入到SRCS-y中</li><li><code>DIRS-BLACKLIST-y</code> - 不参与编译的目录集合, 该目录下的所有文件都会被加入到SRCS-BLACKLIST-y中</li></ul><p>Makefile的编译规则在<code>nemu/scripts/build.mk</code>中定义。</p><h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p><a href="https://blog.csdn.net/derkampf/article/details/70661551">regcomp() regexec() regfree()详解</a><br><code>int regcomp (regex_t *compiled, const char *pattern, int cflags)</code><br><code>int regexec (regex_t *compiled, char *string, size_t nmatch, regmatch_t matchptr [], int eflags)</code></p><p>字符串中的转义需要两个<code>\\</code>,比如转义+号，<code>"\\+"</code><br><a href="https://zh.javascript.info/regexp-escaping#newregexp">转义，特殊字符</a></p><h2 id="一些字符串处理函数"><a href="#一些字符串处理函数" class="headerlink" title="一些字符串处理函数"></a>一些字符串处理函数</h2><p><code>strcat</code><br><code>strcmp</code><br><code>strstr</code><br><code>strtol</code></p><p><code>char *strtok(char *str, const char *delim)</code> 分解字符串 str 为一组字符串，delim 为分隔符。</p><p><code>atoi</code>函数：十进制字符串数字转为int类型。</p><p><code>long int strtol(const char *str, char **endptr, int base)</code>：可以根据字符串数字为10进制/16进制…，转化为<code>long int</code>。如<code>strtol(0xabc, NULL, 16)</code>。<br>base表示输入数字的进制，base为0表示自动判断输入的数字为8/10/16进制。</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第十章 RISC-V特权架构</title>
    <link href="/2023/01/09/Book/23-01-09_RISC-V%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2023/01/09/Book/23-01-09_RISC-V%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="10-1-导言"><a href="#10-1-导言" class="headerlink" title="10.1 导言"></a>10.1 导言</h2><p>到目前为止，本书主要关注RISC-V 对通用计算的支持：我们引入的所有指令都在用户模式（User mode 应用程序的代码在此模式下运行）下可用。本章介绍两种新的权限模式：运行最可信的代码的机器模式（machine mode），以及为Linux，FreeBSD 和Windows 等操作系统提供支持的监管者模式（supervisor mode）。</p><p>图10.1是RISC-V 特权指令的图形表示，图10.2列出了这些指令的操作码。显然，特权架构添加的指令非常少。作为替代，几个新的控制状态寄存器（CSR）显示了附加的功能。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.1.png"></p><h2 id="10-2-简单嵌入式系统的机器模式"><a href="#10-2-简单嵌入式系统的机器模式" class="headerlink" title="10.2 简单嵌入式系统的机器模式"></a>10.2 简单嵌入式系统的机器模式</h2><p>机器模式（缩写为M模式， M-mode）是 RISC-V中（hart hardware thread，硬件线程）可以执行的最高权限模式。程）可以执行的最高权限模式。在M模式下运行的hart对内存，I/O和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准RISC-V处理器都必须实现的权限模式。实际上简单的 RISC-V微控制器仅支持 M模式。</p><p>机器模式最重要的特性是拦截和处理异常的能力。RISC-V将异常分为两类。一类是同步异常。另一类是中断，它是与指令流异步的外部事件，比如鼠标的单击。</p><p>在 M模式运行期间可能发生的同步异常有五种：</p><ul><li><p>访问错误异常：当物理内存的地址不支持访问类型时发生（例如尝试写入 ROM）。</p></li><li><p>断点异常：在执行 ebreak指令，或者地址或数据与调试触发器匹配时发生。</p></li><li><p>环境调用异常：在执行 ecall指令时发生。</p></li><li><p>非法指令异常：在译码阶段发现无效操作码时发生。</p></li><li><p>非对齐地址异常：在有效地址不能被访问大小整除时发生，例如地址为0x12的amoadd.w。</p></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.3.png"></p><p>有三种标准的中断源：软件、时钟和外部来源。软件中断通过向内存映射寄存器中存数来触发。</p><h2 id="10-3-机器模式下的异常处理"><a href="#10-3-机器模式下的异常处理" class="headerlink" title="10.3 机器模式下的异常处理"></a>10.3 机器模式下的异常处理</h2><p>八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：</p><ul><li>mtvec (Machine Trap Vector) 它保存发生异常时处理器需要跳转到的地址。</li><li>mepc (Machine Exception PC) 它指向发生异常的指令。</li><li>mcause (Machine Exception Cause) 它指示发生异常的种类。</li><li>mie (Machine Interrupt Enable) 它指出处理器目前能处理和必须忽略的中断。</li><li>mip (Machine Interrupt Pending) 它列出目前正准备处理的中断。</li><li>mtval (Machine Trap Value) 它保存了陷入 trap 的附加信息：地址例外中出错的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0。</li><li>mscratch (Machine Scratch) 它暂时存放一个字大小的数据。</li><li>mstatus (Machine Status) 它保存全局中断使能，以及许多其他的状态，如图10.4所示。</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.4.png"></p><p>处理器在M模式下运行时，只有在全局中断使能位mstatus.MIE置1时才会产生中断。此外，每个中断在控制状态寄存器mie中都有自己的使能位。这些位在mie中的位置对应于图10.3中的中断代码。例如，mie[7]对应于M模式中的时钟中断。控制状态寄存器mip具有相同的布局，并且它指示当前待处理的中断。。将所有三个控制状态寄存器合在一起考虑，如果 mstatus.MIE = 1，mie[7] = 1，且 mip[7] = 1，则可以处理机器的时钟中断。</p><p>当一个hart发生异常时，硬件自动经历如下的状态转换：</p><div class="note note-info">            <p>hart是硬件线程 (hardware thread) 的缩略形式 。我们用该术语将它们与大多数程序员熟悉的软件线程区分开来。软件线程在 harts上进行分时复用。大多数处理器核都只有一个hart。</p>          </div><ul><li><p>异常指令的PC被保存在mepc中，PC被设置为 mtvec。（对于同步异常， mepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）</p></li><li><p>根据异常来源设置 mcause（如图 10.3所示），并将 mtval设置为出错的地址或者其它适用于特定异常的信息字。</p></li><li><p>把控制状态寄存器 mstatus中的 MIE位置零以禁用中断，并把先前的 MIE值保留到 MPIE中。</p></li><li><p>发生异常之前的权限模式保留在mstatus的MPP域中，再把权限模式更改为M。图 10.5显示了MPP域的编码（如果处理器仅实现M模式，则有效地跳过这个步骤）。</p></li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.5.png" alt="img"></p><p>为避免覆盖整数寄存器中的内容，中断处理程序先在最开始用mscratch和整数寄存器（例如 a0）中的值交换。通常，软件会让 mscratch包含指向附加临时内存空间的指针，处理程序用该指针来保存其主体中将会用到的整数寄存器。在主体执行之后，中断程序会恢复它保存到内存中的寄存器，然后再次使用 mscratch和 a0交换，将两个寄存器恢复到它们在发生异常之前的值。最后，处理程序用 mret指令（ M模式特有的指令）返回。 mret将 PC设置为mepc，通过将mstatus的 MPIE域复制到MIE来恢复之前的中断使能设置，并将权限模式设置为 mstatus的MPP域中的值。这基本是前一段中描述的逆操作。</p><p>图10.6展示了遵循此模式的基本时钟中断处理程序的 RISC-V汇编代码。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/10.6.png"></p><p>除了上面介绍的mret指令之外，M模式还提供了另外一条指令：wfi (Wait For Interrupt)。 wfi通 知处理器目前没有任何有用的工作，所有它应该进入低功耗模式，直到任何使能有效的中断等待处理，即 mie&amp;mip≠0。</p><div class="note note-info">            <p>操作 CSR 的指令在 RISC-V 的 <code>Zicsr</code> 扩展模块中定义。包括伪指令在内，共有以下 7 种操作类型：</p><ol><li><code>csrr</code>，读取一个 CSR 的值到通用寄存器。如：<code>csrr t0, mstatus</code>，读取 <code>mstatus</code> 的值到 <code>t0</code> 中。</li><li><code>csrw</code>，把一个通用寄存器中的值写入 CSR 中。如：<code>csrw mstatus, t0</code>，将 <code>t0</code> 的值写入 <code>mstatus</code>。</li><li><code>csrs</code>，把 CSR 中指定的 bit 置 1。如：<code>csrsi mstatus, (1 &lt;&lt; 2)</code>，将 <code>mstatus</code> 的右起第 3 位置 1。</li><li><code>csrc</code>，把 CSR 中指定的 bit 置 0。如：<code>csrci mstatus, (1 &lt;&lt; 2)</code>，将 <code>mstatus</code> 的右起第 3 位置 0。</li><li><code>csrrw</code>，读取一个 CSR 的值到通用寄存器，然后把另一个值写入该 CSR。如：<code>csrrw t0, mstatus, t0</code>，将 <code>mstatus</code> 的值与 <code>t0</code> 的值交换。</li><li><code>csrrs</code>，读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 1。</li><li><code>csrrc</code>，读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 0。</li></ol>          </div><h2 id="10-5-现代操作系统的监管者模式"><a href="#10-5-现代操作系统的监管者模式" class="headerlink" title="10.5 现代操作系统的监管者模式"></a>10.5 现代操作系统的监管者模式</h2><p>更复杂的 RISC-V处理器用和几乎所有通用架构相同的方式处理这些问题：使用基于页面的虚拟内存。这个功能构成了监管者模式（S模式）的核心，这是一种可选的权限模式，旨在支持现代类Unix操作系统，如Linux。S模式比 U模式权限更高，但比M模式低。与U模式一样，S模式下运行的软件不能使用M模式的CSR和指令，并且受到PMP的限制。</p><p>mideleg（Machine Interrupt Delegation），机器中断委托 CSR控制将哪些中断委托给S模式。与mip和mie一样，mideleg中的每个位对应于图10.3中相同的异常。例如，mideleg[5]对应于S模式的时钟中断，如果把它置位，S模式的时钟中断将会移交S模式的异常处理程序，而不是M模式的异常处理程序。</p><p>委托给S模式的任何中断都可以被S模式的软件屏蔽。sie (Supervisor Interrupt enable) 和sip (Superivisor Interrupt pending) CSR是S模式的控制状态寄存器。他们是mie和mip的子集。它们有着和M模式下相同的布局，但在sie和sip中只有与由mideleg委托的中断对应的位才能读写。那些没有被委派的中断对应的位始终为零。</p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第三、四章 RISC-V汇编语言，乘法和除法指令</title>
    <link href="/2023/01/06/Book/23-01-06_RISC-V%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0/"/>
    <url>/2023/01/06/Book/23-01-06_RISC-V%E7%AC%AC%E4%B8%89%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-RISC-V汇编语言"><a href="#第三章-RISC-V汇编语言" class="headerlink" title="第三章 RISC-V汇编语言"></a>第三章 RISC-V汇编语言</h1><h2 id="3-2-函数调用规范"><a href="#3-2-函数调用规范" class="headerlink" title="3.2 函数调用规范"></a>3.2 函数调用规范</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.2.png" alt="图3.2"></p><h2 id="3-3-汇编器"><a href="#3-3-汇编器" class="headerlink" title="3.3 汇编器"></a>3.3 汇编器</h2><p>这类指令在巧妙配置常规指令的基础上实现，称为<strong>伪指令</strong>。图 3.3和 3.4列出了 RISC-V伪指令。</p><p>汇编程序的开头是一些汇编指示符，它们是汇编器的命令。图 3.9是RISC-V的汇编指示符。其中图 3.6中用到的指示符有：</p><ul><li>.text：进入代码段。</li><li>.align 2：后续代码按2^2字节对齐。</li><li>.globl main：声明全局符号 “main”</li><li>.section .rodata：进入只读数据段</li><li>.balign 4：数据段按4字节对齐</li><li>.string “Hello, %s!\n”: 创建空字符结尾的字符串</li><li>.string “world”: 创建空字符结尾的字符串</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.3.png" alt="图3.3"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.4.png" alt="图3.4"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/%E5%9B%BE3.6.png" alt="图3.6"></p><h2 id="3-4-链接器"><a href="#3-4-链接器" class="headerlink" title="3.4 链接器"></a>3.4 链接器</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/3.9.png" alt="图3.9"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/3.10.png" alt="图3.10"></p><h2 id="3-5-静态链接和动态链接"><a href="#3-5-静态链接和动态链接" class="headerlink" title="3.5 静态链接和动态链接"></a>3.5 静态链接和动态链接</h2><p>上一节对 静态链接进行了说明，在程序运行前所有的库都进行了链接和加载。如果这样的库很大，链接一个库到多个程序中会十分占用内存。另外，链接时库是绑定的，即使它们后来的更新修复了 bug，强制的静态链接的代码仍然会使用旧的、有bug的版本。</p><p>为了解决这两个问题，现在的许多系统使用动态链接，外部的函数在第一次被调用时才会加载和链接。后续所有调用都使用快速链接，因此只会产生一次动态开销。每次程序开始运行，它都会按照需要链接最新版本的库函数。另外，如果多个程序使用了同一个动态链接库，库代码在内存中只会加载一次。</p><p>编译器产生的代码和静态链接的代码很相似。其不同之处在于，跳转的目标不是实际的函数，而是一个只有三条指令的存根函数（ stub function）。存根函数会从内存中的一个表中加载实际的函数的地址并跳转。不过，在第一次调用时，表中还没有实际的函数的地址，只有一个动态链接的过程的地址。当这个动态链接过程被调用时，动态链接器通过符号表找到实际要调用的函数，复制到内存中，更新记录实际的函数地址的表。后续的每次调用的开销就是存根函数的三条指令的开销。</p><h1 id="第四章-乘法和除法指令"><a href="#第四章-乘法和除法指令" class="headerlink" title="第四章 乘法和除法指令"></a>第四章 乘法和除法指令</h1><p>RV32M向RV32I中添加了整数乘法和除法指令。图4.1是RV32M扩展指令集的图形表示，图4.2列出了它们的操作码。</p><p>RV32M具有有符号和无符号整数的除法指令：divide(div)和divide unsigned(divu)，它们将商放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV32M提供remainder(rem)和remainder unsigned(remu)，它们在目标寄存器写入余数，而不是商。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.1.png" alt="图4.1"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.2.png" alt="图4.2"></p><p>将两个32位数相乘得到的是64位的乘积。为了正确地得到一个有符号或无符号的64位积，RISC-V中带有四个乘<br>法指令。要得到整数要得到整数32位乘积（ 64位中的低 32位）就用 mul指令。要得到高32位，如果操作数都是有符号数，就用mulh指令；如果操作数都是无符号数，就用mulhu指令。指令；如果一个有符号一个无符号，可以用mulhsu指令。在一条指令中完成把64位积写入两个 32位寄存器的操作会使硬件设计变得复杂，所以RV32M需要两条乘法指令才能得到一个完整的64位积。</p><p>对许多微处理器来说，整数除法是相对较慢的操作。如前述，除数为2的幂次的无符号除法可以用右移来代替。事实证明，通过乘以近似倒数再修正积的高32位的方法，可以优化除数为其它数的除法。例如，图 4.3显示了 3为除数的无符号除法的代码。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/4.3.png" alt="图4.3"></p><div class="note note-danger">            <p>lui t0, 0xaaaab 为什么t0=0xaaaaaaab而不是0xaaaab000</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V手册 第二章 RV32I基础整数指令集</title>
    <link href="/2023/01/06/Book/23-01-06_RISC-V%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/01/06/Book/23-01-06_RISC-V%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2-模块化与增量型-ISA"><a href="#1-2-模块化与增量型-ISA" class="headerlink" title="1.2 模块化与增量型 ISA"></a>1.2 模块化与增量型 ISA</h2><p>​和几乎所有以往的 ISA不同，RISC-V是模块化的。它的核心是一个名为RV32I的基础 ISA，运行一个完整的软件栈。RV32I是固定的，永远不会改变。模块化来源于可选的标准扩展，根据应用程序的需要，硬件可以包含或不包含这些扩展。可以生成当前硬件条件下的最佳代码。惯例是把代表扩展的字母附加到指令集名称之后作为指示。例如，RV32IMFD将乘法（ RV32M），单精度浮点（RV32F）和双精度浮点（RV32D）的扩展添加到了基础指令集 RV32I）中。</p><h2 id="2-2-RV32I-指令格式"><a href="#2-2-RV32I-指令格式" class="headerlink" title="2.2 RV32I 指令格式"></a>2.2 RV32I 指令格式</h2><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RV32I%E6%8C%87%E4%BB%A4%E5%9B%BE%E7%A4%BA.png" alt="图2.1: RV32指令图示"></p><p>​用于寄存器-寄存器操作的R类型指令，用于短立即数和访存load操作的I型指令，用于访存store操作的S型指令，用于条件跳转操作的B类型指令，用于长立即数的U型指令和用于无条件跳转的J型指令。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RISC%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="图2.2"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230131113244.png" alt="图2.3"></p><h2 id="2-3-RV32I-寄存器"><a href="#2-3-RV32I-寄存器" class="headerlink" title="2.3 RV32I 寄存器"></a>2.3 RV32I 寄存器</h2><p>​RV32I有31寄存器加上一个值恒为0的x0寄存器。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/RV32I%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="图2.4"></p><h2 id="2-4-RV32I-整数计算"><a href="#2-4-RV32I-整数计算" class="headerlink" title="2.4 RV32I 整数计算"></a>2.4 RV32I 整数计算</h2><p>​简单的算术指令（add, sub）、逻辑指令（and, or, xor），以及图2.1中的移位指令（sll, srl, sra）和其他ISA差不多。他们从寄存器读取两个32位的值，并将32位结果写入目标寄存器。</p><p>​程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I提供一个当小于时置位的指令（slt）。</p><p>​图2.1剩下的两条整数计算指令主要用于构造大的常量数值和链接。加载立即数到高位（lui）将20位常量加载到寄存器的高20位。接着便可以使用标准的立即指令来创建32位常量。</p><p><strong>有什么不同之处？</strong></p><ul><li>RISC-V中没有字节或半字宽度的整数计算操作。操作始终是以完整的寄存器宽度。</li><li>RV32I也不包含乘法和除法，它们包含在可选的RV32M扩展中。</li></ul><h2 id="2-5-RV32I-的Load-和-Store"><a href="#2-5-RV32I-的Load-和-Store" class="headerlink" title="2.5 RV32I 的Load 和 Store"></a>2.5 RV32I 的Load 和 Store</h2><p>​除了提供32位字（lw，sw）的加载和存储外，图2.1中说明，RV32I 支持加载有符号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）。有符号字节和半字符号扩展为32位再写入目的寄存器。即使是自然数据类型更窄，低位宽数据也是被扩展后再处理，这使得后续的整数计算指令能正确处理所有的32位。在文本和无符号整数中常用的无符号字节和半字，在写入目标寄存器之前都被无符号扩展到32位。</p><h2 id="RV32I-条件分支"><a href="#RV32I-条件分支" class="headerlink" title="RV32I 条件分支"></a>RV32I 条件分支</h2><p>​相等（beq），不相等 （bne），大于等于（bge），或小于（blt）。最后两种比较有符号比较，RV32I也提供相应的无符号版本比较的：bgeu和bltu。<strong>分支指令的寻址方式是12位的立即数乘以2，符号扩展它，然后将得到值加到PC上作为分支的跳转地址。</strong><span class="label label-danger">这句话没理解</span></p><div class="note note-info">            <p><strong>补充说明：获取PC</strong></p><p>当前的PC可以通过将auipc的U立即数字段设置为0来获得。</p>          </div><h2 id="2-7-RV32I无条件跳转"><a href="#2-7-RV32I无条件跳转" class="headerlink" title="2.7 RV32I无条件跳转"></a>2.7 RV32I无条件跳转</h2><p>​图2.1中的跳转并链接指令（jal）具有双重功能。若将下一条指令PC + 4的地址保存到目标寄存器中，通常是返回地址寄存器ra（见图2.4），便可以用它来实现过程调用。如果<strong>使用零寄存器（x0）替换ra作为目标寄存器</strong>，则可以实现无条件跳转，因为x0不能更改。像分支一样，jal将其20位分支地址乘以2，进行符号扩展后再添加到PC上，便得到了跳转地址。</p><div class="note note-info">            <p><code>jal x1, X</code> means jump to X, and save the return address which is normally PC+4 to the x1.</p><p><code>jal x0 0(x1)</code>  use indirect address (<code>x1</code>) plus a constant of 12bits (0 in your example). set <code>x0</code> as return address register because you «don’t care».</p>          </div><h2 id="2-8-RV32I-杂项"><a href="#2-8-RV32I-杂项" class="headerlink" title="2.8 RV32I 杂项"></a>2.8 RV32I 杂项</h2><p>​图2.1中的控制状态寄存器指令 (csrrc、csrrs、csrrw、csrrci、csrrsi、csrrwi)，使我们可以轻松地访问一些程序性能计数器。对于这些64位计数器, 我们一次可以读取32位。这些计数器包括了系统时间, 时钟周期以及执行的指令数目。</p><p>​在RISC-V指令集中，<strong>ecall</strong>指令用于向运行时环境发出请求，例如系统调用。调试器使用<strong>ebreak</strong>指令将控制转移到调试环境。</p><p>​<strong>fence</strong>指令对外部可见的访存请求，如设备I / O和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。fence.i指令同步指令和数据流。在执行fence.i指令之前，对于同一个硬件线程，RISC-V不保证用存储指令写到内存指令区的数据可以被取指令取到。</p><h2 id="2-10-结束语"><a href="#2-10-结束语" class="headerlink" title="2.10 结束语"></a>2.10 结束语</h2><ul><li>32位字节可寻址的地址空间</li><li>所有指令均为32位长</li><li>31个寄存器，全部32位宽，寄存器0硬连线为零</li><li>所有操作都在寄存器之间（没有寄存器到内存的操作）</li><li>加载/存储字加上有符号和无符号加载/存储字节和半字</li><li>所有算术，逻辑和移位指令都有立即数版本的指令</li><li>立即数总是符号扩展</li><li>仅提供一种数据寻址模式（寄存器+立即数）和PC相对分支</li><li>无乘法或除法指令</li><li>一个指令，用于将大立即数加载到寄存器的高位，这样加载32位常量到寄存器只需要两条指令</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.riscvbook.com/greencard-20181213.pdf">RISC-V Green Card</a></p><p><a href="http://www.riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V-Reader-Chinese-v2p1.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown and theme Fluid syntax</title>
    <link href="/2023/01/05/Ref/Markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/05/Ref/Markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><p>Method 1:</p><div class="note note-success">            <p>Markdown</p>          </div><figure class="highlight md"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">{% note success %}<br>success<br>{% endnote %}<br></code></pre></td></tr></tbody></table></figure><p>Method 2:</p><p class="note note-info">html</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-info"</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>Support various colors:</p><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-info">info</p><p class="note note-light">light</p><p><strong>inline tags</strong>:</p><span class="label label-danger">text</span> <span class="label label-warning">text</span><span class="label label-info">text</span> <span class="label label-success">text</span><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><blockquote><p>This is a blockquote with two paragraphs. This is first paragraph.</p><p>This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>red</li><li>green</li><li>blue</li></ul><h2 id="Task-list"><a href="#Task-list" class="headerlink" title="Task list"></a>Task list</h2><p>Method 1：</p><ul><li><input disabled="" type="checkbox"> a task list item</li><li><input checked="" disabled="" type="checkbox"> completed</li></ul><p>Method 2：</p><div>            <input type="checkbox" disabled="">a task list item          </div><div>            <input type="checkbox" disabled="" checked="checked">a task list item          </div>            <input type="checkbox" disabled="">a task list item          <p><a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">勾选框</a></p><h2 id="Code-block"><a href="#Code-block" class="headerlink" title="Code block"></a>Code block</h2><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">'redcarpet'</span><br>markdown = <span class="hljs-title class_">Redcarpet</span>.new(<span class="hljs-string">"Hello World!"</span>)<br>puts markdown.to_html<br></code></pre></td></tr></tbody></table></figure><p>inline code:<br><code>int a = 123</code></p><h2 id="Math-block"><a href="#Math-block" class="headerlink" title="Math block"></a>Math block</h2><p class="note note-warning">需要在front-matter中指定math：true</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =<br>\begin{bmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{bmatrix}<br>$$</p><p class="note note-danger">矩阵没法换行，有bug，以后换个LaTeX引擎</p><p>Inline math:<br>$\lim_{x \to \infty} \exp(-x) = 0$</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是对应的脚注">[1]</span></a></sup></p><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><hr><h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><p class="note note-warning">需要在front-matter中指定mermaid：true</p><pre><code class=" mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>This is <a href="http://www.baidu.com/" title="Baidu">Baidu</a> inline link.</p><h3 id="Internal-Links"><a href="#Internal-Links" class="headerlink" title="Internal Links"></a>Internal Links</h3><p><a href="#Tags">Internal link</a></p><h3 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links"></a>Reference Links</h3><p>看起来和Links的区别就是可以在文章其他地方定义链接</p><p>This is <a href="http://www.baidu.com/" title="Optional Title Here">Baidu</a> reference-style link.</p><h2 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h2><p>直接放网址的方式：</p><p><a href="https://yc-xiang.github.io/">https://yc-xiang.github.io/</a></p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><div align="center"><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png" width="50%"></div><p><strong>Method 1</strong>: html</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"50%"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>Method 2</strong>: Markdown</p><p>不能改格式大小<br><img src="/img/default.png" alt="图片标题"></p><p><strong>Method 3</strong>: Tags 插件</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div><div class="group-image-wrap"><img src="/img/default.png" alt="图片标题"></div></div></div><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><p><del>Mistaken text</del> <u>underline</u><br><strong>Bold</strong> <em>italic</em></p><!-- This is some comments --><h2 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h2><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><!-- This is some comments --><p>注释：<code>&lt;!-- This is some comments --&gt;</code></p><p>空行：<code>&lt;br /&gt;</code></p><h2 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h2><ul><li>表格：<code>ctrl+t</code></li><li>选中一整行：<code>ctrl+l</code></li><li>选中单词：<code>ctrl+d</code></li><li>插入图片：<code>ctrl+shift+i</code></li><li>插入链接：<code>ctrl + k</code></li><li>代码行: ctrl + shift + `</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://hexo.fluid-dev.com/docs/guide/">Hexo Fluid 用户手册</a></p><br><br><br><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令</title>
    <link href="/2023/01/04/Note/23_01-04_Git/"/>
    <url>/2023/01/04/Note/23_01-04_Git/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h1 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git push [远程主机名][本地分支名]:[远程分支名]</span><br>$ git push origin HEAD:master<br><span class="hljs-comment"># HEAD是当前指向的分支,可以用git show HEAD 查看</span><br>$ git show HEAD<br>$ git branch -a<br><span class="hljs-comment"># 需要code view 时要加/refs/for</span><br>$ git push origin HEAD:refs/for/master<br><br><span class="hljs-comment"># 不加远程分支名</span><br>$ git push origin dev<br><span class="hljs-comment"># 相当于,如果远程分支不存在则会自动创建, 并创建联系</span><br>$ git push origin dev:dev<br>$ git branch --set-upstream-to=origin/dev<br><span class="hljs-comment"># 删除远程分支，直接推送空分支到远程分支</span><br>$ git push origin :dev<br></code></pre></td></tr></tbody></table></figure><h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看unstaged的改动(还没git add)</span><br>$ git diff<br><span class="hljs-comment"># 查看staged的改动(git add过的)</span><br>$ git diff --staged<br><span class="hljs-comment"># 显示出branch1和branch2中差异的部分</span><br>$ git diff branch1 branch2 --<span class="hljs-built_in">stat</span><br><span class="hljs-comment"># 显示指定文件的详细差异</span><br>$ git diff branch1 branch2 具体文件路径<br><span class="hljs-comment"># 显示出所有有差异的文件的详细差异</span><br>$ git diff branch1 branch2<br><span class="hljs-comment"># 显示本地master分支与远程master分支的区别</span><br>$ git diff master origin/master<br><span class="hljs-comment"># 比较两个commit</span><br>git diff commit id1 commit id2<br></code></pre></td></tr></tbody></table></figure><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看前两个commit的修改</span><br>$ git <span class="hljs-built_in">log</span> -p -2<br><span class="hljs-comment"># 查看改动了哪些文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><span class="hljs-comment"># 每个commit一行展示</span><br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<br><span class="hljs-comment"># 展示合并历史</span><br>$ git <span class="hljs-built_in">log</span> --graph<br><span class="hljs-comment"># 从一定时间开始的commit</span><br>$ git <span class="hljs-built_in">log</span> --since=2.weeks<br>$ git <span class="hljs-built_in">log</span> --since=2008-01-15<br>$ git <span class="hljs-built_in">log</span> --since=2 years 1 day 3 minutes ago<br><span class="hljs-comment"># 查看哪些commit修改了function_name</span><br>$ git <span class="hljs-built_in">log</span> -S function_name<br><span class="hljs-comment"># 查看某个文件的commit</span><br>$ git <span class="hljs-built_in">log</span> -- path/to/file<br></code></pre></td></tr></tbody></table></figure><p>You can also filter the list to commits that match some search criteria. The <code>--author</code> option allows<br>you to filter on a specific author, and the <code>--grep</code> option lets you search for keywords in the commit<br>messages.<br><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/RISC-V%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/20230116143526.png"></p><h1 id="git-rebase-git-merge"><a href="#git-rebase-git-merge" class="headerlink" title="git rebase, git merge"></a>git rebase, git merge</h1><p>git merge：在dev分支git merge main，// 将main最新的commit拉到dev，有合并记录</p><p>git rebase：在dev分支git rebase main //修改dev分支，将main最新的commit拉到dev，将dev最新的commit 接到main后面</p><p>e.g 在本地一个分支上有了C5，C6两个自己的commit，但此时远程master分支上别人又合并了两个C3,C4分支。如果用git pull（git fetch + git merge）会有一个新的merge commit。此时需要git rebase 将c5,c6接到最新的master代码(c4)上。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git1.png"></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/git2.png"></p><h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>git revert + commit_id: revert掉指定的commit, 会生成一个新的commit，需要git push到远程。加上-n参数可以自定义commit信息。</p><h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>git stash save “add style to our site” 添加stash信息</p><p>git stash clear :注意这是清空你所有的内容</p><p>git stash drop stash@{0} 这是删除第一个队列</p><p>git stash apply 不会删除内容</p><p>git stash pop 删除内容</p><p>git stash 不能stash untracked的文件，需要先git add，或者git stash -u</p><p>查看某个stash的具体内容：git stash show -p stash@{1}</p><h1 id="git-放弃修改-放弃增加文件操作"><a href="#git-放弃修改-放弃增加文件操作" class="headerlink" title="git 放弃修改, 放弃增加文件操作"></a>git 放弃修改, 放弃增加文件操作</h1><p>1.本地修改了一些文件 (并没有使用 git add 到暂存区)，想放弃修改:</p><ul><li>单个文件: <code>git checkout -- filename</code></li><li>所有文件/文件夹: <code>git checkout .</code></li></ul><p>2.本地新增了一些文件 (并没有 git add 到暂存区)，想放弃修改:</p><ul><li>单个文件/文件夹: <code>rm  -rf filename</code></li><li>所有文件: <code>git clean -nxfd</code></li></ul><blockquote><p>-f 删除untracked files <br><br>-d 连untracked 的目录一起删掉 <br><br>-x 连 gitignore 的untrack 文件/目录也一起删掉（慎用,一般这个是用来删掉编译出来的.o之类的文件用的）<br><br>-n 先看看会删掉哪些文件，防止重要文件被误删</p></blockquote><p>3.本地修改/新增了一些文件，已经 git add 到暂存区，想放弃修改:</p><ul><li>单个文件/文件夹: <code>git reset HEAD filename</code></li><li>所有文件/文件夹: <code>git reset HEAD .</code></li></ul><p>4.本地通过 git add 和 git commit 后，想要撤销此次 commit：</p><ul><li><p>撤销 commit, 同时保留该 commit 修改：<code>git reset commit_id</code> (撤销之后，你所做的已经 commit 的修改还在工作区)</p></li><li><p>撤销 commit, 同时本地删除该 commit 修改：<code>git reset --hard commit_id</code> (撤销之后，你所做的已经 commit 的修改将会清除，仍在工作区/暂存区的代码也将会清除)</p></li></ul><blockquote><p>这里的commit id可以通过git log查看选取前6位，commit_id是想要回到的节点</p></blockquote><h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><blockquote><p>不要通过rebase对任何已经提交到公共仓库中的commit进行修改（你自己一个人玩的分支除外）</p></blockquote><h2 id="合并多个commit为一个完整commit"><a href="#合并多个commit为一个完整commit" class="headerlink" title="合并多个commit为一个完整commit"></a>合并多个commit为一个完整commit</h2><p><a href="https://www.jianshu.com/p/4a8f4af4e803">https://www.jianshu.com/p/4a8f4af4e803</a></p><p><code>git rebase -i HEAD~3</code> 修改HEAD往后三个分支（包括HEAD)</p><p>或者<code>git rebase -i 某个commit</code> 修改某个commit前的所有提交</p><p>然后<code>git push -f</code>可以修改远程的commit记录</p><h2 id="将某一段commit粘贴到另一个分支上"><a href="#将某一段commit粘贴到另一个分支上" class="headerlink" title="将某一段commit粘贴到另一个分支上"></a>将某一段commit粘贴到另一个分支上</h2><h1 id="git-patch"><a href="#git-patch" class="headerlink" title="git patch"></a>git patch</h1><h2 id="生成patch"><a href="#生成patch" class="headerlink" title="生成patch"></a>生成patch</h2><ol><li>git diff</li><li>git format-patch</li></ol><p>生成某个提交的补丁:</p><ul><li>git diff &gt; xxx.patch</li><li>生成单个commit的patch: git format-patch &lt;commit_id&gt; -1</li></ul><h2 id="git-apply"><a href="#git-apply" class="headerlink" title="git apply"></a>git apply</h2><p>git apply是另外一种打patch的命令，其与git am的区别是：git apply并不会将<strong>commit message</strong>等打上去，打完patch后需要重新<strong>git add和git commit</strong>。</p><p>2.检查补丁是否有冲突</p><p>git apply –check xxx.patch</p><p>3.无冲突打补丁</p><p>git apply xxx.patch</p><h2 id="git-am"><a href="#git-am" class="headerlink" title="git am"></a>git am</h2><p>git am会直接将patch的<strong>所有信息</strong>打上去，而且不用重新git add和git commit，author也是<strong>patch的author</strong>而不是打patch的人。</p><p>git am 之前可以git apply –check一下</p><p>无冲突：git am xxx.patch</p><p>有冲突：git am –reject xxx.patch</p><p>此时会在有冲突的文件相同文件夹生产一个以原来文件名加后缀为.rej的新文件，里面会告知哪些地方冲突了，</p><p>参考这些冲突的地方修改原文件即可</p><p>修改完成后添加到缓冲区 git add xxx1.c xxx2.c ….</p><p>最后 git am –continue 即可完成打补丁。</p><p>git commit –amend -s 可以添加自己的signed-off</p><p><a href="https://blog.csdn.net/u013318019/article/details/114860407">https://blog.csdn.net/u013318019/article/details/114860407</a></p><h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><p><a href="https://www.runoob.com/git/git-tag.html">https://www.runoob.com/git/git-tag.html</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有标签</span><br>$ git tag<br><br><span class="hljs-comment"># 创建</span><br>$ git tag -a v1.0<br><br><span class="hljs-comment"># 删除</span><br>$ git tag -d v1.0<br><br><span class="hljs-comment">#查看</span><br>$ git show v1.0<br><br><span class="hljs-comment"># 切换</span><br>git checkout v1.0<br></code></pre></td></tr></tbody></table></figure><p>tag 需要单独上传<code>git push origin &lt;tagname&gt;</code> 和删除``git push origin –delete <tagname>`</tagname></p><h1 id="创建分支并与远程某分支关联："><a href="#创建分支并与远程某分支关联：" class="headerlink" title="创建分支并与远程某分支关联："></a>创建分支并与远程某分支关联：</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以先更新远程分支信息</span><br>git remote update origin --prune<br><br><span class="hljs-comment"># git checkout -b 本地新分支 远程分支。远程分支可以git branch -a查看</span><br>git checkout -b <span class="hljs-built_in">test</span> origin/test<br><br><span class="hljs-comment"># 查看本地分支与远程分支匹配</span><br>git branch -vv<br><br><span class="hljs-comment"># 用下面的操作两个分支会对不上，无法git push，因为test分支可能是从master分支新建过来的，git log都不对应，需要一个干净的分支</span><br>git chekcout -b <span class="hljs-built_in">test</span><br>git branch --set-upstream-to=origin/develop<br></code></pre></td></tr></tbody></table></figure><h1 id="Pro-Git"><a href="#Pro-Git" class="headerlink" title="Pro Git"></a>Pro Git</h1><h1 id="1-Getting-Started"><a href="#1-Getting-Started" class="headerlink" title="1. Getting Started"></a>1. Getting Started</h1><h2 id="First-Time-Git-Setup"><a href="#First-Time-Git-Setup" class="headerlink" title="First-Time Git Setup"></a>First-Time Git Setup</h2><ol><li><code>[path]/etc/gitconfig</code> system全局配置，会影响所有用户。pass the option <code>--system</code> to <code>git config</code>可以修改全局配置。</li><li><code>~/.gitconfig</code> or <code>~/.config/git/config</code> user全局配置。pass the  option <code>--global</code> to <code>git config</code>可以修改用户配置。</li><li><code>config</code> file in the Git directory (that is, <code>.git/config</code>) 某个库的本地配置。pass the  option<code>--local</code> to <code>git config</code>可以修改某个库的配置。也是<code>git config</code>的默认选项。</li></ol><p>查看所有配置：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list --show-origin<br></code></pre></td></tr></tbody></table></figure><p><strong>Your Identity</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"John Doe"</span><br>$ git config --global user.email johndoe@example.com<br></code></pre></td></tr></tbody></table></figure><p><strong>Your Editor</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor vim<br></code></pre></td></tr></tbody></table></figure><p>可以通过</p><p><code>git config xxx.xxx</code>查看某个配置。</p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><p>在repository中不小心上传了大文件或者隐私数据：<br><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</a></p><p><strong>git alias</strong>: <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias">https://git-scm.com/docs/git-config#Documentation/git-config.txt-alias</a></p><p>git branch -f dev HEAD^  //让dev分支指向HEAD^</p><p>git remote show origin：查看远程信息</p><p>git branch –set-upstream-to=origin/develop（远程分支） develop：关联远程分支</p><p>那么如何查看已经配置分支关联信息呢，通过下述三条命令均可：</p><ol><li>git branch -vv</li><li>git remote show origin</li><li>cat .git/config</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://learngitbranching.js.org/">An online game to learn Git</a><br><a href="https://git-scm.com/book/en/v2">Pro Git</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电源管理</title>
    <link href="/2022/04/26/legacy/power_management/"/>
    <url>/2022/04/26/legacy/power_management/</url>
    
    <content type="html"><![CDATA[<p><strong>This article is out of date and need to rewrite.</strong></p><p><a href="http://www.wowotech.net/pm_subsystem/suspend_and_resume.html">http://www.wowotech.net/pm_subsystem/suspend_and_resume.html</a></p><p>Linux内核提供了三种Suspend: Freeze、Standby和STR(Suspend to RAM)，在用户空间向”/sys/power/state”文件分别写入”freeze”、”standby”和”mem”，即可触发它们。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo "freeze" &gt; /sys/power/state<br><br>echo "standby" &gt; /sys/power/state<br><br>echo "mem" &gt; /sys/power/state<br></code></pre></td></tr></tbody></table></figure><p>参考文章：</p><p><a href="https://www.cnblogs.com/arnoldlu/p/6253665.html">https://www.cnblogs.com/arnoldlu/p/6253665.html</a></p><p><strong>系统睡眠模型</strong></p><ul><li>On                                                           S0 - working</li><li>Standby                                                   S1 - CPU and RAM are powered but not executed</li><li>Suspend to RAM                                     S3 - RAM is powered and the running content is saved to RAM</li><li>Suspend to Disk , Hibernation(disk)       S4 - All content is saved to Disk and power down   嵌入式系统中一般没有</li></ul><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609175345.png"></p><p><strong>Runtime电源管理模型</strong></p><p>在运行状态下如何省电</p><p><strong>Linux系统Suspend的实现</strong></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230609175729.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">启动 suspend to ram：<br><br>echo mem &gt; sys/power/state<br><br><span class="hljs-title function_">state_store</span> <span class="hljs-params">(kernel/power/main.c)</span><br><span class="hljs-title function_">pm_suspend</span> <span class="hljs-params">(kernel/power/suspend.c)</span><br><span class="hljs-title function_">enter_state</span> <span class="hljs-params">(kernel/power/suspend.c)</span><br><span class="hljs-title function_">suspend_prepare</span> <span class="hljs-params">(kernel/power/suspend.c)</span><br><span class="hljs-title function_">pm_prepare_console</span><span class="hljs-params">(kernel/power/console.c)</span> <span class="hljs-comment">// 将当前console切换到一个虚拟console并重定向内核的kmsg</span><br><br>__<span class="hljs-title function_">pm_notifier_call_chain</span> <span class="hljs-params">(kernel/power/main.c)</span> <span class="hljs-comment">// 通知所有关系“休眠消息”的驱动程序</span><br><span class="hljs-title function_">suspend_freeze_processes</span> <span class="hljs-params">(kernel/power/power.h)</span> <span class="hljs-comment">// 冻结app和内核线程</span><br><span class="hljs-title function_">suspend_devices_and_enter</span> <span class="hljs-params">(kernel/power/suspend.c)</span> <span class="hljs-comment">// 让设备进入休眠状态</span><br>suspend_ops-&gt;begin 如果平台相关的代码有begin函数则调用它 ，**arm/arch/mach-realtek/pm.c**<br><br><span class="hljs-title function_">suspend_console</span> <span class="hljs-params">(kernel/power/suspend.c)</span><br><br><span class="hljs-title function_">dpm_suspend_start</span> <span class="hljs-params">(PMSG_SUSPEND)</span> <span class="hljs-params">(drivers/base/power/main.c)</span><br><span class="hljs-title function_">dpm_prepare</span><span class="hljs-params">(state)</span> <span class="hljs-params">(drivers/base/power/main.c)</span> 对于dmp_list链表中的每一个设备，都调用<span class="hljs-title function_">device_prepare</span><span class="hljs-params">(dev, state)</span>;<br><br>对于该设备调用它的dev→pm_domain→ops.prepare      或<br>                            dev→type→pm→prepare                或<br>                      dev→<span class="hljs-class"><span class="hljs-keyword">class</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">prepare</span>                或</span><br><span class="hljs-class">                      <span class="hljs-title">dev</span>→<span class="hljs-title">bus</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">prepare</span>                  或</span><br><span class="hljs-class">                      <span class="hljs-title">dev</span>→<span class="hljs-title">driver</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">prepare</span>               </span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">dpm_suspend</span>(<span class="hljs-title">state</span>) (<span class="hljs-title">drivers</span>/<span class="hljs-title">base</span>/<span class="hljs-title">power</span>/<span class="hljs-title">main</span>.<span class="hljs-title">c</span>) 让各类设备休眠，对于<span class="hljs-title">dpm_prepare_list</span>链表中的每一个设备，都调用<span class="hljs-title">device_suspend</span>(<span class="hljs-title">dev</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">__<span class="hljs-title">device_suspend</span>(<span class="hljs-title">dev</span>, <span class="hljs-title">pm_transition</span>, <span class="hljs-title">false</span>) </span><br><span class="hljs-class"></span><br><span class="hljs-class">对于该设备，调用它的<span class="hljs-title">dev</span>→<span class="hljs-title">pm_domain</span>→<span class="hljs-title">ops</span>.<span class="hljs-title">suspend</span> 或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-title">type</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend</span>           或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-keyword">class</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend</span>           或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-title">bus</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend</span>             或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-title">driver</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">suspend_enter</span>(<span class="hljs-title">state</span>, &amp;<span class="hljs-title">wakeup</span>) (<span class="hljs-title">kernel</span>/<span class="hljs-title">power</span>/<span class="hljs-title">suspend</span>.<span class="hljs-title">c</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">suspend_ops</span>→<span class="hljs-title">prepare</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">dpm_suspend_late</span>(<span class="hljs-title">state</span>) (<span class="hljs-title">drivers</span>/<span class="hljs-title">base</span>/<span class="hljs-title">power</span>/<span class="hljs-title">main</span>.<span class="hljs-title">c</span>) 对于<span class="hljs-title">dpm_suspend_list</span>链表中的每一个设备，都调用<span class="hljs-title">device_suspend_late</span>(<span class="hljs-title">dev</span>, <span class="hljs-title">state</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">对于该设备，调用它的<span class="hljs-title">dev</span>→<span class="hljs-title">pm_domain</span>→<span class="hljs-title">ops</span>.<span class="hljs-title">suspend_late</span> 或</span><br><span class="hljs-class">                               <span class="hljs-title">dev</span>→<span class="hljs-title">type</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend_late</span>           或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-keyword">class</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend_late</span>           或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-title">bus</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend_late</span>             或</span><br><span class="hljs-class">                         <span class="hljs-title">dev</span>→<span class="hljs-title">driver</span>→<span class="hljs-title">pm</span>→<span class="hljs-title">suspend_late</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">suspend_ops</span>→<span class="hljs-title">prepare_late</span>()</span><br><span class="hljs-class"><span class="hljs-title">disable_nonboot_cpus</span>()</span><br><span class="hljs-class"><span class="hljs-title">arch_suspend_disable_irqs</span>()</span><br><span class="hljs-class"><span class="hljs-title">syscore_suspend</span>()</span><br><span class="hljs-class"><span class="hljs-title">suspend_ops</span>→<span class="hljs-title">enter</span>(<span class="hljs-title">state</span>) </span><br><span class="hljs-class"><span class="hljs-title">power_attr</span>(<span class="hljs-title">state</span>);</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> power_attr(_name) \</span><br><span class="hljs-meta">static struct kobj_attribute _name##_attr = {  \</span><br><span class="hljs-meta">.attr  = {\</span><br><span class="hljs-meta">.name = __stringify(_name),  \</span><br><span class="hljs-meta">.mode = 0644,      \</span><br><span class="hljs-meta">},          \</span><br><span class="hljs-meta">.show  = _name##_show,\</span><br><span class="hljs-meta">.store  = _name##_store,\</span><br><span class="hljs-meta">}</span><br></code></pre></td></tr></tbody></table></figure><h1 id="给驱动程序添加电源管理功能"><a href="#给驱动程序添加电源管理功能" class="headerlink" title="给驱动程序添加电源管理功能"></a><strong>给驱动程序添加电源管理功能</strong></h1><h2 id="1-通知notifier"><a href="#1-通知notifier" class="headerlink" title="1. 通知notifier"></a>1. 通知notifier</h2><p>在冻结APP之前，使用pm_notifier_call_chain(PM_SUSPEND_PREPARE)来通知驱动程序</p><p>在重启APP后，使用pm_notifier_call_chain(PM_POST_SUSPEND)来通知驱动程序</p><p>如果驱动程序有事情在上述时机要处理，可以使用register_pm_notifier注册一个notifier</p><h2 id="添加suspend、resume函数（常用）"><a href="#添加suspend、resume函数（常用）" class="headerlink" title="添加suspend、resume函数（常用）"></a>添加suspend、resume函数（常用）</h2><p>在platform_driver中可以定义.suspend、.resume两个函数（老方法）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pinctrl-rts3917.c</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">rts_pinctrl_driver</span> =</span> {<br>  .probe = rts_pinctrl_probe,<br>  .remove = rts_pinctrl_remove,<br>  .suspend = rts_pinctrl_suspend,<br>  .resume = rts_pinctrl_resume,<br>  .driver = {<br>       .name = <span class="hljs-string">"pinctrl_rts3917"</span>,<br>       .owner = THIS_MODULE,<br>       .of_match_table = rts_pinctrl_match,<br>       },<br>};<br></code></pre></td></tr></tbody></table></figure><p>新的内核推荐在driver中定义一个.pm结构体，在其中实现suspend、resume，比如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> <span class="hljs-title">xxx</span> =</span> <br>{<br>              .suspend = rts_pinctrl_suspend,<br>              .resume = rts_pinctrl_resume,<br>}<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> platform_driver rts_pinctrl_driver = {<br>  .probe = rts_pinctrl_probe,<br>  .remove = rts_pinctrl_remove,<br>  .driver = {<br>       .name = <span class="hljs-string">"pinctrl_rts3917"</span>,<br>       .owner = THIS_MODULE,<br>       .of_match_table = rts_pinctrl_match,<br>       .pm = &amp;xxx,<br>       },<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="Runtime-PM"><a href="#Runtime-PM" class="headerlink" title="Runtime PM"></a>Runtime PM</h1><p>runtime PM 提供辅助函数：</p><ol><li>增加计数/减少计数</li><li>使能runtime PM</li></ol><p>内核驱动示例driver/dma/rts_dmac.c</p><p>修改驱动程序和使用：</p><ol><li>在dev_pm_ops中提供3个回调函数：runtime_suspend, runtime_resume, runtime_idle</li><li>在对应的系统调用接口里调用：</li></ol><p>probe函数中：pm_runtime_enable(&amp;pdev-&gt;dev); 使能Runtime PM 修改power.disable_depth变量</p><p>remove函数中：pm_runtime_disable(&amp;pdev-&gt;dev); 禁止Runtime PM 修改power.disable_depth变量</p><p>pm_runtime_get_sync(&amp;pdev-&gt;dev);  增加计数值</p><p>pm_runtime_put_sync(&amp;pdev-&gt;dev); 减小计数值</p><p>如何使用runtime PM：</p><ol><li><p>echo on &gt; /sys/devices/…/power/control  // 导致control_store-&gt;pm_runtime_forbid(dev);</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">                                                                               atomic<span class="hljs-constructor">_inc(&amp;<span class="hljs-params">dev</span>-&gt;<span class="hljs-params">power</span>.<span class="hljs-params">usage_count</span>)</span>;<br><br>                                                                               rpm<span class="hljs-constructor">_resume(<span class="hljs-params">dev</span>, 0)</span>;<br><br>echo auto &gt; /sys/devices/.../power/control <span class="hljs-comment">// 导致control_store-&gt;pm_runtime_allow(dev);</span><br><br>                                                                                 atomic<span class="hljs-constructor">_dec_and_test(&amp;<span class="hljs-params">dev</span>-&gt;<span class="hljs-params">power</span>.<span class="hljs-params">usage_count</span>)</span>;<br><br>                                                                                 rpm<span class="hljs-constructor">_idle(<span class="hljs-params">dev</span>, RPM_AUTO | RPM_ASYNC)</span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p>在对应的系统调用接口里调用：pm_runtime_get_sync / pm_runtime_put_sync</p></li><li><p>autosuspend: 如果不想让设备频繁开关，可以使用autosuspend功能</p><p>驱动里：执行pm_runtime_use_autosuspend来设置启动autosuspend功能</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">      put设备时，执行这两个函数：<br>   <br><span class="hljs-built_in">pm_runtime_mark_last_busy</span>();<br>   <br><span class="hljs-built_in">pm_runtime_put_sync_autosuspend</span>();<br></code></pre></td></tr></tbody></table></figure><p>用户空间：执行echo 秒数 &gt; /sys/devices/xxx/power/autosuspend_delay_ms</p></li></ol><p><strong>流程分析：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">pm_runtime_get_sync(include/linux/pm_runtime.h)<br>__pm_runtime_resume(dev, RPM_GET_PUT) (drivers/base/runtime.c)<br><span class="hljs-type">atomic_inc</span>(&amp;dev-&gt;power.usage_count);  <span class="hljs-comment">// 增加使用计数</span><br>rpm_resume(dev, rpmflags); <span class="hljs-comment">// resume 设备</span><br><span class="hljs-keyword">if</span> (dev-&gt;power.disable_depth &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 该变量初始值为1，要使用runtime PM，要先enable</span><br>retval = -EACCES;<br><span class="hljs-keyword">if</span> (!dev-&gt;power.timer_autosuspends) <span class="hljs-comment">// 为防止设备频繁地开关，可以设置autosuspends的值</span><br>pm_runtime_deactivate_timer(dev);<br><span class="hljs-keyword">if</span> (dev-&gt;power.runtime_status == RPM_ACTIVE) {  <span class="hljs-comment">// 如果设备已经是RPM_ACTIVE 就不用resume 直接返回</span><br><br><span class="hljs-comment">// 如果设备处于RPM_RESUMING或RPM_SUSPENDING，等待该操作完成</span><br><span class="hljs-comment">//Increment the parent's usage counter and resume it is necessary</span><br><span class="hljs-comment">//resume设备本身，前面4个函数被称为subsystem-level callback</span><br><br>callback = RPM_GET_CALLBACK(dev, runtime_resume);<br><br>ops = &amp;dev-&gt;pm_domain-&gt;ops-&gt;runtime_resume; 或<br>ops = dev-&gt;type-&gt;pm-&gt;runtime_resume;                 或<br>ops = dev-&gt;class-&gt;pm-&gt;runtime_resume;                或<br>ops = dev-&gt;bus-&gt;pm-&gt;runtime_resume;                  或<br><br>如果都没定义，则调用我们在驱动中定义的函数<br><br>dev-&gt;driver-&gt;pm-&gt;runtime_resume<br><br><span class="hljs-comment">// 成功时，给父亲的child_count加1</span><br><br><span class="hljs-keyword">if</span> (parent)<br><span class="hljs-type">atomic_inc</span>(&amp;parent-&gt;power.child_count);<br><br><span class="hljs-comment">// 唤醒其他进程</span><br><br>wake_up_all(&amp;dev-&gt;power.wait_queue);<br><br><span class="hljs-comment">// 如果resume失败，让设备进入idle状态</span><br><br><span class="hljs-keyword">if</span> (retval &gt;= <span class="hljs-number">0</span>)<br>rpm_idle(dev, RPM_ASYNC);<br><br>pm_runtime_put_sync<br><br>__pm_runtime_idle(dev, RPM_GET_PUT)<br><br>atomic_dec_and_test(&amp;dev-&gt;power.usage_count) <span class="hljs-comment">// 减小使用计数</span><br>rpm_idle(dev, rpmflags)                                           <span class="hljs-comment">// 让设备进入idle状态</span><br>rpm_check_suspend_allowed(dev);                     <span class="hljs-comment">// 检查是否允许设备进入suspend状态 </span><br><span class="hljs-keyword">if</span> (dev-&gt;power.disable_depth &gt; <span class="hljs-number">0</span>)                <span class="hljs-comment">// 失败</span><br><span class="hljs-keyword">if</span> (<span class="hljs-type">atomic_read</span>(&amp;dev-&gt;power.usage_count) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 当前的使用计数不是0也失败</span><br><span class="hljs-keyword">if</span> (!dev-&gt;power.ignore_children &amp;&amp;<br><span class="hljs-type">atomic_read</span>(&amp;dev-&gt;power.child_count))        <span class="hljs-comment">// 如果有子设备没suspend也失败</span><br><span class="hljs-keyword">if</span> (dev-&gt;power.runtime_status != RPM_ACTIVE)      <span class="hljs-comment">// 如果设备不是RPM_ACTIVE状态，直接返回也不用suspend了</span><br><br>callback = RPM_GET_CALLBACK(dev, runtime_idle);<br><br>ops = &amp;dev-&gt;pm_domain-&gt;ops-&gt;runtime_idle; 或<br>ops = dev-&gt;type-&gt;pm-&gt;runtime_idle;                 或<br>ops = dev-&gt;class-&gt;pm-&gt;runtime_idle;                或<br>ops = dev-&gt;bus-&gt;pm-&gt;runtime_idle;                  或<br><br>如果都没定义，则调用我们在驱动中定义的函数<br><br>dev-&gt;driver-&gt;pm-&gt;runtime_idle<br><br>__rpm_callback(callback, dev);<br><br>wake_up_all(&amp;dev-&gt;power.wait_queue);<br><br>如果设备不提供runtime_idle，则最终会调用runtime_suspend<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Legacy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Legacy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养学习笔记</title>
    <link href="/2022/01/27/Book/22-01-27_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <url>/2022/01/27/Book/22-01-27_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -h # 显示段结构<br>objdump -s # 将所有段以16进制打印出来<br>objdump -d # 反汇编<br>objdump -D # 反汇编更多信息<br>objdump -t # 查看符号<br>objdump -R # 查看目标文件重定位表<br><br>readelf -S # 显示段结构<br>readelf -h # 查看文件头<br>readelf -s # 查看符号表<br>readelf -l # 查看ELF加载时的Segment<br>readelf -d<br></code></pre></td></tr></tbody></table></figure><h1 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h1><h3 id="2-1-1-预处理"><a href="#2-1-1-预处理" class="headerlink" title="2.1.1 预处理"></a>2.1.1 预处理</h3><p>gcc –E hello.c –o hello.i</p><ul><li>展开宏定义</li><li>处理预编译指令 “#if”、“#ifdef”等等</li><li>处理 “#include ”预编译指令</li><li>删除注释</li><li>添加行号和文件名标识</li><li>保留所有的 #pragma 编译器指令</li></ul><h3 id="2-1-2-编译"><a href="#2-1-2-编译" class="headerlink" title="2.1.2 编译"></a>2.1.2 编译</h3><p>编译：gcc –S hello.i –o hello.s</p><p>预编译+编译：gcc –S hello.c –o hello.s</p><h3 id="2-1-3-汇编"><a href="#2-1-3-汇编" class="headerlink" title="2.1.3 汇编"></a>2.1.3 汇编</h3><p>汇编：gcc –c hello.c –o hello.o</p><p>-c表示只编译不链接。</p><h3 id="2-1-4-链接"><a href="#2-1-4-链接" class="headerlink" title="2.1.4 链接"></a>2.1.4 链接</h3><h1 id="第三章-目标文件里有什么"><a href="#第三章-目标文件里有什么" class="headerlink" title="第三章 目标文件里有什么"></a>第三章 目标文件里有什么</h1><h2 id="3-1-目标文件的格式"><a href="#3-1-目标文件的格式" class="headerlink" title="3.1 目标文件的格式"></a>3.1 目标文件的格式</h2><ul><li>可重定位文件 .o, .a</li><li>可执行文件</li><li>共享目标文件 .so</li><li>核心转储文件</li></ul><p><code>file</code> 命令可以查看文件格式</p><h2 id="3-3-挖掘SimpleSection-o"><a href="#3-3-挖掘SimpleSection-o" class="headerlink" title="3.3 挖掘SimpleSection.o"></a>3.3 挖掘SimpleSection.o</h2><p>查看obj文件内部的段表：</p><p><code>objdump -h SimpleSection.o</code> (只显示关键的段)</p><p><code>readelf -S SimpleSection.o</code> (显示所有段)</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230530212643.png"></p><ul><li><p>CONTENTS: 表示该段在文件中存在。可以看到.bss没有CONTENTS，说明在ELF文件中其实不存在，在加载到虚拟地址空间时才会分配空间。</p></li><li><p>ALLOC: 表示该段在进程空间需要分配空间。</p></li><li><p>WRITE: 该段在进程空间可写。</p></li></ul><p><code>objdump -s SimpleSection.o</code></p><p><code>objdump -d SimpleSection.o</code></p><p>or<code> objdump -s -d SimpleSection.o</code></p><p>-s参数：将所有段内容以16进制方式打印出来</p><p>-d参数：将所有包含指令的段反汇编</p><p>size命令用来查看ELF文件的代码段、数据段、BSS段的长度</p><p><code>size u-boot</code></p><p><strong>自定义段</strong>：</p><p>在全局变量或函数之前加上“__ attribute__((section(“name”))) ”属性就可以把相应的变量或函数放到以“ name ”作为段名的段中。</p><p><code>__attribute__((section("FOO"))) int global = 42;</code></p><p><code>__attribute__((section("BAR"))) void foo()</code></p><h2 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h2><p>查看ELF文件头：</p><p><code>readelf -h u-boot</code></p><table><thead><tr><th>ELF Header</th></tr></thead><tbody><tr><td>.text</td></tr><tr><td>.data</td></tr><tr><td>.bss</td></tr><tr><td>…other sections</td></tr><tr><td>Section header Table段表</td></tr><tr><td>.strtab(String tables)字符串表，保存字符串。</td></tr><tr><td>.symtab(Symbol tables)符号表，保存变量和函数的地址。</td></tr><tr><td>.shstrtab(Section string tables)段名表，保存段表的段名。</td></tr></tbody></table><h3 id="3-4-1-文件头"><a href="#3-4-1-文件头" class="headerlink" title="3.4.1 文件头"></a><strong>3.4.1 文件头</strong></h3><p>/usr/include/elf.h</p><h3 id="3-4-2-段表"><a href="#3-4-2-段表" class="headerlink" title="3.4.2 段表"></a><strong>3.4.2 段表</strong></h3><p>/usr/include/elf.h</p><p>段表位置可以通过readelf -h 查看elf文件头的start of section headers获得。</p><p>readelf输出的结果就是ELF文件段表的内容。以<code>ELF32_Shdr</code>为结构体的数组。数组元素的个数等于段的个数。</p><h3 id="3-4-3-重定位表"><a href="#3-4-3-重定位表" class="headerlink" title="3.4.3 重定位表"></a>3.4.3 重定位表</h3><p>readelf -S 中.rel.xxx的Link对应.symtab下表，Info对应.xxx段的下标。</p><h3 id="3-4-4-字符串表"><a href="#3-4-4-字符串表" class="headerlink" title="3.4.4 字符串表"></a>3.4.4 字符串表</h3><p>字符串集中存放到的一个表，使用字符串在表中的偏移来引用字符串。</p><h2 id="3-5-链接的接口-符号"><a href="#3-5-链接的接口-符号" class="headerlink" title="3.5 链接的接口-符号"></a>3.5 链接的接口-符号</h2><ul><li>定义在本文件的全局符号，可以被其他目标文件引用。</li><li>在本文件中引用的全局符号，但没有在本文件中定义。<strong>称为外部符号</strong>。</li><li>段名。</li><li>局部符号。</li><li>行号信息。</li></ul><p><code>nm</code>指令可以查看ELF文件的符号表。</p><h3 id="3-5-1-ELF符号表结构"><a href="#3-5-1-ELF符号表结构" class="headerlink" title="3.5.1 ELF符号表结构"></a>3.5.1 ELF符号表结构</h3><p><code>readelf -s SimpleSection.o</code> 也可以查看符号表。</p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230531212159.png"></p><ul><li><p>Size: 符号大小</p></li><li><p>Type: 符号类型</p><ul><li>NOTYPE</li><li>OBJECT(数据对象，变量/数组)</li><li>FUNC(函数)</li><li>SECTION(段)</li><li>FILE(文件名)</li></ul></li><li><p>Bind: 符号绑定信息</p><ul><li>LOCAL(局部符号)</li><li>GLOBAL(全局符号)</li><li>WEAK(弱引用)</li></ul></li><li><p>Vis不用管。</p></li><li><p>Ndx: 符号所在段</p><ul><li>ABS(表示符号包含一个绝对值，比如文件名的符号)</li><li>COMMON(未初始化的全局符号)</li><li>UNDEF(本目标文件引用，但定义在其他文件)</li></ul></li></ul><h2 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h2><p><code>strip</code>可以去掉ELF文件中的调试信息。</p><h1 id="第四章-静态连接"><a href="#第四章-静态连接" class="headerlink" title="第四章 静态连接"></a><strong>第四章 静态连接</strong></h1><h2 id="4-1-空间与地址分配"><a href="#4-1-空间与地址分配" class="headerlink" title="4.1 空间与地址分配"></a>4.1 空间与地址分配</h2><p>Linux下，ELF可执行文件默认从地址0x08048000开始分配。</p><h2 id="4-2-符号解析和重定位"><a href="#4-2-符号解析和重定位" class="headerlink" title="4.2 符号解析和重定位"></a><strong>4.2 符号解析和重定位</strong></h2><h3 id="4-2-2-重定位表"><a href="#4-2-2-重定位表" class="headerlink" title="4.2.2 重定位表"></a><strong>4.2.2 重定位表</strong></h3><p>.text ⇒ .rel.text</p><p>.data ⇒ .rel.data</p><p>查看目标文件重定位表：objdump -r a.o</p><h3 id="4-2-4-指令修正方式"><a href="#4-2-4-指令修正方式" class="headerlink" title="4.2.4 指令修正方式"></a><strong>4.2.4 指令修正方式</strong></h3><ul><li>绝对寻址修正，得到的是该符号的实际地址。<ul><li>S+A 符号的实际地址+被修正位置的值</li></ul></li><li>相对寻址修正,得到的是符号距离被修正的地址差。<ul><li>S+A-P 符号的实际地址+被修正位置的值-被修正的位置的地址</li></ul></li></ul><h2 id="4-3-COMMON块"><a href="#4-3-COMMON块" class="headerlink" title="4.3 COMMON块"></a><strong>4.3 COMMON块</strong></h2><p>把未初始化的全局变量标记为一个COMMON类型的变量。</p><p>链接完成后，在最终输出文件的BSS段为其分配空间。</p><h1 id="第六章-可执行文件的装载和进程"><a href="#第六章-可执行文件的装载和进程" class="headerlink" title="第六章 可执行文件的装载和进程"></a>第六章 可执行文件的装载和进程</h1><h2 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h2><p>0xC0000000<del>0xFFFFFFFF: 内核使用<br>0x0</del>0xC0000000: 进程使用</p><p>32位CPU使用的空间能否超过4GB?<br>mmap(), 可以将进程的一部分虚拟地址空间映射到不同的物理空间去。</p><h2 id="6-4-进程虚存空间分布"><a href="#6-4-进程虚存空间分布" class="headerlink" title="6.4 进程虚存空间分布"></a>6.4 进程虚存空间分布</h2><h3 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h3><p>对于相同权限的段(Section)，把它们合并到一起当作一个段映射。引入新的概念Segment。相当于从装载的角度重新划分了ELF文件的各个段(Section)。这样的好处是可以减少页面内部碎片。</p><p>查看ELF的Segment<code>readelf -l SectionMapping.elf</code></p><p><img src="https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230602161011.png"></p><ul><li><p>Type: LOAD/DYNAMIC/INTERP…</p></li><li><p>offset: Segment在文件中的偏移。</p></li><li><p>VirtAddr：Segment的第一个字节在进程虚拟地址空间的起始位置。</p></li><li><p>PhysAddr: 物理装载地址，一般和Virtaddr相同。</p></li><li><p>FileSize：Segment在ELF文件中所占的长度。</p></li><li><p>MemSize：Segment在进程虚拟地址空间所占的长度。</p></li></ul><p>MemSize可能比FileSize大的原因是，在进程虚拟地址空间中分配了bss段，而bss段在elf文件中其实是不存在的。</p><h3 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h3><p><code>cat /proc/&lt;pid_num&gt;/maps</code>可以查看进程的虚拟空间分布。</p><h1 id="第七章-动态链接"><a href="#第七章-动态链接" class="headerlink" title="第七章 动态链接"></a>第七章 动态链接</h1><p><code>gcc -fPIC -shared -o Lib.so Lib.c</code>生成动态链接库。</p><p><code>gcc -o program1 program1.c ./Lib.so</code> 编译program1.c，依赖于lib.so。</p><p>gcc -l 小写的L参数，用来指定共享库。或者更简洁的方式-lxxx，xxx为libxxx.so.2.6.1中的名字。</p><p>gcc -L 用来指定共享库目录。</p><h2 id="7-3-位置无关码"><a href="#7-3-位置无关码" class="headerlink" title="7.3 位置无关码"></a>7.3 位置无关码</h2><p><code>-fPIC</code>对共享文件编译生成位置无关码。<code>-fPIE</code>对可执行文件编译生成位置无关码。</p><p>.got段</p><h1 id="第八章-Linux共享库的组织"><a href="#第八章-Linux共享库的组织" class="headerlink" title="第八章 Linux共享库的组织"></a>第八章 Linux共享库的组织</h1><h3 id="8-1-2-共享库版本命名"><a href="#8-1-2-共享库版本命名" class="headerlink" title="8.1.2 共享库版本命名"></a>8.1.2 共享库版本命名</h3><p><code>libname.so.x.y.z</code></p><p>主版本号x表示库的重大升级，不同主版本号的库之间不兼容。<br>次版本号y表示库的增量升级，增加一些新的接口符号，且保持原来的符号不变，向后兼容的。<br>发布版本号z表示库的一些错误的修正、性能的改进，不添加任何新的接口，也不对接口进行更改。</p><h3 id="8-1-3-SO-NAME"><a href="#8-1-3-SO-NAME" class="headerlink" title="8.1.3 SO-NAME"></a>8.1.3 SO-NAME</h3><p>比如libfoo.so.2.6.1的SO-NAME为libfoo.so.2。Linux中，会在每个共享库目录中创建和SO-NAME相同的软链接。</p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux输入输出重定向</title>
    <link href="/2021/12/31/legacy/2021-12-31-linux%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2021/12/31/legacy/2021-12-31-linux%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>&amp;&gt;file  意思是把标准输出 和 标准错误输出 都重定向到文件file中</p><p>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</p><ul><li>command &gt; filename 把标准输出重定向到一个新文件中</li><li>command &gt;&gt; filename 把标准输出重定向到一个文件中(追加)</li><li>command 1 &gt; fielname 把标准输出重定向到一个文件中(和 &gt; 一样的)</li><li>command &gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到一个文件中</li><li>command 2 &gt; filename 把标准错误重定向到一个文件中</li><li>command 2 &gt;&gt; filename 把标准输出重定向到一个文件中(追加)</li><li>command &gt;&gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到一个文件中(追加)</li><li>command &lt; filename &gt;filename2 把command命令以filename文件作为标准输入，以filename2文件作为标准输出</li><li>command &lt; filename 把command命令以filename文件作为标准输入</li><li>command &lt;&lt; delimiter 把从标准输入中读入，直至遇到delimiter分界符</li><li>command &lt;&amp;m 把文件描述符m作为标准输入</li><li>command &gt;&amp;m 把标准输出重定向到文件描述符m中</li><li>command &lt;&amp;- 把关闭标准输入</li></ul><p><a href="https://blog.csdn.net/alex_xhl/article/details/5719381">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Legacy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Legacy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac Homebrew和gem下载源修改</title>
    <link href="/2021/12/24/legacy/2021-12-24-Homebrew-gem/"/>
    <url>/2021/12/24/legacy/2021-12-24-Homebrew-gem/</url>
    
    <content type="html"><![CDATA[<h2 id="Homebrew下载源修改"><a href="#Homebrew下载源修改" class="headerlink" title="Homebrew下载源修改"></a>Homebrew下载源修改</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HOMEBREW_INSTALL_FROM_API=1<br>export HOMEBREW_API_DOMAIN="https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api"<br>export HOMEBREW_BOTTLE_DOMAIN="https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"<br>export HOMEBREW_BREW_GIT_REMOTE="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"<br>export HOMEBREW_CORE_GIT_REMOTE="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"<br>export HOMEBREW_PIP_INDEX_URL="https://pypi.tuna.tsinghua.edu.cn/simple"<br></code></pre></td></tr></tbody></table></figure><h1 id="Gem下载源修改："><a href="#Gem下载源修改：" class="headerlink" title="Gem下载源修改："></a>Gem下载源修改：</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移除gem默认源，改成ruby-china源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gem sources -r https://rubygems.org/ -a https://gems.ruby-china.com/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Gemfile和Bundle的项目，可以做下面修改，就不用修改Gemfile的<span class="hljs-built_in">source</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除Bundle的一个镜像源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bundle config --delete <span class="hljs-string">'mirror.https://rubygems.org'</span></span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Legacy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Legacy</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
