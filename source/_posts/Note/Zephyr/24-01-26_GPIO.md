---
title: Zephyr -- GPIO Subsystem
date: 2024-01-26 09:30:28
tags:
- Zephyr
categories:
- Zephyr OS
---

# Device Tree

`dts/binding/gpio/gpio-controller.yaml`描述了设备树中支持的属性。

gpio-controller节点：
其中`gpio-controller`和`gpio-cells`两个属性是必须的。
前者表示gpio controller节点，后者表示其他节点使用gpio specifier需要几个item来描述。

```c
gpio: gpio@0x400ff000 {
	compatible = "nxp, kinetis-gpio";
	status = "disabled";
	reg = <0x400ff000 0x40>;
	interrupts = <59 2>;
	gpio-controller;
	#gpio-cells = <2>;
};
```

consumer节点:

```c
xxx-gpios/gpios = <&<gpio-controller节点> <gpio_number> <配置属性>>
xxx-gpios = <&gpio0 5 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>,
		<&gpio0 6 (GPIO_PULL_DOWN | GPIO_ACTIVE_LOW)>;
```

配置属性可在`include/zephyr/dt-bindings/gpio/gpio.h`中查找。

# Consumer

从设备树获取的gpio信息会保存到`gpio_dt_spec`结构体。包括gpio controller, pin number, config flag。对应上面device tree中consumer节点的node。

```c
struct gpio_dt_spec {
	/** GPIO device controlling the pin */
	const struct device *port;
	/** The pin's number on the device */
	gpio_pin_t pin;
	/** The pin's configuration flags as specified in devicetree */
	gpio_dt_flags_t dt_flags;
};
```

可以通过`GPIO_DT_SPEC_GET_BY_IDX()`或其他一系列变种函数解析dts获取`gpio_dt_spec`结构体。
`node_id`对应consumer的node，`prop`为`xxx-gpios`, `idx`为`xxx-gpios`下的第x条属性。

```c
#define GPIO_DT_SPEC_GET_BY_IDX(node_id, prop, idx)			       \
	{								       \
		.port = DEVICE_DT_GET(DT_GPIO_CTLR_BY_IDX(node_id, prop, idx)),\
		.pin = DT_GPIO_PIN_BY_IDX(node_id, prop, idx),		       \
		.dt_flags = DT_GPIO_FLAGS_BY_IDX(node_id, prop, idx),	       \
	}
```

得到`gpio_dt_spec`结构体后，就可以调用一系列函数来进行GPIO操作了。

```c
// 判断gpio controller是否ready
static inline bool gpio_is_ready_dt(const struct gpio_dt_spec *spec);
/** 设置GPIO中断, 可传入的gpio_flags_t有, 具体含义参考drivers/gpio.h:
 * GPIO_INT_EDGE_RISING
 * GPIO_INT_EDGE_FALLING
 * GPIO_INT_EDGE_BOTH
 * GPIO_INT_LEVEL_LOW
 * GPIO_INT_LEVEL_HIGH
 * ...
 **/
static inline int gpio_pin_interrupt_configure_dt(const struct gpio_dt_spec *spec,
						  gpio_flags_t flags);
//
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
```

# Provider

需要实现的API:

```c
__subsystem struct gpio_driver_api {
	int (*pin_configure)(const struct device *port, gpio_pin_t pin,
			     gpio_flags_t flags);
#ifdef CONFIG_GPIO_GET_CONFIG
	int (*pin_get_config)(const struct device *port, gpio_pin_t pin,
			      gpio_flags_t *flags);
#endif
	int (*port_get_raw)(const struct device *port,
			    gpio_port_value_t *value);
	int (*port_set_masked_raw)(const struct device *port,
				   gpio_port_pins_t mask,
				   gpio_port_value_t value);
	int (*port_set_bits_raw)(const struct device *port,
				 gpio_port_pins_t pins);
	int (*port_clear_bits_raw)(const struct device *port,
				   gpio_port_pins_t pins);
	int (*port_toggle_bits)(const struct device *port,
				gpio_port_pins_t pins);
	int (*pin_interrupt_configure)(const struct device *port,
				       gpio_pin_t pin,
				       enum gpio_int_mode, enum gpio_int_trig);
	int (*manage_callback)(const struct device *port,
			       struct gpio_callback *cb,
			       bool set);
	uint32_t (*get_pending_int)(const struct device *dev);
#ifdef CONFIG_GPIO_GET_DIRECTION
	int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,
				  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);
#endif /* CONFIG_GPIO_GET_DIRECTION */
};
```
