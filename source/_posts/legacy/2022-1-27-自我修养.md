---
layout:     post
title:      程序员的自我修养学习笔记
subtitle:
date:       2022-1-27
author:     YC-Xiang
header-img:
catalog: true
tags:
    - 程序员的自我修养
---

# 第二部分 静态链接

## 第二章 编译和链接

### 2.1.1 预处理

gcc –E hello.c –o hello.i

- 展开宏定义
- 处理预编译指令 “#if”、“#ifdef”等等
- 处理 “#include ”预编译指令
- 删除注释
- 添加行号和文件名标识
- 保留所有的 #pragma 编译器指令

### 2.1.2 编译

编译：gcc –S hello.i –o hello.s

预编译+编译：gcc –S hello.c –o hello.s

### 2.1.3 汇编

汇编：gcc –c hello.c –o hello.o

-c表示只编译不链接。

### 2.1.4 链接

## 第三章 目标文件里有什么

### 3.1 目标文件的格式

- 可重定位文件 .o, .a
- 可执行文件
- 共享目标文件 .so
- 核心转储文件

`file` 命令可以查看文件格式

### 3.3 挖掘SimpleSection.o

查看obj文件内部的段表：

objdump -h SimpleSection.o (只显示关键的段)

readelf -S SimpleSection.o (显示所有段)

![](https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230530212643.png)

“CONTENTS”表示该段在文件中存在。可以看到.bss没有CONTENTS，说明在ELF文件中其实不存在。



objdump -s SimpleSection.o

objdump -d SimpleSection.o

or objdump -s -d SimpleSection.o

-s参数：将所有段内容以16进制方式打印出来

-d参数：将所有包含指令的段反汇编



size命令用来查看ELF文件的代码段、数据段、BSS段的长度

size u-boot



**自定义段**：

在全局变量或函数之前加上“__ attribute__((section(“name”))) ”属性就可以把相应的变量或函数放到以“ name ”作为段名的段中。

`__attribute__((section("FOO"))) int global = 42;`

`__attribute__((section("BAR"))) void foo()`

### 3.4 ELF文件结构描述

查看ELF文件头：

readelf -h u-boot

| ELF Header                                               |
| -------------------------------------------------------- |
| .text                                                    |
| .data                                                    |
| .bss                                                     |
| ...other sections                                        |
| Section header Table段表                                 |
| .strtab(String tables)字符串表，保存字符串。             |
| .symtab(Symbol tables)符号表，保存变量和函数的地址。     |
| .shstrtab(Section string tables)段名表，保存段表的段名。 |

#### **3.4.1 文件头**

/usr/include/elf.h

#### **3.4.2 段表**

/usr/include/elf.h

段表位置可以通过readelf -h 查看elf文件头的start of section headers获得。

readelf输出的结果就是ELF文件段表的内容。以`ELF32_Shdr`为结构体的数组。数组元素的个数等于段的个数。

#### 3.4.3 重定位表

readelf -S 中.rel.xxx的Link对应.symtab下表，Info对应.xxx段的下标。

#### 3.4.4 字符串表

字符串集中存放到的一个表，使用字符串在表中的偏移来引用字符串。

### 3.5 链接的接口-符号

- 定义在本文件的全局符号，可以被其他目标文件引用。
- 在本文件中引用的全局符号，但没有在本文件中定义。**称为外部符号**。
- 段名。
- 局部符号。
- 行号信息。

**nm**指令可以查看ELF文件的符号表。

## **第四章 静态连接**

## **4.2 符号解析和重定位**

### **4.2.2 重定位表**

.text ⇒ .rel.text

.data ⇒ .rel.data

查看目标文件重定位表：objdump -r a.o

### **4.2.4 指令修正方式**

- 绝对寻址修正
- 相对寻址修正

## **4.3 COMMON块**

把未初始化的全局变量标记为一个COMMON类型的变量。

链接完成后，在最终输出文件的BSS段为其分配空间。

# 可执行文件的装载和进程

## 6.1 进程虚拟地址空间

0xC0000000~0xFFFFFFFF: 内核使用
0x0~0xC0000000: 进程使用

32位CPU使用的空间能否超过4GB?
mmap(), 可以将进程的一部分虚拟地址空间映射到不同的物理空间去。

## 6.4 进程虚存空间分布

### 6.4.1 ELF文件链接视图和执行视图

对于相同权限的段(Section)，把它们合并到一起当作一个段映射。引入新的概念Segment。相当于从装载的角度重新划分了ELF文件的各个段(Section)。这样的好处是可以减少页面内部碎片。

查看ELF的Segment`readelf -l SectionMapping.elf`

![](https://xyc-1316422823.cos.ap-shanghai.myqcloud.com/20230602161011.png)

- Type: LOAD/DYNAMIC/INTERP...

- offset: Segment在文件中的偏移。

- VirtAddr：Segment的第一个字节在进程虚拟地址空间的起始位置。

- PhysAddr: 物理装载地址，一般和Virtaddr相同。

- FileSize：Segment在ELF文件中所占的长度。

- MemSize：Segment在进程虚拟地址空间所占的长度。

MemSize可能比FileSize大的原因是，在进程虚拟地址空间中分配了bss段，而bss段在elf文件中其实是不存在的。

### 6.4.2 堆和栈

`cat /proc/<pid_num>/maps`可以查看进程的虚拟空间分布。

# 动态链接

`gcc -fPIC -shared -o Lib.so Lib.c`生成动态链接库。

`gcc -o program1 program1.c ./Lib.so` 编译program1.c，依赖于lib.so。